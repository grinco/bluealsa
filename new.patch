diff --git a/.travis.yml b/.travis.yml
index 252daa9..092e92f 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,13 +1,12 @@
 sudo: true
-dist: trusty
+dist: xenial
 
 language: c
 
 addons:
   apt:
-    sources:
-      - sourceline: 'deb http://cz.archive.ubuntu.com/ubuntu xenial main'
     packages:
+      - check
       - libasound2-dev
       - libbluetooth-dev
       - libbsd-dev
@@ -19,8 +18,13 @@ addons:
 
 before_script:
   - mkdir -p m4
+  - sed -i -e 's$/var/run$.$' configure.ac
   - autoreconf --install && mkdir build && cd build
 
 script:
-  - ../configure && make && make check
-  - ../configure --enable-aac && make && make check
+  - ../configure --enable-test && make && make check
+  - cat test/*.log
+  - ../configure --enable-test --enable-debug && make && make check
+  - cat test/*.log
+  - ../configure --enable-test --enable-aac && make && make check
+  - cat test/*.log
diff --git a/LICENSE.txt b/LICENSE.txt
index 0a9d5fd..fc15c38 100644
--- a/LICENSE.txt
+++ b/LICENSE.txt
@@ -1,6 +1,7 @@
 The MIT License
 
 Copyright (c) 2016-2018 Arkadiusz Bokowy <arkadiusz.bokowy@gmail.com>
+              2018 Jörg Krause
               2018 Parthiban Nallathambi
               2018 René Rebe
               2018 Wade Berrier
diff --git a/Makefile.am b/Makefile.am
index cebd107..fe76d2c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,9 @@
 # BlueALSA - Makefile.am
-# Copyright (c) 2016 Arkadiusz Bokowy
+# Copyright (c) 2016-2018 Arkadiusz Bokowy
 
 ACLOCAL_AMFLAGS = -I m4
-SUBDIRS = src utils test
+SUBDIRS = src utils
+
+if ENABLE_TEST
+SUBDIRS += test
+endif
diff --git a/README.md b/README.md
index 25d08f0..5cdf8db 100644
--- a/README.md
+++ b/README.md
@@ -41,6 +41,8 @@ Dependencies:
 - [sbc](https://git.kernel.org/cgit/bluetooth/sbc.git)
 - [fdk-aac](https://github.com/mstorsjo/fdk-aac) (when AAC support is enabled with `--enable-aac`)
 - [openaptx](https://github.com/Arkq/openaptx) (when apt-X support is enabled with `--enable-aptx`)
+- [libldac](https://android.googlesource.com/platform/external/libldac) (when LDAC support is
+		enabled with `--enable-ldac`)
 
 Dependencies for `bluealsa-rfcomm` (when `--enable-rfcomm` is specified during configuration):
 
@@ -122,12 +124,21 @@ Troubleshooting
 	affect hardware audio devices (because for hardware devices, this change is disabled), but it
 	affects A LOT all software plug-ins. Random deadlocks are inevitable. My personal advice is to
 	disable it during alsa-lib configuration step (`./configure --disable-thread-safety` - of
-	course, if one is compiling alsa-lib from source), or if it is not possible (instalation from a
+	course, if one is compiling alsa-lib from source), or if it is not possible (installation from a
 	package repository), disable it via an environmental variable, as follows: `export
 	LIBASOUND_THREAD_SAFE=0`. Just take a look at involved
 	[hacks](http://git.alsa-project.org/?p=alsa-lib.git;a=blob;f=src/pcm/pcm_ioplug.c;h=1dc198e7c99c933264fa25c9d7dbac5153bf0860;hb=1bf144013cffdeb41a5df3a11a8eb2596c5ea2b5#l682)
 	(search for "to avoid deadlock" comments) and decide for yourself.
 
+3. Couldn't bind controller socket: Address already in use
+
+	It is not possible to run more than one instance of the BlueALSA server per HCI device. If one
+	tries to run second instance, it fails with the `"Couldn't bind controller socket: Address
+	already in use"` error message. This error message might also appear when the previous BlueALSA
+	server has crashed unexpectedly. In order to recover from this error, one has to manually remove
+	dangling socket located in the `/var/run/bluealsa` directory (this location might be different
+	for non standard configuration).
+
 
 Resources
 ---------
diff --git a/configure.ac b/configure.ac
index 3acf308..1e2a9d8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,13 +1,14 @@
 # BlueALSA - configure.ac
-# Copyright (c) 2016-2018 Arkadiusz Bokowy
+# Copyright (c) 2016-2019 Arkadiusz Bokowy
 
-AC_PREREQ([2.59])
-AC_INIT([bluez-alsa], [1.3.0], [arkadiusz.bokowy@gmail.com])
+AC_PREREQ([2.60])
+AC_INIT([bluez-alsa], [1.3.1], [arkadiusz.bokowy@gmail.com])
 AM_INIT_AUTOMAKE([foreign subdir-objects -Wall -Werror])
 
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_MACRO_DIR([m4])
 
+AC_USE_SYSTEM_EXTENSIONS
 AC_PROG_CC
 AC_PROG_INSTALL
 AM_PROG_AR
@@ -18,6 +19,15 @@ LT_INIT
 AC_PREFIX_DEFAULT([/usr])
 AC_SUBST([runstatedir], [/var/run])
 
+# testing presence of pkg-config
+AC_MSG_CHECKING([pkg-config m4 macros])
+if test m4_ifdef([PKG_CHECK_MODULES], [yes], [no]) = "yes"; then
+	AC_MSG_RESULT([yes]);
+else
+	AC_MSG_RESULT([no]);
+	AC_MSG_ERROR([pkg-config is required. See pkg-config.freedesktop.org])
+fi
+
 # support for debugging
 AC_ARG_ENABLE([debug],
 	AS_HELP_STRING([--enable-debug], [enable debugging support]))
@@ -39,6 +49,8 @@ AC_SEARCH_LIBS([clock_gettime], [rt],
 	[], [AC_MSG_ERROR([unable to find clock_gettime() function])])
 AC_SEARCH_LIBS([pow], [m],
 	[], [AC_MSG_ERROR([unable to find pow() function])])
+AC_CHECK_FUNCS([splice],
+	[], [AC_MSG_ERROR([unable to find splice() function])])
 
 PKG_CHECK_MODULES([ALSA], [alsa])
 PKG_CHECK_MODULES([BLUEZ], [bluez >= 5.0])
@@ -47,6 +59,7 @@ PKG_CHECK_MODULES([GIO2], [gio-unix-2.0])
 PKG_CHECK_MODULES([SBC], [sbc >= 1.2])
 
 AM_CONDITIONAL([ALSA_1_1_2], [$PKG_CONFIG --atleast-version=1.1.2 alsa])
+AM_CONDITIONAL([ALSA_1_1_7], [$PKG_CONFIG --atleast-version=1.1.7 alsa])
 
 AC_ARG_ENABLE([aac],
 	[AS_HELP_STRING([--enable-aac], [enable AAC support])])
@@ -64,6 +77,22 @@ AM_COND_IF([ENABLE_APTX], [
 	AC_DEFINE([ENABLE_APTX], [1], [Define to 1 if apt-X is enabled.])
 ])
 
+AC_ARG_ENABLE([ldac],
+	[AS_HELP_STRING([--enable-ldac], [enable LDAC support])])
+AM_CONDITIONAL([ENABLE_LDAC], [test "x$enable_ldac" = "xyes"])
+AM_COND_IF([ENABLE_LDAC], [
+	PKG_CHECK_MODULES([LDAC], [libldacBT >= 2.0.0])
+	PKG_CHECK_MODULES([LDAC_ABR], [libldacBT_abr >= 2.0.0])
+	AC_DEFINE([ENABLE_LDAC], [1], [Define to 1 if LDAC is enabled.])
+])
+
+AC_ARG_ENABLE([ofono],
+	AS_HELP_STRING([--enable-ofono], [enable HFP over oFono]))
+AM_CONDITIONAL([ENABLE_OFONO], [test "x$enable_ofono" = "xyes"])
+AM_COND_IF([ENABLE_OFONO], [
+	AC_DEFINE([ENABLE_OFONO], [1], [Define to 1 if oFono is enabled.])
+])
+
 AC_ARG_ENABLE([payloadcheck],
 	[AS_HELP_STRING([--disable-payloadcheck], [disable RTP payload type check (workaround for a PulseAudio bug)])])
 AM_CONDITIONAL([ENABLE_PAYLOADCHECK], [test "x$enable_payloadcheck" != "xno"])
@@ -87,34 +116,38 @@ AM_COND_IF([ENABLE_HCITOP], [
 	PKG_CHECK_MODULES([NCURSES], [ncurses])
 ])
 
-# Since it is not possible to specify custom ALSA plugin directory, BlueALSA
-# PCM plugin has to be installed prior to this test.
-AC_ARG_ENABLE([pcm-test],
-	[AS_HELP_STRING([--enable-pcm-test], [enable PCM plugin test])])
-AM_CONDITIONAL([ENABLE_PCM_TEST], [test "x$enable_pcm_test" = "xyes"])
+AC_ARG_ENABLE([test],
+	[AS_HELP_STRING([--enable-test], [enable unit test])])
+AM_CONDITIONAL([ENABLE_TEST], [test "x$enable_test" = "xyes"])
+AM_COND_IF([ENABLE_TEST], [
+	PKG_CHECK_MODULES([CHECK], [check >= 0.9.10])
+])
 
 AC_ARG_WITH([alsaplugindir],
 	AS_HELP_STRING([--with-alsaplugindir=dir], [path where ALSA plugin files are stored]),
 	[alsaplugindir="$withval"], [alsaplugindir=$($PKG_CONFIG --variable=libdir alsa)/alsa-lib])
-AC_ARG_WITH([alsadatadir],
-	AS_HELP_STRING([--with-alsadatadir=dir], [directory containing ALSA data files]),
-	[alsadatadir="$withval"], [alsadatadir="$datadir/alsa"])
+AC_ARG_WITH([alsaconfdir],
+	AS_HELP_STRING([--with-alsaconfdir=dir], [directory containing ALSA add-on configuration files]),
+	[alsaconfdir="$withval"],
+	[AM_COND_IF([ALSA_1_1_7],
+		[alsaconfdir="$sysconfdir/alsa/conf.d"],
+		[alsaconfdir="$datadir/alsa/alsa.conf.d"])])
 
 test "x$prefix" = xNONE && prefix=$ac_default_prefix
 test "x$exec_prefix" = xNONE && exec_prefix=$prefix
 
 # TODO: Get rid of "ev(a|i)l" statements.
 # TIP: Wizard-level Autotconf coder is needed.
-eval alsadatadir="$alsadatadir"
-eval alsadatadir="$alsadatadir"
+eval alsaconfdir="$alsaconfdir"
+eval alsaconfdir="$alsaconfdir"
 eval alsaplugindir="$alsaplugindir"
 eval alsaplugindir="$alsaplugindir"
 
-AC_DEFINE_UNQUOTED([ALSA_DATA_DIR], "$alsadatadir", [Directory containing ALSA data files.])
+AC_DEFINE_UNQUOTED([ALSA_CONF_DIR], "$alsaconfdir", [Directory containing ALSA add-on configuration files.])
 AC_DEFINE_UNQUOTED([ALSA_PLUGIN_DIR], "$alsaplugindir", [Directory containing ALSA add-on modules.])
 AC_DEFINE_UNQUOTED([RUN_STATE_DIR], "$runstatedir", [Path where run statuses are stored.])
 
-AC_SUBST([ALSA_DATA_DIR], [$alsadatadir])
+AC_SUBST([ALSA_CONF_DIR], [$alsaconfdir])
 AC_SUBST([ALSA_PLUGIN_DIR], [$alsaplugindir])
 AC_SUBST([RUN_STATE_DIR], [$runstatedir])
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 78ba0ed..fb1241d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,5 +1,5 @@
 # BlueALSA - Makefile.am
-# Copyright (c) 2016-2017 Arkadiusz Bokowy
+# Copyright (c) 2016-2018 Arkadiusz Bokowy
 
 bin_PROGRAMS = bluealsa
 SUBDIRS = asound
@@ -20,12 +20,20 @@ bluealsa_SOURCES = \
 	utils.c \
 	main.c
 
+if ENABLE_OFONO
+bluealsa_SOURCES += \
+	ofono.c \
+	ofono-iface.c
+endif
+
 AM_CFLAGS = \
 	@BLUEZ_CFLAGS@ \
 	@GLIB2_CFLAGS@ \
 	@GIO2_CFLAGS@ \
 	@AAC_CFLAGS@ \
 	@APTX_CFLAGS@ \
+	@LDAC_CFLAGS@ \
+	@LDAC_ABR_CFLAGS@ \
 	@SBC_CFLAGS@
 
 LDADD = \
@@ -34,4 +42,6 @@ LDADD = \
 	@GIO2_LIBS@ \
 	@AAC_LIBS@ \
 	@APTX_LIBS@ \
+	@LDAC_LIBS@ \
+	@LDAC_ABR_LIBS@ \
 	@SBC_LIBS@
diff --git a/src/asound/Makefile.am b/src/asound/Makefile.am
index 75a2dc3..923d884 100644
--- a/src/asound/Makefile.am
+++ b/src/asound/Makefile.am
@@ -5,7 +5,7 @@ EXTRA_DIST = 20-bluealsa.conf
 
 asound_module_ctl_LTLIBRARIES = libasound_module_ctl_bluealsa.la
 asound_module_pcm_LTLIBRARIES = libasound_module_pcm_bluealsa.la
-asound_module_data_DATA = 20-bluealsa.conf
+asound_module_conf_DATA = 20-bluealsa.conf
 
 libasound_module_ctl_bluealsa_la_SOURCES = \
 	../shared/ctl-client.c \
@@ -19,7 +19,7 @@ libasound_module_pcm_bluealsa_la_SOURCES = \
 
 asound_module_ctldir = @ALSA_PLUGIN_DIR@
 asound_module_pcmdir = @ALSA_PLUGIN_DIR@
-asound_module_datadir = @ALSA_DATA_DIR@/alsa.conf.d
+asound_module_confdir = @ALSA_CONF_DIR@
 
 AM_CFLAGS = \
 	-I$(top_srcdir)/src \
diff --git a/src/asound/bluealsa-ctl.c b/src/asound/bluealsa-ctl.c
index 0195210..f4a0181 100644
--- a/src/asound/bluealsa-ctl.c
+++ b/src/asound/bluealsa-ctl.c
@@ -48,8 +48,9 @@ struct ctl_elem_update {
 struct bluealsa_ctl {
 	snd_ctl_ext_t ext;
 
-	/* bluealsa socket */
+	/* bluealsa sockets */
 	int fd;
+	int event_fd;
 
 	/* if true, show battery meter */
 	bool battery;
@@ -107,7 +108,7 @@ static void bluealsa_set_elem_name(struct ctl_elem *elem, int id) {
 	char no[8] = "";
 
 	if (id != -1) {
-		sprintf(no, " #%d", id + 1);
+		sprintf(no, " #%u", id + 1);
 		len -= strlen(no);
 	}
 
@@ -119,7 +120,7 @@ static void bluealsa_set_elem_name(struct ctl_elem *elem, int id) {
 	}
 	else if (transport != NULL) {
 		/* avoid name duplication by adding profile suffixes */
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			break;
 		case BA_PCM_TYPE_A2DP:
@@ -174,7 +175,7 @@ static int bluealsa_ctl_elem_cmp(const struct ctl_elem *e1, const struct ctl_ele
 		updated |= d1->battery_level != d2->battery_level;
 		break;
 	case CTL_ELEM_TYPE_SWITCH:
-		switch (t1->type) {
+		switch (BA_PCM_TYPE(t1->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -191,7 +192,7 @@ static int bluealsa_ctl_elem_cmp(const struct ctl_elem *e1, const struct ctl_ele
 		}
 		break;
 	case CTL_ELEM_TYPE_VOLUME:
-		switch (t1->type) {
+		switch (BA_PCM_TYPE(t1->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -219,6 +220,7 @@ static int bluealsa_ctl_elem_update_cmp(const void *p1, const void *p2) {
 static void bluealsa_close(snd_ctl_ext_t *ext) {
 	struct bluealsa_ctl *ctl = (struct bluealsa_ctl *)ext->private_data;
 	close(ctl->fd);
+	close(ctl->event_fd);
 	free(ctl->devices);
 	free(ctl->transports);
 	free(ctl->elems);
@@ -251,14 +253,15 @@ static int bluealsa_elem_count(snd_ctl_ext_t *ext) {
 		/* Every stream has two controls associated to itself - volume adjustment
 		 * and mute switch. A2DP transport contains only one stream. However, SCO
 		 * transport represent both streams - playback and capture. */
-		switch (ctl->transports[i].type) {
+		switch (BA_PCM_TYPE(ctl->transports[i].type)) {
 		case BA_PCM_TYPE_NULL:
 			continue;
 		case BA_PCM_TYPE_A2DP:
 			count += 2;
 			break;
 		case BA_PCM_TYPE_SCO:
-			count += 4;
+			if (ctl->transports[i].codec != 0)
+				count += 4;
 			break;
 		}
 	}
@@ -275,12 +278,11 @@ static int bluealsa_elem_count(snd_ctl_ext_t *ext) {
 		size_t ii;
 
 		/* get device structure for given transport */
-		for (ii = 0; ii < ctl->devices_count; ii++) {
+		for (ii = 0; ii < ctl->devices_count; ii++)
 			if (bacmp(&ctl->devices[ii].addr, &transport->addr) == 0) {
 				device = &ctl->devices[ii];
 				break;
 			}
-		}
 
 		/* If the timing is right, the device list might not contain all devices.
 		 * It will happen, when between the get devices and get transports calls
@@ -288,7 +290,7 @@ static int bluealsa_elem_count(snd_ctl_ext_t *ext) {
 		if (device == NULL)
 			continue;
 
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			break;
 
@@ -297,14 +299,14 @@ static int bluealsa_elem_count(snd_ctl_ext_t *ext) {
 			ctl->elems[count].type = CTL_ELEM_TYPE_VOLUME;
 			ctl->elems[count].device = device;
 			ctl->elems[count].transport = transport;
-			ctl->elems[count].playback = transport->stream == BA_PCM_STREAM_PLAYBACK;
+			ctl->elems[count].playback = transport->type & BA_PCM_STREAM_PLAYBACK;
 			bluealsa_set_elem_name(&ctl->elems[count], -1);
 			count++;
 
 			ctl->elems[count].type = CTL_ELEM_TYPE_SWITCH;
 			ctl->elems[count].device = device;
 			ctl->elems[count].transport = transport;
-			ctl->elems[count].playback = transport->stream == BA_PCM_STREAM_PLAYBACK;
+			ctl->elems[count].playback = transport->type & BA_PCM_STREAM_PLAYBACK;
 			bluealsa_set_elem_name(&ctl->elems[count], -1);
 			count++;
 
@@ -312,6 +314,9 @@ static int bluealsa_elem_count(snd_ctl_ext_t *ext) {
 
 		case BA_PCM_TYPE_SCO:
 
+			if (ctl->transports[i].codec == 0)
+				break;
+
 			ctl->elems[count].type = CTL_ELEM_TYPE_VOLUME;
 			ctl->elems[count].device = device;
 			ctl->elems[count].transport = transport;
@@ -462,7 +467,7 @@ static int bluealsa_get_integer_info(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key,
 	case CTL_ELEM_TYPE_SWITCH:
 		return -EINVAL;
 	case CTL_ELEM_TYPE_VOLUME:
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -495,7 +500,7 @@ static int bluealsa_read_integer(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key, long
 		value[0] = device->battery_level;
 		break;
 	case CTL_ELEM_TYPE_SWITCH:
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -512,7 +517,7 @@ static int bluealsa_read_integer(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key, long
 		}
 		break;
 	case CTL_ELEM_TYPE_VOLUME:
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -550,7 +555,7 @@ static int bluealsa_write_integer(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key, lon
 		/* this element should be read-only */
 		return -EINVAL;
 	case CTL_ELEM_TYPE_SWITCH:
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -567,7 +572,7 @@ static int bluealsa_write_integer(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key, lon
 		}
 		break;
 	case CTL_ELEM_TYPE_VOLUME:
-		switch (transport->type) {
+		switch (BA_PCM_TYPE(transport->type)) {
 		case BA_PCM_TYPE_NULL:
 			return -EINVAL;
 		case BA_PCM_TYPE_A2DP:
@@ -594,7 +599,7 @@ static int bluealsa_write_integer(snd_ctl_ext_t *ext, snd_ctl_ext_key_t key, lon
 
 static void bluealsa_subscribe_events(snd_ctl_ext_t *ext, int subscribe) {
 	struct bluealsa_ctl *ctl = (struct bluealsa_ctl *)ext->private_data;
-	if (bluealsa_subscribe(ctl->fd, subscribe ? 0xFFFF : 0) == -1)
+	if (bluealsa_event_subscribe(ctl->event_fd, subscribe ? 0xFFFF : 0) == -1)
 		SNDERR("BlueALSA subscription failed: %s", strerror(errno));
 }
 
@@ -622,7 +627,7 @@ static int bluealsa_read_event(snd_ctl_ext_t *ext, snd_ctl_elem_id_t *id, unsign
 	/* This code reads events from the socket until the EAGAIN is returned.
 	 * Since EAGAIN is returned when operation would block (there is no more
 	 * data to read), we are compliant with the ALSA specification. */
-	while ((ret = recv(ctl->fd, &event, sizeof(event), MSG_DONTWAIT)) == -1 && errno == EINTR)
+	while ((ret = recv(ctl->event_fd, &event, sizeof(event), MSG_DONTWAIT)) == -1 && errno == EINTR)
 		continue;
 	if (ret == -1)
 		return -errno;
@@ -747,7 +752,8 @@ SND_CTL_PLUGIN_DEFINE_FUNC(bluealsa) {
 	if ((ctl = calloc(1, sizeof(*ctl))) == NULL)
 		return -ENOMEM;
 
-	if ((ctl->fd = bluealsa_open(interface)) == -1) {
+	if ((ctl->fd = bluealsa_open(interface)) == -1 ||
+			(ctl->event_fd = bluealsa_open(interface)) == -1) {
 		SNDERR("BlueALSA connection failed: %s", strerror(errno));
 		ret = -errno;
 		goto fail;
@@ -764,7 +770,7 @@ SND_CTL_PLUGIN_DEFINE_FUNC(bluealsa) {
 
 	ctl->ext.callback = &bluealsa_snd_ctl_ext_callback;
 	ctl->ext.private_data = ctl;
-	ctl->ext.poll_fd = ctl->fd;
+	ctl->ext.poll_fd = ctl->event_fd;
 
 	if ((ret = snd_ctl_ext_create(&ctl->ext, name, mode)) < 0)
 		goto fail;
@@ -775,6 +781,8 @@ SND_CTL_PLUGIN_DEFINE_FUNC(bluealsa) {
 fail:
 	if (ctl->fd != -1)
 		close(ctl->fd);
+	if (ctl->event_fd != -1)
+		close(ctl->event_fd);
 	free(ctl);
 	return ret;
 }
diff --git a/src/asound/bluealsa-pcm.c b/src/asound/bluealsa-pcm.c
index c5d46fe..ca43e07 100644
--- a/src/asound/bluealsa-pcm.c
+++ b/src/asound/bluealsa-pcm.c
@@ -1,6 +1,6 @@
 /*
  * bluealsa-pcm.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,7 +8,10 @@
  *
  */
 
-#define _GNU_SOURCE
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
 #include <errno.h>
 #include <poll.h>
 #include <pthread.h>
@@ -40,7 +43,7 @@ struct bluealsa_pcm {
 	int event_fd;
 
 	/* requested transport */
-	struct ba_msg_transport *transport;
+	struct ba_msg_transport transport;
 	size_t pcm_buffer_size;
 	int pcm_fd;
 
@@ -73,21 +76,27 @@ struct bluealsa_pcm {
 /**
  * Helper function for closing PCM transport. */
 static int close_transport(struct bluealsa_pcm *pcm) {
-	int rv = bluealsa_close_transport(pcm->fd, pcm->transport);
-	int err = errno;
-	close(pcm->pcm_fd);
+	if (pcm->pcm_fd == -1)
+		return 0;
+	int rv = close(pcm->pcm_fd);
 	pcm->pcm_fd = -1;
-	errno = err;
 	return rv;
 }
 
+/**
+ * Helper function for IO thread termination. */
+static void io_thread_cleanup(struct bluealsa_pcm *pcm) {
+	debug("IO thread cleanup: %d", pcm->fd);
+	pcm->io_started = false;
+}
+
 /**
  * IO thread, which facilitates ring buffer. */
 static void *io_thread(void *arg) {
 	snd_pcm_ioplug_t *io = (snd_pcm_ioplug_t *)arg;
 
 	struct bluealsa_pcm *pcm = io->private_data;
-	const snd_pcm_channel_area_t *areas = snd_pcm_ioplug_mmap_areas(io);
+	pthread_cleanup_push(PTHREAD_CLEANUP(io_thread_cleanup), pcm);
 
 	sigset_t sigset;
 	sigemptyset(&sigset);
@@ -101,25 +110,13 @@ static void *io_thread(void *arg) {
 
 	if ((errno = pthread_sigmask(SIG_BLOCK, &sigset, NULL)) != 0) {
 		SNDERR("Thread signal mask error: %s", strerror(errno));
-		goto final;
-	}
-
-	/* In the capture mode, the PCM FIFO is opened in the non-blocking mode.
-	 * So right now, we have to synchronize write and read sides, otherwise
-	 * reading might return 0, which will be incorrectly recognized as FIFO
-	 * close signal, but in fact it means, that it was not opened yet. */
-	if (io->stream == SND_PCM_STREAM_CAPTURE) {
-		struct pollfd pfds[1] = {{ pcm->pcm_fd, POLLIN, 0 }};
-		if (poll(pfds, 1, -1) == -1) {
-			SNDERR("PCM FIFO poll error: %s", strerror(errno));
-			goto final;
-		}
+		goto fail;
 	}
 
 	struct asrsync asrs;
-	asrsync_init(asrs, io->rate);
+	asrsync_init(&asrs, io->rate);
 
-	debug("Starting IO loop");
+	debug("Starting IO loop: %d", pcm->pcm_fd);
 	for (;;) {
 
 		int tmp;
@@ -128,11 +125,11 @@ static void *io_thread(void *arg) {
 		case SND_PCM_STATE_DRAINING:
 			break;
 		case SND_PCM_STATE_DISCONNECTED:
-			goto final;
+			goto fail;
 		default:
 			debug("IO thread paused: %d", io->state);
 			sigwait(&sigset, &tmp);
-			asrsync_init(asrs, io->rate);
+			asrsync_init(&asrs, io->rate);
 			debug("IO thread resumed: %d", io->state);
 		}
 
@@ -141,6 +138,7 @@ static void *io_thread(void *arg) {
 		snd_pcm_uframes_t io_hw_ptr = pcm->io_hw_ptr;
 		snd_pcm_uframes_t io_hw_boundary = pcm->io_hw_boundary;
 		snd_pcm_uframes_t frames = io->period_size;
+		const snd_pcm_channel_area_t *areas = snd_pcm_ioplug_mmap_areas(io);
 		char *buffer = areas->addr + (areas->first + areas->step * io_ptr) / 8;
 		char *head = buffer;
 		ssize_t ret = 0;
@@ -173,14 +171,14 @@ static void *io_thread(void *arg) {
 					if (errno == EINTR)
 						continue;
 					SNDERR("PCM FIFO read error: %s", strerror(errno));
-					goto final;
+					goto fail;
 				}
 				head += ret;
 				len -= ret;
 			}
 
 			if (ret == 0)
-				goto final;
+				goto fail;
 
 		}
 		else {
@@ -198,12 +196,11 @@ static void *io_thread(void *arg) {
 					if (errno == EINTR)
 						continue;
 					SNDERR("PCM FIFO write error: %s", strerror(errno));
-					goto final;
+					goto fail;
 				}
 				head += ret;
 				len -= ret;
-			}
-			while (len != 0);
+			} while (len != 0);
 
 			/* synchronize playback time */
 			asrsync_sync(&asrs, frames);
@@ -215,8 +212,9 @@ sync:
 		eventfd_write(pcm->event_fd, 1);
 	}
 
-final:
-	debug("Exiting IO thread");
+fail:
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(1);
 	close_transport(pcm);
 	eventfd_write(pcm->event_fd, 0xDEAD0000);
 	return NULL;
@@ -224,7 +222,7 @@ final:
 
 static int bluealsa_start(snd_pcm_ioplug_t *io) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	debug("Starting");
+	debug("Starting: %d", pcm->fd);
 
 	/* If the IO thread is already started, skip thread creation. Otherwise,
 	 * we might end up with a bunch of IO threads reading or writing to the
@@ -238,7 +236,7 @@ static int bluealsa_start(snd_pcm_ioplug_t *io) {
 	/* initialize delay calculation */
 	pcm->delay = 0;
 
-	if (bluealsa_pause_transport(pcm->fd, pcm->transport, false) == -1) {
+	if (bluealsa_control_transport(pcm->fd, &pcm->transport, BA_COMMAND_PCM_RESUME) == -1) {
 		debug("Couldn't start PCM: %s", strerror(errno));
 		return -errno;
 	}
@@ -264,12 +262,14 @@ static int bluealsa_start(snd_pcm_ioplug_t *io) {
 
 static int bluealsa_stop(snd_pcm_ioplug_t *io) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	debug("Stopping");
+	debug("Stopping: %d", pcm->fd);
 	if (pcm->io_started) {
 		pcm->io_started = false;
 		pthread_cancel(pcm->io_thread);
 		pthread_join(pcm->io_thread, NULL);
 	}
+	if (bluealsa_control_transport(pcm->fd, &pcm->transport, BA_COMMAND_PCM_DROP) == -1)
+		return -errno;
 	return 0;
 }
 
@@ -282,10 +282,9 @@ static snd_pcm_sframes_t bluealsa_pointer(snd_pcm_ioplug_t *io) {
 
 static int bluealsa_close(snd_pcm_ioplug_t *io) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	debug("Closing plugin");
+	debug("Closing: %d", pcm->fd);
 	close(pcm->fd);
 	close(pcm->event_fd);
-	free(pcm->transport);
 	free(pcm);
 	return 0;
 }
@@ -293,11 +292,11 @@ static int bluealsa_close(snd_pcm_ioplug_t *io) {
 static int bluealsa_hw_params(snd_pcm_ioplug_t *io, snd_pcm_hw_params_t *params) {
 	struct bluealsa_pcm *pcm = io->private_data;
 	(void)params;
-	debug("Initializing HW");
+	debug("Initializing HW: %d", pcm->fd);
 
 	pcm->frame_size = (snd_pcm_format_physical_width(io->format) * io->channels) / 8;
 
-	if ((pcm->pcm_fd = bluealsa_open_transport(pcm->fd, pcm->transport)) == -1) {
+	if ((pcm->pcm_fd = bluealsa_open_transport(pcm->fd, &pcm->transport)) == -1) {
 		debug("Couldn't open PCM FIFO: %s", strerror(errno));
 		return -errno;
 	}
@@ -329,7 +328,7 @@ static int bluealsa_hw_params(snd_pcm_ioplug_t *io, snd_pcm_hw_params_t *params)
 
 static int bluealsa_hw_free(snd_pcm_ioplug_t *io) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	debug("Freeing HW");
+	debug("Freeing HW: %d", pcm->fd);
 	if (close_transport(pcm) == -1)
 		return -errno;
 	return 0;
@@ -337,7 +336,7 @@ static int bluealsa_hw_free(snd_pcm_ioplug_t *io) {
 
 static int bluealsa_sw_params(snd_pcm_ioplug_t *io, snd_pcm_sw_params_t *params) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	debug("Initializing SW");
+	debug("Initializing SW: %d", pcm->fd);
 	snd_pcm_sw_params_get_boundary(params, &pcm->io_hw_boundary);
 	return 0;
 }
@@ -353,13 +352,13 @@ static int bluealsa_prepare(snd_pcm_ioplug_t *io) {
 	pcm->io_hw_ptr = 0;
 	pcm->io_ptr = 0;
 
-	debug("Prepared");
+	debug("Prepared: %d", pcm->fd);
 	return 0;
 }
 
 static int bluealsa_drain(snd_pcm_ioplug_t *io) {
 	struct bluealsa_pcm *pcm = io->private_data;
-	if (bluealsa_drain_transport(pcm->fd, pcm->transport) == -1)
+	if (bluealsa_control_transport(pcm->fd, &pcm->transport, BA_COMMAND_PCM_DRAIN) == -1)
 		return -errno;
 	return 0;
 }
@@ -367,7 +366,8 @@ static int bluealsa_drain(snd_pcm_ioplug_t *io) {
 static int bluealsa_pause(snd_pcm_ioplug_t *io, int enable) {
 	struct bluealsa_pcm *pcm = io->private_data;
 
-	if (bluealsa_pause_transport(pcm->fd, pcm->transport, enable) == -1)
+	if (bluealsa_control_transport(pcm->fd, &pcm->transport,
+				enable ? BA_COMMAND_PCM_PAUSE : BA_COMMAND_PCM_RESUME) == -1)
 		return -errno;
 
 	if (enable == 0) {
@@ -388,10 +388,10 @@ static void bluealsa_dump(snd_pcm_ioplug_t *io, snd_output_t *out) {
 	struct bluealsa_pcm *pcm = io->private_data;
 	char addr[18];
 
-	ba2str(&pcm->transport->addr, addr);
+	ba2str(&pcm->transport.addr, addr);
 	snd_output_printf(out, "Bluetooth device: %s\n", addr);
-	snd_output_printf(out, "Bluetooth profile: %d\n", pcm->transport->type);
-	snd_output_printf(out, "Bluetooth codec: %d\n", pcm->transport->codec);
+	snd_output_printf(out, "Bluetooth profile: %#x\n", pcm->transport.type);
+	snd_output_printf(out, "Bluetooth codec: %#x\n", pcm->transport.codec);
 }
 
 static int bluealsa_delay(snd_pcm_ioplug_t *io, snd_pcm_sframes_t *delayp) {
@@ -425,8 +425,8 @@ static int bluealsa_delay(snd_pcm_ioplug_t *io, snd_pcm_sframes_t *delayp) {
 		if (io->stream == SND_PCM_STREAM_PLAYBACK &&
 				(pcm->delay == 0 || ++counter % (io->rate / 10) == 0)) {
 
-			int tmp;
-			if ((tmp = bluealsa_get_transport_delay(pcm->fd, pcm->transport)) != -1) {
+			unsigned int tmp;
+			if (bluealsa_get_transport_delay(pcm->fd, &pcm->transport, &tmp) != -1) {
 				pcm->delay = (io->rate / 100) * tmp / 100;
 				debug("BlueALSA delay: %.1f ms (%ld frames)", (float)tmp / 10, pcm->delay);
 			}
@@ -448,7 +448,7 @@ static int bluealsa_poll_descriptors(snd_pcm_ioplug_t *io, struct pollfd *pfd,
 		unsigned int space) {
 	struct bluealsa_pcm *pcm = io->private_data;
 
-	if (space != 2)
+	if (space < 2)
 		return -EINVAL;
 
 	/* PCM plug-in relies on the BlueALSA socket (critical signaling
@@ -465,7 +465,7 @@ static int bluealsa_poll_revents(snd_pcm_ioplug_t *io, struct pollfd *pfd,
 		unsigned int nfds, unsigned short *revents) {
 	struct bluealsa_pcm *pcm = io->private_data;
 
-	if (nfds != 2)
+	if (nfds < 2)
 		return -EINVAL;
 
 	if (pcm->pcm_fd == -1)
@@ -545,7 +545,7 @@ static int bluealsa_set_hw_constraint(struct bluealsa_pcm *pcm) {
 
 	int err;
 
-	debug("Setting constraints");
+	debug("Setting constraints: %d", pcm->fd);
 
 	if ((err = snd_pcm_ioplug_set_param_list(io, SND_PCM_IOPLUG_HW_ACCESS,
 					ARRAYSIZE(accesses), accesses)) < 0)
@@ -564,8 +564,8 @@ static int bluealsa_set_hw_constraint(struct bluealsa_pcm *pcm) {
 	 * the transport sampling rate and the number of channels, so the buffer
 	 * "time" size will be constant. The minimal period size and buffer size
 	 * are respectively 10 ms and 200 ms. Upper limits are not constraint. */
-	unsigned int min_p = pcm->transport->sampling * 10 / 1000 * pcm->transport->channels * 2;
-	unsigned int min_b = pcm->transport->sampling * 200 / 1000 * pcm->transport->channels * 2;
+	unsigned int min_p = pcm->transport.sampling * 10 / 1000 * pcm->transport.channels * 2;
+	unsigned int min_b = pcm->transport.sampling * 200 / 1000 * pcm->transport.channels * 2;
 
 	if ((err = snd_pcm_ioplug_set_param_minmax(io, SND_PCM_IOPLUG_HW_PERIOD_BYTES,
 					min_p, 1024 * 16)) < 0)
@@ -576,11 +576,11 @@ static int bluealsa_set_hw_constraint(struct bluealsa_pcm *pcm) {
 		return err;
 
 	if ((err = snd_pcm_ioplug_set_param_minmax(io, SND_PCM_IOPLUG_HW_CHANNELS,
-					pcm->transport->channels, pcm->transport->channels)) < 0)
+					pcm->transport.channels, pcm->transport.channels)) < 0)
 		return err;
 
 	if ((err = snd_pcm_ioplug_set_param_minmax(io, SND_PCM_IOPLUG_HW_RATE,
-					pcm->transport->sampling, pcm->transport->sampling)) < 0)
+					pcm->transport.sampling, pcm->transport.sampling)) < 0)
 		return err;
 
 	return 0;
@@ -674,9 +674,8 @@ SND_PCM_PLUGIN_DEFINE_FUNC(bluealsa) {
 		goto fail;
 	}
 
-	enum ba_pcm_stream _stream = stream == SND_PCM_STREAM_PLAYBACK ?
-			BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE;
-	if ((pcm->transport = bluealsa_get_transport(pcm->fd, addr, type, _stream)) == NULL) {
+	type |= stream == SND_PCM_STREAM_PLAYBACK ? BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE;
+	if (bluealsa_get_transport(pcm->fd, &addr, type, &pcm->transport) == -1) {
 		SNDERR("Couldn't get BlueALSA transport: %s", strerror(errno));
 		ret = -errno;
 		goto fail;
@@ -688,7 +687,6 @@ SND_PCM_PLUGIN_DEFINE_FUNC(bluealsa) {
 	pcm->io.mmap_rw = 1;
 	pcm->io.callback = &bluealsa_callback;
 	pcm->io.private_data = pcm;
-	pcm->transport->stream = _stream;
 
 	if ((ret = snd_pcm_ioplug_create(&pcm->io, name, stream, mode)) < 0)
 		goto fail;
@@ -706,7 +704,6 @@ fail:
 		close(pcm->fd);
 	if (pcm->event_fd != -1)
 		close(pcm->event_fd);
-	free(pcm->transport);
 	free(pcm);
 	return ret;
 }
diff --git a/src/bluealsa.c b/src/bluealsa.c
index 6008657..8e09ea7 100644
--- a/src/bluealsa.c
+++ b/src/bluealsa.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluealsa.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -10,8 +10,15 @@
 
 #include "bluealsa.h"
 
+#include <fcntl.h>
 #include <grp.h>
+#include <poll.h>
 
+#if ENABLE_LDAC
+# include <ldacBT.h>
+#endif
+
+#include "ctl.h"
 #include "hfp.h"
 #include "transport.h"
 
@@ -21,15 +28,19 @@ struct ba_config config = {
 
 	/* enable output profiles by default */
 	.enable.a2dp_source = true,
-	.enable.hsp_ag = true,
 	.enable.hfp_ag = true,
+	.enable.hsp_ag = true,
+
+	.null_fd = -1,
+
+	/* omit chown if audio group is not defined */
+	.gid_audio = -1,
 
 	/* initialization flags */
 	.ctl.socket_created = false,
 	.ctl.thread_created = false,
 
-	/* omit chown if audio group is not defined */
-	.gid_audio = -1,
+	.ctl.evt = { -1, -1 },
 
 	.hfp.features_sdp_hf =
 		SDP_HFP_HF_FEAT_CLI |
@@ -51,15 +62,22 @@ struct ba_config config = {
 	.a2dp.volume = false,
 	.a2dp.force_mono = false,
 	.a2dp.force_44100 = false,
+	.a2dp.keep_alive = 0,
 
 #if ENABLE_AAC
 	/* There are two issues with the afterburner: a) it uses a LOT of power,
-	 * b) it generates larger payload (see VBR comment). These two reasons
-	 * are good enough to not enable afterburner by default. */
+	 * b) it generates larger payload. These two reasons are good enough to
+	 * not enable afterburner by default. */
 	.aac_afterburner = false,
 	.aac_vbr_mode = 4,
 #endif
 
+#if ENABLE_LDAC
+	.ldac_abr = false,
+	/* Use standard encoder quality as a reasonable default. */
+	.ldac_eqmid = LDACBT_EQMID_SQ,
+#endif
+
 };
 
 int bluealsa_config_init(void) {
@@ -75,17 +93,20 @@ int bluealsa_config_init(void) {
 	config.dbus_objects = g_hash_table_new_full(g_direct_hash, g_direct_equal,
 			NULL, g_free);
 
+	config.null_fd = open("/dev/null", O_WRONLY | O_NONBLOCK);
+
 	/* use proper ACL group for our audio device */
 	if ((grp = getgrnam("audio")) != NULL)
 		config.gid_audio = grp->gr_gid;
 
+	/* Create arrays for handling connected clients. Note, that it is not
+	 * necessary to clear pfds array, because we have to initialize pollfd
+	 * struct by ourself anyway. Also, make sure to reserve some space, so
+	 * for most cases reallocation will not be required. */
+	config.ctl.pfds = g_array_sized_new(FALSE, FALSE, sizeof(struct pollfd), __CTL_IDX_MAX + 16);
+	config.ctl.subs = g_array_sized_new(FALSE, TRUE, sizeof(enum ba_event), 16);
+
 	config.a2dp.codecs = bluez_a2dp_codecs;
 
 	return 0;
 }
-
-void bluealsa_config_free(void) {
-	pthread_mutex_destroy(&config.devices_mutex);
-	g_hash_table_unref(config.devices);
-	g_hash_table_unref(config.dbus_objects);
-}
diff --git a/src/bluealsa.h b/src/bluealsa.h
index 6d1b880..e291ae3 100644
--- a/src/bluealsa.h
+++ b/src/bluealsa.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluealsa.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -12,10 +12,9 @@
 #define BLUEALSA_BLUEALSA_H
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
-#include <poll.h>
 #include <pthread.h>
 #include <stdbool.h>
 
@@ -27,16 +26,9 @@
 
 #include "bluez.h"
 #include "bluez-a2dp.h"
+#include "transport.h"
 #include "shared/ctl-proto.h"
 
-/* Maximal number of clients connected to the controller. */
-#define BLUEALSA_MAX_CLIENTS 7
-
-/* Indexes of special file descriptors in the poll array. */
-#define CTL_IDX_SRV 0
-#define CTL_IDX_EVT 1
-#define __CTL_IDX_MAX 2
-
 struct ba_config {
 
 	/* used HCI device */
@@ -46,10 +38,11 @@ struct ba_config {
 	struct {
 		bool a2dp_source;
 		bool a2dp_sink;
-		bool hsp_hs;
-		bool hsp_ag;
+		bool hfp_ofono;
 		bool hfp_hf;
 		bool hfp_ag;
+		bool hsp_hs;
+		bool hsp_ag;
 	} enable;
 
 	/* established D-Bus connection */
@@ -65,6 +58,9 @@ struct ba_config {
 	/* registered D-Bus objects */
 	GHashTable *dbus_objects;
 
+	/* opened null device */
+	int null_fd;
+
 	/* audio group ID */
 	gid_t gid_audio;
 
@@ -74,9 +70,10 @@ struct ba_config {
 		bool socket_created;
 		bool thread_created;
 
-		struct pollfd pfds[__CTL_IDX_MAX + BLUEALSA_MAX_CLIENTS];
+		/* special file descriptors + connected clients */
+		GArray *pfds;
 		/* event subscriptions for connected clients */
-		enum ba_event subs[BLUEALSA_MAX_CLIENTS];
+		GArray *subs;
 
 		/* PIPE for transferring events */
 		int evt[2];
@@ -110,6 +107,11 @@ struct ba_config {
 		 * to force lower sampling in order to save Bluetooth bandwidth. */
 		bool force_44100;
 
+		/* The number of seconds for keeping A2DP transport alive after PCM has
+		 * been closed. One might set this value to negative number for infinite
+		 * time. This option applies for the source profile only. */
+		int keep_alive;
+
 	} a2dp;
 
 #if ENABLE_AAC
@@ -117,6 +119,11 @@ struct ba_config {
 	uint8_t aac_vbr_mode;
 #endif
 
+#if ENABLE_LDAC
+	bool ldac_abr;
+	uint8_t ldac_eqmid;
+#endif
+
 };
 
 /* Structure describing registered D-Bus object. */
@@ -133,6 +140,17 @@ struct ba_dbus_object {
 extern struct ba_config config;
 
 int bluealsa_config_init(void);
-void bluealsa_config_free(void);
+
+#define bluealsa_devpool_mutex_lock() \
+	pthread_mutex_lock(&config.devices_mutex)
+#define bluealsa_devpool_mutex_unlock() \
+	pthread_mutex_unlock(&config.devices_mutex)
+
+#define bluealsa_device_insert(key, device) \
+	g_hash_table_insert(config.devices, g_strdup(key), device)
+#define bluealsa_device_lookup(key) \
+	((struct ba_device *)g_hash_table_lookup(config.devices, key))
+#define bluealsa_device_remove(key) \
+	g_hash_table_remove(config.devices, key)
 
 #endif
diff --git a/src/bluez-a2dp.c b/src/bluez-a2dp.c
index 7015d37..1b2bfe9 100644
--- a/src/bluez-a2dp.c
+++ b/src/bluez-a2dp.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluez-a2dp.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,11 +8,8 @@
  *
  */
 
-#if HAVE_CONFIG_H
-# include "config.h"
-#endif
-
 #include "bluez-a2dp.h"
+#include "shared/defs.h"
 
 static const a2dp_sbc_t a2dp_sbc = {
 	.frequency =
@@ -40,6 +37,20 @@ static const a2dp_sbc_t a2dp_sbc = {
 	.max_bitpool = SBC_MAX_BITPOOL,
 };
 
+static const struct bluez_a2dp_channel_mode a2dp_sbc_channels[] = {
+	{ BLUEZ_A2DP_CHM_MONO, SBC_CHANNEL_MODE_MONO },
+	{ BLUEZ_A2DP_CHM_DUAL_CHANNEL, SBC_CHANNEL_MODE_DUAL_CHANNEL },
+	{ BLUEZ_A2DP_CHM_STEREO, SBC_CHANNEL_MODE_STEREO },
+	{ BLUEZ_A2DP_CHM_JOINT_STEREO, SBC_CHANNEL_MODE_JOINT_STEREO },
+};
+
+static const struct bluez_a2dp_sampling_freq a2dp_sbc_samplings[] = {
+	{ 16000, SBC_SAMPLING_FREQ_16000 },
+	{ 32000, SBC_SAMPLING_FREQ_32000 },
+	{ 44100, SBC_SAMPLING_FREQ_44100 },
+	{ 48000, SBC_SAMPLING_FREQ_48000 },
+};
+
 static const a2dp_mpeg_t a2dp_mpeg = {
 	.layer =
 		MPEG_LAYER_MP1 |
@@ -78,6 +89,22 @@ static const a2dp_mpeg_t a2dp_mpeg = {
 		MPEG_BIT_RATE_FREE,
 };
 
+static const struct bluez_a2dp_channel_mode a2dp_mpeg_channels[] = {
+	{ BLUEZ_A2DP_CHM_MONO, MPEG_CHANNEL_MODE_MONO },
+	{ BLUEZ_A2DP_CHM_DUAL_CHANNEL, MPEG_CHANNEL_MODE_DUAL_CHANNEL },
+	{ BLUEZ_A2DP_CHM_STEREO, MPEG_CHANNEL_MODE_STEREO },
+	{ BLUEZ_A2DP_CHM_JOINT_STEREO, MPEG_CHANNEL_MODE_JOINT_STEREO },
+};
+
+static const struct bluez_a2dp_sampling_freq a2dp_mpeg_samplings[] = {
+	{ 16000, MPEG_SAMPLING_FREQ_16000 },
+	{ 22050, MPEG_SAMPLING_FREQ_22050 },
+	{ 24000, MPEG_SAMPLING_FREQ_24000 },
+	{ 32000, MPEG_SAMPLING_FREQ_32000 },
+	{ 44100, MPEG_SAMPLING_FREQ_44100 },
+	{ 48000, MPEG_SAMPLING_FREQ_48000 },
+};
+
 static const a2dp_aac_t a2dp_aac = {
 	.object_type =
 		/* NOTE: AAC Long Term Prediction and AAC Scalable are
@@ -85,23 +112,43 @@ static const a2dp_aac_t a2dp_aac = {
 		AAC_OBJECT_TYPE_MPEG2_AAC_LC |
 		AAC_OBJECT_TYPE_MPEG4_AAC_LC,
 	AAC_INIT_FREQUENCY(
-		AAC_SAMPLING_FREQ_8000 |
-		AAC_SAMPLING_FREQ_11025 |
-		AAC_SAMPLING_FREQ_12000 |
-		AAC_SAMPLING_FREQ_16000 |
-		AAC_SAMPLING_FREQ_22050 |
-		AAC_SAMPLING_FREQ_24000 |
-		AAC_SAMPLING_FREQ_32000 |
-		AAC_SAMPLING_FREQ_44100 |
-		AAC_SAMPLING_FREQ_48000 |
-		AAC_SAMPLING_FREQ_64000 |
-		AAC_SAMPLING_FREQ_88200 |
-		AAC_SAMPLING_FREQ_96000)
+			AAC_SAMPLING_FREQ_8000 |
+			AAC_SAMPLING_FREQ_11025 |
+			AAC_SAMPLING_FREQ_12000 |
+			AAC_SAMPLING_FREQ_16000 |
+			AAC_SAMPLING_FREQ_22050 |
+			AAC_SAMPLING_FREQ_24000 |
+			AAC_SAMPLING_FREQ_32000 |
+			AAC_SAMPLING_FREQ_44100 |
+			AAC_SAMPLING_FREQ_48000 |
+			AAC_SAMPLING_FREQ_64000 |
+			AAC_SAMPLING_FREQ_88200 |
+			AAC_SAMPLING_FREQ_96000)
 	.channels =
 		AAC_CHANNELS_1 |
 		AAC_CHANNELS_2,
 	.vbr = 1,
-	AAC_INIT_BITRATE(0xFFFF)
+	AAC_INIT_BITRATE(320000)
+};
+
+static const struct bluez_a2dp_channel_mode a2dp_aac_channels[] = {
+	{ BLUEZ_A2DP_CHM_MONO, AAC_CHANNELS_1 },
+	{ BLUEZ_A2DP_CHM_STEREO, AAC_CHANNELS_2 },
+};
+
+static const struct bluez_a2dp_sampling_freq a2dp_aac_samplings[] = {
+	{ 8000, AAC_SAMPLING_FREQ_8000 },
+	{ 11025, AAC_SAMPLING_FREQ_11025 },
+	{ 12000, AAC_SAMPLING_FREQ_12000 },
+	{ 16000, AAC_SAMPLING_FREQ_16000 },
+	{ 22050, AAC_SAMPLING_FREQ_22050 },
+	{ 24000, AAC_SAMPLING_FREQ_24000 },
+	{ 32000, AAC_SAMPLING_FREQ_32000 },
+	{ 44100, AAC_SAMPLING_FREQ_44100 },
+	{ 48000, AAC_SAMPLING_FREQ_48000 },
+	{ 64000, AAC_SAMPLING_FREQ_64000 },
+	{ 88200, AAC_SAMPLING_FREQ_88200 },
+	{ 96000, AAC_SAMPLING_FREQ_96000 },
 };
 
 static const a2dp_aptx_t a2dp_aptx = {
@@ -118,11 +165,55 @@ static const a2dp_aptx_t a2dp_aptx = {
 		APTX_SAMPLING_FREQ_48000,
 };
 
+static const struct bluez_a2dp_channel_mode a2dp_aptx_channels[] = {
+	{ BLUEZ_A2DP_CHM_STEREO, APTX_CHANNEL_MODE_STEREO },
+};
+
+static const struct bluez_a2dp_sampling_freq a2dp_aptx_samplings[] = {
+	{ 16000, APTX_SAMPLING_FREQ_16000 },
+	{ 32000, APTX_SAMPLING_FREQ_32000 },
+	{ 44100, APTX_SAMPLING_FREQ_44100 },
+	{ 48000, APTX_SAMPLING_FREQ_48000 },
+};
+
+static const a2dp_ldac_t a2dp_ldac = {
+	.info.vendor_id = LDAC_VENDOR_ID,
+	.info.codec_id = LDAC_CODEC_ID,
+	.channel_mode =
+		LDAC_CHANNEL_MODE_MONO |
+		LDAC_CHANNEL_MODE_DUAL_CHANNEL |
+		LDAC_CHANNEL_MODE_STEREO,
+	.frequency =
+		/* NOTE: Used LDAC library does not support
+		 *       frequencies higher than 96 kHz. */
+		LDAC_SAMPLING_FREQ_44100 |
+		LDAC_SAMPLING_FREQ_48000 |
+		LDAC_SAMPLING_FREQ_88200 |
+		LDAC_SAMPLING_FREQ_96000,
+};
+
+static const struct bluez_a2dp_channel_mode a2dp_ldac_channels[] = {
+	{ BLUEZ_A2DP_CHM_MONO, LDAC_CHANNEL_MODE_MONO },
+	{ BLUEZ_A2DP_CHM_DUAL_CHANNEL, LDAC_CHANNEL_MODE_DUAL_CHANNEL },
+	{ BLUEZ_A2DP_CHM_STEREO, LDAC_CHANNEL_MODE_STEREO },
+};
+
+static const struct bluez_a2dp_sampling_freq a2dp_ldac_samplings[] = {
+	{ 44100, LDAC_SAMPLING_FREQ_44100 },
+	{ 48000, LDAC_SAMPLING_FREQ_48000 },
+	{ 88200, LDAC_SAMPLING_FREQ_88200 },
+	{ 96000, LDAC_SAMPLING_FREQ_96000 },
+};
+
 static const struct bluez_a2dp_codec a2dp_codec_source_sbc = {
 	.dir = BLUEZ_A2DP_SOURCE,
 	.id = A2DP_CODEC_SBC,
 	.cfg = &a2dp_sbc,
 	.cfg_size = sizeof(a2dp_sbc),
+	.channels = a2dp_sbc_channels,
+	.channels_size = ARRAYSIZE(a2dp_sbc_channels),
+	.samplings = a2dp_sbc_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_sbc_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_sink_sbc = {
@@ -130,6 +221,10 @@ static const struct bluez_a2dp_codec a2dp_codec_sink_sbc = {
 	.id = A2DP_CODEC_SBC,
 	.cfg = &a2dp_sbc,
 	.cfg_size = sizeof(a2dp_sbc),
+	.channels = a2dp_sbc_channels,
+	.channels_size = ARRAYSIZE(a2dp_sbc_channels),
+	.samplings = a2dp_sbc_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_sbc_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_source_mpeg = {
@@ -137,6 +232,10 @@ static const struct bluez_a2dp_codec a2dp_codec_source_mpeg = {
 	.id = A2DP_CODEC_MPEG12,
 	.cfg = &a2dp_mpeg,
 	.cfg_size = sizeof(a2dp_mpeg),
+	.channels = a2dp_mpeg_channels,
+	.channels_size = ARRAYSIZE(a2dp_mpeg_channels),
+	.samplings = a2dp_mpeg_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_mpeg_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_sink_mpeg = {
@@ -144,6 +243,10 @@ static const struct bluez_a2dp_codec a2dp_codec_sink_mpeg = {
 	.id = A2DP_CODEC_MPEG12,
 	.cfg = &a2dp_mpeg,
 	.cfg_size = sizeof(a2dp_mpeg),
+	.channels = a2dp_mpeg_channels,
+	.channels_size = ARRAYSIZE(a2dp_mpeg_channels),
+	.samplings = a2dp_mpeg_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_mpeg_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_source_aac = {
@@ -151,6 +254,10 @@ static const struct bluez_a2dp_codec a2dp_codec_source_aac = {
 	.id = A2DP_CODEC_MPEG24,
 	.cfg = &a2dp_aac,
 	.cfg_size = sizeof(a2dp_aac),
+	.channels = a2dp_aac_channels,
+	.channels_size = ARRAYSIZE(a2dp_aac_channels),
+	.samplings = a2dp_aac_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_aac_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_sink_aac = {
@@ -158,6 +265,10 @@ static const struct bluez_a2dp_codec a2dp_codec_sink_aac = {
 	.id = A2DP_CODEC_MPEG24,
 	.cfg = &a2dp_aac,
 	.cfg_size = sizeof(a2dp_aac),
+	.channels = a2dp_aac_channels,
+	.channels_size = ARRAYSIZE(a2dp_aac_channels),
+	.samplings = a2dp_aac_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_aac_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_source_aptx = {
@@ -165,6 +276,10 @@ static const struct bluez_a2dp_codec a2dp_codec_source_aptx = {
 	.id = A2DP_CODEC_VENDOR_APTX,
 	.cfg = &a2dp_aptx,
 	.cfg_size = sizeof(a2dp_aptx),
+	.channels = a2dp_aptx_channels,
+	.channels_size = ARRAYSIZE(a2dp_aptx_channels),
+	.samplings = a2dp_aptx_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_aptx_samplings),
 };
 
 static const struct bluez_a2dp_codec a2dp_codec_sink_aptx = {
@@ -172,9 +287,38 @@ static const struct bluez_a2dp_codec a2dp_codec_sink_aptx = {
 	.id = A2DP_CODEC_VENDOR_APTX,
 	.cfg = &a2dp_aptx,
 	.cfg_size = sizeof(a2dp_aptx),
+	.channels = a2dp_aptx_channels,
+	.channels_size = ARRAYSIZE(a2dp_aptx_channels),
+	.samplings = a2dp_aptx_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_aptx_samplings),
+};
+
+static const struct bluez_a2dp_codec a2dp_codec_source_ldac = {
+	.dir = BLUEZ_A2DP_SOURCE,
+	.id = A2DP_CODEC_VENDOR_LDAC,
+	.cfg = &a2dp_ldac,
+	.cfg_size = sizeof(a2dp_ldac),
+	.channels = a2dp_ldac_channels,
+	.channels_size = ARRAYSIZE(a2dp_ldac_channels),
+	.samplings = a2dp_ldac_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_ldac_samplings),
+};
+
+static const struct bluez_a2dp_codec a2dp_codec_sink_ldac = {
+	.dir = BLUEZ_A2DP_SINK,
+	.id = A2DP_CODEC_VENDOR_LDAC,
+	.cfg = &a2dp_ldac,
+	.cfg_size = sizeof(a2dp_ldac),
+	.channels = a2dp_ldac_channels,
+	.channels_size = ARRAYSIZE(a2dp_ldac_channels),
+	.samplings = a2dp_ldac_samplings,
+	.samplings_size = ARRAYSIZE(a2dp_ldac_samplings),
 };
 
 static const struct bluez_a2dp_codec *a2dp_codecs[] = {
+#if ENABLE_LDAC
+	&a2dp_codec_source_ldac,
+#endif
 #if ENABLE_APTX
 	&a2dp_codec_source_aptx,
 #endif
diff --git a/src/bluez-a2dp.h b/src/bluez-a2dp.h
index e0715bf..0726eaf 100644
--- a/src/bluez-a2dp.h
+++ b/src/bluez-a2dp.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluez-a2dp.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -11,6 +11,10 @@
 #ifndef BLUEALSA_BLUEZA2DP_H_
 #define BLUEALSA_BLUEZA2DP_H_
 
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
 #include <stddef.h>
 
 #include "a2dp-codecs.h"
@@ -20,11 +24,38 @@ enum bluez_a2dp_dir {
 	BLUEZ_A2DP_SINK,
 };
 
+enum bluez_a2dp_chm {
+	BLUEZ_A2DP_CHM_MONO = 0,
+	/* fixed bit-rate for each channel */
+	BLUEZ_A2DP_CHM_DUAL_CHANNEL,
+	/* channel bits allocated dynamically */
+	BLUEZ_A2DP_CHM_STEREO,
+	/* L+R (mid) and L-R (side) encoding */
+	BLUEZ_A2DP_CHM_JOINT_STEREO,
+};
+
+struct bluez_a2dp_channel_mode {
+	enum bluez_a2dp_chm mode;
+	uint16_t value;
+};
+
+struct bluez_a2dp_sampling_freq {
+	int frequency;
+	uint16_t value;
+};
+
 struct bluez_a2dp_codec {
 	enum bluez_a2dp_dir dir;
 	uint16_t id;
+	/* capabilities configuration element */
 	const void *cfg;
 	size_t cfg_size;
+	/* list of supported channel modes */
+	const struct bluez_a2dp_channel_mode *channels;
+	size_t channels_size;
+	/* list of supported sampling frequencies */
+	const struct bluez_a2dp_sampling_freq *samplings;
+	size_t samplings_size;
 };
 
 /* NULL-terminated list of available A2DP codecs */
diff --git a/src/bluez-iface.c b/src/bluez-iface.c
index c0a22f6..9e778ae 100644
--- a/src/bluez-iface.c
+++ b/src/bluez-iface.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluez-iface.c
- * Copyright (c) 2016 Arkadiusz Bokowy
+ * Copyright (c) 2016-2018 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -133,7 +133,7 @@ static const GDBusMethodInfo *bluez_iface_profile_methods[] = {
 };
 
 const GDBusInterfaceInfo bluez_iface_endpoint = {
-	-1, "org.bluez.MediaEndpoint1",
+	-1, BLUEZ_IFACE_MEDIA_ENDPOINT,
 	(GDBusMethodInfo **)bluez_iface_endpoint_methods,
 	NULL,
 	NULL,
@@ -141,7 +141,7 @@ const GDBusInterfaceInfo bluez_iface_endpoint = {
 };
 
 const GDBusInterfaceInfo bluez_iface_profile = {
-	-1, "org.bluez.Profile1",
+	-1, BLUEZ_IFACE_PROFILE,
 	(GDBusMethodInfo **)bluez_iface_profile_methods,
 	NULL,
 	NULL,
diff --git a/src/bluez-iface.h b/src/bluez-iface.h
index 7d61638..483bc7f 100644
--- a/src/bluez-iface.h
+++ b/src/bluez-iface.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluez-iface.h
- * Copyright (c) 2016 Arkadiusz Bokowy
+ * Copyright (c) 2016-2018 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -13,6 +13,19 @@
 
 #include <gio/gio.h>
 
+#define BLUEZ_SERVICE "org.bluez"
+
+#define BLUEZ_IFACE_DEVICE          BLUEZ_SERVICE ".Device1"
+#define BLUEZ_IFACE_MEDIA           BLUEZ_SERVICE ".Media1"
+#define BLUEZ_IFACE_MEDIA_ENDPOINT  BLUEZ_SERVICE ".MediaEndpoint1"
+#define BLUEZ_IFACE_MEDIA_TRANSPORT BLUEZ_SERVICE ".MediaTransport1"
+#define BLUEZ_IFACE_PROFILE         BLUEZ_SERVICE ".Profile1"
+#define BLUEZ_IFACE_PROFILE_MANAGER BLUEZ_SERVICE ".ProfileManager1"
+
+#define BLUEZ_TRANSPORT_STATE_IDLE    "idle"
+#define BLUEZ_TRANSPORT_STATE_PENDING "pending"
+#define BLUEZ_TRANSPORT_STATE_ACTIVE  "active"
+
 const GDBusInterfaceInfo bluez_iface_endpoint;
 const GDBusInterfaceInfo bluez_iface_profile;
 
diff --git a/src/bluez.c b/src/bluez.c
index 3f22534..537f0fe 100644
--- a/src/bluez.c
+++ b/src/bluez.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - bluez.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -21,6 +21,7 @@
 #include "bluealsa.h"
 #include "bluez-a2dp.h"
 #include "bluez-iface.h"
+#include "ctl.h"
 #include "transport.h"
 #include "utils.h"
 #include "shared/log.h"
@@ -28,7 +29,9 @@
 
 /**
  * Get D-Bus object reference count for given profile. */
-static int bluez_get_dbus_object_count(enum bluetooth_profile profile, uint16_t codec) {
+static int bluez_get_dbus_object_count(
+		enum bluetooth_profile profile,
+		uint16_t codec) {
 
 	GHashTableIter iter;
 	struct ba_dbus_object *obj;
@@ -42,11 +45,139 @@ static int bluez_get_dbus_object_count(enum bluetooth_profile profile, uint16_t
 	return count;
 }
 
+/**
+ * Get device associated with given D-Bus object path. */
+struct ba_device *bluez_get_device(const char *path) {
+
+#if DEBUG
+	/* make sure that the device mutex is acquired */
+	g_assert(pthread_mutex_trylock(&config.devices_mutex) == EBUSY);
+#endif
+
+	struct ba_device *d;
+	char name[sizeof(d->name)];
+	GVariant *property;
+	bdaddr_t addr;
+
+	if ((d = bluealsa_device_lookup(path)) != NULL)
+		return d;
+
+	g_dbus_device_path_to_bdaddr(path, &addr);
+	ba2str(&addr, name);
+
+	/* get local (user editable) Bluetooth device name */
+	if ((property = g_dbus_get_property(config.dbus, BLUEZ_SERVICE, path,
+					BLUEZ_IFACE_DEVICE, "Alias")) != NULL) {
+		strncpy(name, g_variant_get_string(property, NULL), sizeof(name) - 1);
+		name[sizeof(name) - 1] = '\0';
+		g_variant_unref(property);
+	}
+
+	d = device_new(config.hci_dev.dev_id, &addr, name);
+	bluealsa_device_insert(path, d);
+	return d;
+}
+
+/**
+ * Check whether channel mode configuration is valid. */
+static bool bluez_a2dp_codec_check_channel_mode(
+		const struct bluez_a2dp_codec *codec,
+		unsigned int capabilities) {
+
+	size_t i;
+
+	for (i = 0; i < codec->channels_size; i++)
+		if (capabilities == codec->channels[i].value)
+			return true;
+
+	return false;
+}
+
+/**
+ * Check whether sampling frequency configuration is valid. */
+static bool bluez_a2dp_codec_check_sampling_freq(
+		const struct bluez_a2dp_codec *codec,
+		unsigned int capabilities) {
+
+	size_t i;
+
+	for (i = 0; i < codec->samplings_size; i++)
+		if (capabilities == codec->samplings[i].value)
+			return true;
+
+	return false;
+}
+
+/**
+ * Select (best) channel mode configuration. */
+static unsigned int bluez_a2dp_codec_select_channel_mode(
+		const struct bluez_a2dp_codec *codec,
+		unsigned int capabilities) {
+
+	size_t i;
+
+	/* If monophonic sound has been forced, check whether given codec supports
+	 * such a channel mode. Since mono channel mode shall be stored at index 0
+	 * we can simply check for its existence with a simple index lookup. */
+	if (config.a2dp.force_mono &&
+			codec->channels[0].mode == BLUEZ_A2DP_CHM_MONO &&
+			capabilities & codec->channels[0].value)
+		return codec->channels[0].value;
+
+	/* favor higher number of channels */
+	for (i = codec->channels_size; i > 0; i--)
+		if (capabilities & codec->channels[i - 1].value)
+			return codec->channels[i - 1].value;
+
+	return 0;
+}
+
+/**
+ * Select (best) sampling frequency configuration. */
+static unsigned int bluez_a2dp_codec_select_sampling_freq(
+		const struct bluez_a2dp_codec *codec,
+		unsigned int capabilities) {
+
+	size_t i;
+
+	if (config.a2dp.force_44100)
+		for (i = 0; i < codec->samplings_size; i++)
+			if (codec->samplings[i].frequency == 44100) {
+				if (capabilities & codec->samplings[i].value)
+					return codec->samplings[i].value;
+				break;
+			}
+
+	/* favor higher sampling frequencies */
+	for (i = codec->samplings_size; i > 0; i--)
+		if (capabilities & codec->samplings[i - 1].value)
+			return codec->samplings[i - 1].value;
+
+	return 0;
+}
+
+/**
+ * Set transport state using BlueZ state string. */
+static int bluez_a2dp_set_transport_state(
+		struct ba_transport *t,
+		const char *state) {
+
+	if (strcmp(state, BLUEZ_TRANSPORT_STATE_IDLE) == 0)
+		return transport_set_state(t, TRANSPORT_IDLE);
+	else if (strcmp(state, BLUEZ_TRANSPORT_STATE_PENDING) == 0)
+		return transport_set_state(t, TRANSPORT_PENDING);
+	else if (strcmp(state, BLUEZ_TRANSPORT_STATE_ACTIVE) == 0)
+		return transport_set_state(t, TRANSPORT_ACTIVE);
+
+	warn("Invalid state: %s", state);
+	return -1;
+}
+
 static void bluez_endpoint_select_configuration(GDBusMethodInvocation *inv, void *userdata) {
-	(void)userdata;
 
 	const char *path = g_dbus_method_invocation_get_object_path(inv);
 	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
+	const struct bluez_a2dp_codec *codec = userdata;
 
 	const uint8_t *data;
 	uint8_t *capabilities;
@@ -57,45 +188,25 @@ static void bluez_endpoint_select_configuration(GDBusMethodInvocation *inv, void
 	capabilities = g_memdup(data, size);
 	g_variant_unref(params);
 
-	switch (g_dbus_object_path_to_a2dp_codec(path)) {
-	case A2DP_CODEC_SBC: {
+	if (size != codec->cfg_size) {
+		error("Invalid capabilities size: %zu != %zu", size, codec->cfg_size);
+		goto fail;
+	}
 
-		if (size != sizeof(a2dp_sbc_t)) {
-			error("Invalid capabilities size: %zu != %zu", size, sizeof(a2dp_sbc_t));
-			goto fail;
-		}
+	switch (codec->id) {
+	case A2DP_CODEC_SBC: {
 
 		a2dp_sbc_t *cap = (a2dp_sbc_t *)capabilities;
+		unsigned int cap_chm = cap->channel_mode;
+		unsigned int cap_freq = cap->frequency;
 
-		if (config.a2dp.force_44100 &&
-				cap->frequency & SBC_SAMPLING_FREQ_44100)
-			cap->frequency = SBC_SAMPLING_FREQ_44100;
-		else if (cap->frequency & SBC_SAMPLING_FREQ_48000)
-			cap->frequency = SBC_SAMPLING_FREQ_48000;
-		else if (cap->frequency & SBC_SAMPLING_FREQ_44100)
-			cap->frequency = SBC_SAMPLING_FREQ_44100;
-		else if (cap->frequency & SBC_SAMPLING_FREQ_32000)
-			cap->frequency = SBC_SAMPLING_FREQ_32000;
-		else if (cap->frequency & SBC_SAMPLING_FREQ_16000)
-			cap->frequency = SBC_SAMPLING_FREQ_16000;
-		else {
-			error("No supported sampling frequencies: %#x", cap->frequency);
+		if ((cap->channel_mode = bluez_a2dp_codec_select_channel_mode(codec, cap_chm)) == 0) {
+			error("No supported channel modes: %#x", cap_chm);
 			goto fail;
 		}
 
-		if (config.a2dp.force_mono &&
-				cap->channel_mode & SBC_CHANNEL_MODE_MONO)
-			cap->channel_mode = SBC_CHANNEL_MODE_MONO;
-		else if (cap->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-			cap->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-		else if (cap->channel_mode & SBC_CHANNEL_MODE_STEREO)
-			cap->channel_mode = SBC_CHANNEL_MODE_STEREO;
-		else if (cap->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-			cap->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
-		else if (cap->channel_mode & SBC_CHANNEL_MODE_MONO)
-			cap->channel_mode = SBC_CHANNEL_MODE_MONO;
-		else {
-			error("No supported channel modes: %#x", cap->channel_mode);
+		if ((cap->frequency = bluez_a2dp_codec_select_sampling_freq(codec, cap_freq)) == 0) {
+			error("No supported sampling frequencies: %#x", cap_freq);
 			goto fail;
 		}
 
@@ -137,15 +248,33 @@ static void bluez_endpoint_select_configuration(GDBusMethodInvocation *inv, void
 		break;
 	}
 
-#if ENABLE_AAC
-	case A2DP_CODEC_MPEG24: {
+#if ENABLE_MPEG
+	case A2DP_CODEC_MPEG12: {
 
-		if (size != sizeof(a2dp_aac_t)) {
-			error("Invalid capabilities size: %zu != %zu", size, sizeof(a2dp_aac_t));
+		a2dp_mpeg_t *cap = (a2dp_mpeg_t *)capabilities;
+		unsigned int cap_chm = cap->channel_mode;
+		unsigned int cap_freq = cap->frequency;
+
+		if ((cap->channel_mode = bluez_a2dp_codec_select_channel_mode(codec, cap_chm)) == 0) {
+			error("No supported channel modes: %#x", cap_chm);
 			goto fail;
 		}
 
+		if ((cap->frequency = bluez_a2dp_codec_select_sampling_freq(codec, cap_freq)) == 0) {
+			error("No supported sampling frequencies: %#x", cap_freq);
+			goto fail;
+		}
+
+		break;
+	}
+#endif
+
+#if ENABLE_AAC
+	case A2DP_CODEC_MPEG24: {
+
 		a2dp_aac_t *cap = (a2dp_aac_t *)capabilities;
+		unsigned int cap_chm = cap->channels;
+		unsigned int cap_freq = AAC_GET_FREQUENCY(*cap);
 
 		if (cap->object_type & AAC_OBJECT_TYPE_MPEG4_AAC_SCA)
 			cap->object_type = AAC_OBJECT_TYPE_MPEG4_AAC_SCA;
@@ -160,48 +289,16 @@ static void bluez_endpoint_select_configuration(GDBusMethodInvocation *inv, void
 			goto fail;
 		}
 
-		unsigned int sampling = AAC_GET_FREQUENCY(*cap);
-		if (config.a2dp.force_44100 &&
-				sampling & AAC_SAMPLING_FREQ_44100)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_44100);
-		else if (sampling & AAC_SAMPLING_FREQ_96000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_96000);
-		else if (sampling & AAC_SAMPLING_FREQ_88200)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_88200);
-		else if (sampling & AAC_SAMPLING_FREQ_64000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_64000);
-		else if (sampling & AAC_SAMPLING_FREQ_48000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_48000);
-		else if (sampling & AAC_SAMPLING_FREQ_44100)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_44100);
-		else if (sampling & AAC_SAMPLING_FREQ_32000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_32000);
-		else if (sampling & AAC_SAMPLING_FREQ_24000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_24000);
-		else if (sampling & AAC_SAMPLING_FREQ_22050)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_22050);
-		else if (sampling & AAC_SAMPLING_FREQ_16000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_16000);
-		else if (sampling & AAC_SAMPLING_FREQ_12000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_12000);
-		else if (sampling & AAC_SAMPLING_FREQ_11025)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_11025);
-		else if (sampling & AAC_SAMPLING_FREQ_8000)
-			AAC_SET_FREQUENCY(*cap, AAC_SAMPLING_FREQ_8000);
-		else {
-			error("No supported sampling frequencies: %#x", sampling);
+		if ((cap->channels = bluez_a2dp_codec_select_channel_mode(codec, cap_chm)) == 0) {
+			error("No supported channels: %#x", cap_chm);
 			goto fail;
 		}
 
-		if (config.a2dp.force_mono &&
-				cap->channels & AAC_CHANNELS_1)
-			cap->channels = AAC_CHANNELS_1;
-		else if (cap->channels & AAC_CHANNELS_2)
-			cap->channels = AAC_CHANNELS_2;
-		else if (cap->channels & AAC_CHANNELS_1)
-			cap->channels = AAC_CHANNELS_1;
+		unsigned int freq;
+		if ((freq = bluez_a2dp_codec_select_sampling_freq(codec, cap_freq)) != 0)
+			AAC_SET_FREQUENCY(*cap, freq);
 		else {
-			error("No supported channels: %#x", cap->channels);
+			error("No supported sampling frequencies: %#x", cap_freq);
 			goto fail;
 		}
 
@@ -212,33 +309,38 @@ static void bluez_endpoint_select_configuration(GDBusMethodInvocation *inv, void
 #if ENABLE_APTX
 	case A2DP_CODEC_VENDOR_APTX: {
 
-		if (size != sizeof(a2dp_aptx_t)) {
-			error("Invalid capabilities size: %zu != %zu", size, sizeof(a2dp_aptx_t));
+		a2dp_aptx_t *cap = (a2dp_aptx_t *)capabilities;
+		unsigned int cap_chm = cap->channel_mode;
+		unsigned int cap_freq = cap->frequency;
+
+		if ((cap->channel_mode = bluez_a2dp_codec_select_channel_mode(codec, cap_chm)) == 0) {
+			error("No supported channel modes: %#x", cap_chm);
 			goto fail;
 		}
 
-		a2dp_aptx_t *cap = (a2dp_aptx_t *)capabilities;
+		if ((cap->frequency = bluez_a2dp_codec_select_sampling_freq(codec, cap_freq)) == 0) {
+			error("No supported sampling frequencies: %#x", cap_freq);
+			goto fail;
+		}
 
-		if (config.a2dp.force_44100 &&
-				cap->frequency & APTX_SAMPLING_FREQ_44100)
-			cap->frequency = APTX_SAMPLING_FREQ_44100;
-		else if (cap->frequency & APTX_SAMPLING_FREQ_48000)
-			cap->frequency = APTX_SAMPLING_FREQ_48000;
-		else if (cap->frequency & APTX_SAMPLING_FREQ_44100)
-			cap->frequency = APTX_SAMPLING_FREQ_44100;
-		else if (cap->frequency & APTX_SAMPLING_FREQ_32000)
-			cap->frequency = APTX_SAMPLING_FREQ_32000;
-		else if (cap->frequency & APTX_SAMPLING_FREQ_16000)
-			cap->frequency = APTX_SAMPLING_FREQ_16000;
-		else {
-			error("No supported sampling frequencies: %#x", cap->frequency);
+		break;
+	}
+#endif
+
+#if ENABLE_LDAC
+	case A2DP_CODEC_VENDOR_LDAC: {
+
+		a2dp_ldac_t *cap = (a2dp_ldac_t *)capabilities;
+		unsigned int cap_chm = cap->channel_mode;
+		unsigned int cap_freq = cap->frequency;
+
+		if ((cap->channel_mode = bluez_a2dp_codec_select_channel_mode(codec, cap_chm)) == 0) {
+			error("No supported channel modes: %#x", cap_chm);
 			goto fail;
 		}
 
-		if (cap->channel_mode & APTX_CHANNEL_MODE_STEREO)
-			cap->channel_mode = APTX_CHANNEL_MODE_STEREO;
-		else {
-			error("No supported channel modes: %#x", cap->channel_mode);
+		if ((cap->frequency = bluez_a2dp_codec_select_sampling_freq(codec, cap_freq)) == 0) {
+			error("No supported sampling frequencies: %#x", cap_freq);
 			goto fail;
 		}
 
@@ -274,18 +376,18 @@ final:
 }
 
 static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *userdata) {
-	(void)userdata;
 
 	const gchar *sender = g_dbus_method_invocation_get_sender(inv);
 	const gchar *path = g_dbus_method_invocation_get_object_path(inv);
 	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
+	const struct bluez_a2dp_codec *codec = userdata;
+	bool devpool_mutex_locked = false;
 	struct ba_transport *t;
 	struct ba_device *d;
 
 	const int profile = g_dbus_object_path_to_profile(path);
-	const uint16_t codec = g_dbus_object_path_to_a2dp_codec(path);
+	const uint16_t codec_id = codec->id;
 
-	const char *transport;
 	char *device = NULL, *state = NULL;
 	uint8_t *configuration = NULL;
 	uint16_t volume = 127;
@@ -293,18 +395,12 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 	size_t size = 0;
 	int ret = 0;
 
+	const char *transport;
 	GVariantIter *properties;
 	GVariant *value = NULL;
 	const char *key;
 
 	g_variant_get(params, "(&oa{sv})", &transport, &properties);
-
-	if (transport_lookup(config.devices, transport) != NULL) {
-		error("Transport already configured: %s", transport);
-		goto fail;
-	}
-
-	/* read transport properties */
 	while (g_variant_iter_next(properties, "{&sv}", &key, &value)) {
 
 		if (strcmp(key, "Device") == 0) {
@@ -328,7 +424,7 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 				goto fail;
 			}
 
-			if ((codec & 0xFF) != g_variant_get_byte(value)) {
+			if ((codec_id & 0xFF) != g_variant_get_byte(value)) {
 				error("Invalid configuration: %s", "Codec mismatch");
 				goto fail;
 			}
@@ -342,36 +438,23 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 				goto fail;
 			}
 
-			const guchar *capabilities;
+			const guchar *capabilities = g_variant_get_fixed_array(value, &size, sizeof(uint8_t));
+			unsigned int cap_chm = 0;
+			unsigned int cap_freq = 0;
 
-			capabilities = g_variant_get_fixed_array(value, &size, sizeof(uint8_t));
 			configuration = g_memdup(capabilities, size);
 
-			switch (codec) {
-			case A2DP_CODEC_SBC: {
+			if (size != codec->cfg_size) {
+				error("Invalid configuration: %s", "Invalid size");
+				goto fail;
+			}
 
-				if (size != sizeof(a2dp_sbc_t)) {
-					error("Invalid configuration: %s", "Invalid size");
-					goto fail;
-				}
+			switch (codec_id) {
+			case A2DP_CODEC_SBC: {
 
 				const a2dp_sbc_t *cap = (a2dp_sbc_t *)capabilities;
-
-				if (cap->frequency != SBC_SAMPLING_FREQ_16000 &&
-						cap->frequency != SBC_SAMPLING_FREQ_32000 &&
-						cap->frequency != SBC_SAMPLING_FREQ_44100 &&
-						cap->frequency != SBC_SAMPLING_FREQ_48000) {
-					error("Invalid configuration: %s", "Invalid sampling frequency");
-					goto fail;
-				}
-
-				if (cap->channel_mode != SBC_CHANNEL_MODE_MONO &&
-						cap->channel_mode != SBC_CHANNEL_MODE_DUAL_CHANNEL &&
-						cap->channel_mode != SBC_CHANNEL_MODE_STEREO &&
-						cap->channel_mode != SBC_CHANNEL_MODE_JOINT_STEREO) {
-					error("Invalid configuration: %s", "Invalid channel mode");
-					goto fail;
-				}
+				cap_chm = cap->channel_mode;
+				cap_freq = cap->frequency;
 
 				if (cap->allocation_method != SBC_ALLOCATION_SNR &&
 						cap->allocation_method != SBC_ALLOCATION_LOUDNESS) {
@@ -396,15 +479,21 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 				break;
 			}
 
+#if ENABLE_MPEG
+			case A2DP_CODEC_MPEG12: {
+				a2dp_mpeg_t *cap = (a2dp_mpeg_t *)capabilities;
+				cap_chm = cap->channel_mode;
+				cap_freq = cap->frequency;
+				break;
+			}
+#endif
+
 #if ENABLE_AAC
 			case A2DP_CODEC_MPEG24: {
 
-				if (size != sizeof(a2dp_aac_t)) {
-					error("Invalid configuration: %s", "Invalid size");
-					goto fail;
-				}
-
 				const a2dp_aac_t *cap = (a2dp_aac_t *)capabilities;
+				cap_chm = cap->channels;
+				cap_freq = AAC_GET_FREQUENCY(*cap);
 
 				if (cap->object_type != AAC_OBJECT_TYPE_MPEG2_AAC_LC &&
 						cap->object_type != AAC_OBJECT_TYPE_MPEG4_AAC_LC &&
@@ -414,56 +503,24 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 					goto fail;
 				}
 
-				unsigned int sampling = AAC_GET_FREQUENCY(*cap);
-				if (sampling != AAC_SAMPLING_FREQ_8000 &&
-						sampling != AAC_SAMPLING_FREQ_11025 &&
-						sampling != AAC_SAMPLING_FREQ_12000 &&
-						sampling != AAC_SAMPLING_FREQ_16000 &&
-						sampling != AAC_SAMPLING_FREQ_22050 &&
-						sampling != AAC_SAMPLING_FREQ_24000 &&
-						sampling != AAC_SAMPLING_FREQ_32000 &&
-						sampling != AAC_SAMPLING_FREQ_44100 &&
-						sampling != AAC_SAMPLING_FREQ_48000 &&
-						sampling != AAC_SAMPLING_FREQ_64000 &&
-						sampling != AAC_SAMPLING_FREQ_88200 &&
-						sampling != AAC_SAMPLING_FREQ_96000) {
-					error("Invalid configuration: %s", "Invalid sampling frequency");
-					goto fail;
-				}
-
-				if (cap->channels != AAC_CHANNELS_1 &&
-						cap->channels != AAC_CHANNELS_2) {
-					error("Invalid configuration: %s", "Invalid channels");
-					goto fail;
-				}
-
 				break;
 			}
 #endif
 
 #if ENABLE_APTX
 			case A2DP_CODEC_VENDOR_APTX: {
-
-				if (size != sizeof(a2dp_aptx_t)) {
-					error("Invalid configuration: %s", "Invalid size");
-					goto fail;
-				}
-
 				a2dp_aptx_t *cap = (a2dp_aptx_t *)capabilities;
+				cap_chm = cap->channel_mode;
+				cap_freq = cap->frequency;
+				break;
+			}
+#endif
 
-				if (cap->frequency != APTX_SAMPLING_FREQ_16000 &&
-						cap->frequency != APTX_SAMPLING_FREQ_32000 &&
-						cap->frequency != APTX_SAMPLING_FREQ_44100 &&
-						cap->frequency != APTX_SAMPLING_FREQ_48000) {
-					error("Invalid configuration: %s", "Invalid sampling frequency");
-					goto fail;
-				}
-
-				if (cap->channel_mode != APTX_CHANNEL_MODE_STEREO) {
-					error("Invalid configuration: %s", "Invalid channel mode");
-					goto fail;
-				}
-
+#if ENABLE_LDAC
+			case A2DP_CODEC_VENDOR_LDAC: {
+				a2dp_ldac_t *cap = (a2dp_ldac_t *)capabilities;
+				cap_chm = cap->channel_mode;
+				cap_freq = cap->frequency;
 				break;
 			}
 #endif
@@ -473,6 +530,16 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 				goto fail;
 			}
 
+			if (!bluez_a2dp_codec_check_channel_mode(codec, cap_chm)) {
+				error("Invalid configuration: %s", "Invalid channel mode");
+				goto fail;
+			}
+
+			if (!bluez_a2dp_codec_check_sampling_freq(codec, cap_freq)) {
+				error("Invalid configuration: %s", "Invalid sampling frequency");
+				goto fail;
+			}
+
 		}
 		else if (strcmp(key, "State") == 0) {
 
@@ -514,17 +581,23 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 	}
 
 	/* we are going to modify the devices hash-map */
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
+	devpool_mutex_locked = true;
+
+	if (transport_lookup(config.devices, transport) != NULL) {
+		error("Transport already configured: %s", transport);
+		goto fail;
+	}
 
 	/* get the device structure for obtained device path */
-	if ((d = device_get(config.devices, device)) == NULL) {
+	if ((d = bluez_get_device(device)) == NULL) {
 		error("Couldn't get device: %s", strerror(errno));
 		goto fail;
 	}
 
 	/* Create a new transport with a human-readable name. Since the transport
 	 * name can not be obtained from the client, we will use a fall-back one. */
-	if ((t = transport_new_a2dp(d, sender, transport, profile, codec,
+	if ((t = transport_new_a2dp(d, sender, transport, profile, codec_id,
 					configuration, size)) == NULL) {
 		error("Couldn't create new transport: %s", strerror(errno));
 		goto fail;
@@ -536,12 +609,12 @@ static int bluez_endpoint_set_configuration(GDBusMethodInvocation *inv, void *us
 
 	debug("%s (%s) configured for device %s",
 			bluetooth_profile_to_string(profile),
-			bluetooth_a2dp_codec_to_string(codec),
+			bluetooth_a2dp_codec_to_string(codec_id),
 			batostr_(&d->addr));
 	debug("Configuration: channels: %u, sampling: %u",
 			transport_get_channels(t), transport_get_sampling(t));
 
-	transport_set_state_from_string(t, state);
+	bluez_a2dp_set_transport_state(t, state);
 
 	g_dbus_method_invocation_return_value(inv, NULL);
 	goto final;
@@ -552,7 +625,8 @@ fail:
 	ret = -1;
 
 final:
-	pthread_mutex_unlock(&config.devices_mutex);
+	if (devpool_mutex_locked)
+		bluealsa_devpool_mutex_unlock();
 	g_variant_iter_free(properties);
 	if (value != NULL)
 		g_variant_unref(value);
@@ -568,12 +642,12 @@ static void bluez_endpoint_clear_configuration(GDBusMethodInvocation *inv, void
 	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
 	const char *transport;
 
-	pthread_mutex_lock(&config.devices_mutex);
-
 	g_variant_get(params, "(&o)", &transport);
+
+	bluealsa_devpool_mutex_lock();
 	transport_remove(config.devices, transport);
+	bluealsa_devpool_mutex_unlock();
 
-	pthread_mutex_unlock(&config.devices_mutex);
 	g_object_unref(inv);
 }
 
@@ -603,23 +677,23 @@ static void bluez_endpoint_method_call(GDBusConnection *conn, const gchar *sende
 	(void)interface;
 	(void)params;
 
-	struct ba_dbus_object *obj;
-
 	debug("Endpoint method call: %s.%s()", interface, method);
 
 	gpointer hash = GINT_TO_POINTER(g_str_hash(path));
-	obj = g_hash_table_lookup(config.dbus_objects, hash);
+	struct ba_dbus_object *obj;
 
 	if (strcmp(method, "SelectConfiguration") == 0)
 		bluez_endpoint_select_configuration(invocation, userdata);
 	else if (strcmp(method, "SetConfiguration") == 0) {
 		if (bluez_endpoint_set_configuration(invocation, userdata) == 0) {
+			obj = g_hash_table_lookup(config.dbus_objects, hash);
 			obj->connected = true;
 			bluez_register_a2dp();
 		}
 	}
 	else if (strcmp(method, "ClearConfiguration") == 0) {
 		bluez_endpoint_clear_configuration(invocation, userdata);
+		obj = g_hash_table_lookup(config.dbus_objects, hash);
 		obj->connected = false;
 	}
 	else if (strcmp(method, "Release") == 0)
@@ -675,12 +749,12 @@ static int bluez_register_a2dp_endpoint(
 	debug("Registering endpoint: %s", path);
 	if ((dbus_object.id = g_dbus_connection_register_object(conn, path,
 					(GDBusInterfaceInfo *)&bluez_iface_endpoint, &endpoint_vtable,
-					NULL, endpoint_free, &err)) == 0)
+					(void *)codec, endpoint_free, &err)) == 0)
 		goto fail;
 
 	dev = g_strdup_printf("/org/bluez/%s", config.hci_dev.name);
-	msg = g_dbus_message_new_method_call("org.bluez", dev,
-			"org.bluez.Media1", "RegisterEndpoint");
+	msg = g_dbus_message_new_method_call(BLUEZ_SERVICE, dev,
+			BLUEZ_IFACE_MEDIA, "RegisterEndpoint");
 
 	GVariantBuilder caps;
 	GVariantBuilder properties;
@@ -692,6 +766,7 @@ static int bluez_register_a2dp_endpoint(
 		g_variant_builder_add(&caps, "y", ((uint8_t *)codec->cfg)[i]);
 
 	g_variant_builder_add(&properties, "{sv}", "UUID", g_variant_new_string(uuid));
+	g_variant_builder_add(&properties, "{sv}", "DelayReporting", g_variant_new_boolean(TRUE));
 	g_variant_builder_add(&properties, "{sv}", "Codec", g_variant_new_byte(codec->id));
 	g_variant_builder_add(&properties, "{sv}", "Capabilities", g_variant_builder_end(&caps));
 
@@ -761,6 +836,7 @@ static void bluez_profile_new_connection(GDBusMethodInvocation *inv, void *userd
 	const gchar *sender = g_dbus_method_invocation_get_sender(inv);
 	const gchar *path = g_dbus_method_invocation_get_object_path(inv);
 	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
+	bool devpool_mutex_locked = false;
 	struct ba_transport *t;
 	struct ba_device *d;
 
@@ -780,7 +856,11 @@ static void bluez_profile_new_connection(GDBusMethodInvocation *inv, void *userd
 		goto fail;
 	}
 
-	if ((d = device_get(config.devices, device)) == NULL) {
+	/* we are going to modify the devices hash-map */
+	bluealsa_devpool_mutex_lock();
+	devpool_mutex_locked = true;
+
+	if ((d = bluez_get_device(device)) == NULL) {
 		error("Couldn't get device: %s", strerror(errno));
 		goto fail;
 	}
@@ -791,12 +871,12 @@ static void bluez_profile_new_connection(GDBusMethodInvocation *inv, void *userd
 	}
 
 	t->bt_fd = fd;
-	t->release = transport_release_bt_rfcomm;
 
 	debug("%s configured for device %s",
 			bluetooth_profile_to_string(profile), batostr_(&d->addr));
 
 	transport_set_state(t, TRANSPORT_ACTIVE);
+	transport_set_state(t->rfcomm.sco, TRANSPORT_ACTIVE);
 
 	g_dbus_method_invocation_return_value(inv, NULL);
 	goto final;
@@ -806,6 +886,8 @@ fail:
 			G_DBUS_ERROR_INVALID_ARGS, "Unable to connect profile");
 
 final:
+	if (devpool_mutex_locked)
+		bluealsa_devpool_mutex_unlock();
 	g_variant_iter_free(properties);
 	if (err != NULL)
 		g_error_free(err);
@@ -817,12 +899,11 @@ static void bluez_profile_request_disconnection(GDBusMethodInvocation *inv, void
 	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
 	const char *device;
 
-	pthread_mutex_lock(&config.devices_mutex);
-
 	g_variant_get(params, "(&o)", &device);
-	transport_remove(config.devices, device);
 
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
+	transport_remove(config.devices, device);
+	bluealsa_devpool_mutex_unlock();
 
 	g_object_unref(inv);
 }
@@ -867,10 +948,6 @@ static void bluez_profile_method_call(GDBusConnection *conn, const gchar *sender
 
 }
 
-void profile_free(gpointer data) {
-	(void)data;
-}
-
 static const GDBusInterfaceVTable profile_vtable = {
 	.method_call = bluez_profile_method_call,
 };
@@ -910,11 +987,11 @@ static int bluez_register_profile(
 	debug("Registering profile: %s", path);
 	if ((dbus_object.id = g_dbus_connection_register_object(conn, path,
 					(GDBusInterfaceInfo *)&bluez_iface_profile, &profile_vtable,
-					NULL, profile_free, &err)) == 0)
+					NULL, NULL, &err)) == 0)
 		goto fail;
 
-	msg = g_dbus_message_new_method_call("org.bluez", "/org/bluez",
-			"org.bluez.ProfileManager1", "RegisterProfile");
+	msg = g_dbus_message_new_method_call(BLUEZ_SERVICE, "/org/bluez",
+			BLUEZ_IFACE_PROFILE_MANAGER, "RegisterProfile");
 
 	GVariantBuilder options;
 
@@ -1011,6 +1088,7 @@ static void bluez_signal_transport_changed(GDBusConnection *conn, const gchar *s
 	(void)userdata;
 
 	const gchar *signature = g_variant_get_type_string(params);
+	bool devpool_mutex_locked = false;
 	GVariantIter *properties = NULL;
 	GVariantIter *unknown = NULL;
 	GVariant *value = NULL;
@@ -1023,15 +1101,17 @@ static void bluez_signal_transport_changed(GDBusConnection *conn, const gchar *s
 		goto fail;
 	}
 
+	bluealsa_devpool_mutex_lock();
+	devpool_mutex_locked = true;
+
 	if ((t = transport_lookup(config.devices, path)) == NULL) {
 		error("Transport not available: %s", path);
 		goto fail;
 	}
 
 	g_variant_get(params, "(&sa{sv}as)", &iface, &properties, &unknown);
-	debug("Signal: %s: %s", signal, iface);
-
 	while (g_variant_iter_next(properties, "{&sv}", &key, &value)) {
+		debug("Signal: %s: %s: %s", signal, iface, key);
 
 		if (strcmp(key, "State") == 0) {
 
@@ -1041,7 +1121,7 @@ static void bluez_signal_transport_changed(GDBusConnection *conn, const gchar *s
 				goto fail;
 			}
 
-			transport_set_state_from_string(t, g_variant_get_string(value, NULL));
+			bluez_a2dp_set_transport_state(t, g_variant_get_string(value, NULL));
 
 		}
 		else if (strcmp(key, "Delay") == 0) {
@@ -1066,6 +1146,10 @@ static void bluez_signal_transport_changed(GDBusConnection *conn, const gchar *s
 			/* received volume is in range [0, 127]*/
 			t->a2dp.ch1_volume = t->a2dp.ch2_volume = g_variant_get_uint16(value);
 
+			bluealsa_ctl_send_event(BA_EVENT_VOLUME_CHANGED, &t->device->addr,
+					BA_PCM_TYPE_A2DP | (t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE ?
+						BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE));
+
 		}
 
 		g_variant_unref(value);
@@ -1073,6 +1157,8 @@ static void bluez_signal_transport_changed(GDBusConnection *conn, const gchar *s
 	}
 
 fail:
+	if (devpool_mutex_locked)
+		bluealsa_devpool_mutex_unlock();
 	if (properties != NULL)
 		g_variant_iter_free(properties);
 	if (value != NULL)
@@ -1089,14 +1175,14 @@ int bluez_subscribe_signals(void) {
 
 	/* Note, that we do not have to subscribe for the interfaces remove signal,
 	 * because prior to removal, BlueZ will emit appropriate "clear" signal. */
-	g_dbus_connection_signal_subscribe(conn, "org.bluez", "org.freedesktop.DBus.ObjectManager",
+	g_dbus_connection_signal_subscribe(conn, BLUEZ_SERVICE, "org.freedesktop.DBus.ObjectManager",
 			"InterfacesAdded", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
 			/* TODO: Use arg0 filtering, but is seems it doesn't work... */
 			/* "InterfacesAdded", NULL, "/org/bluez/hci0", G_DBUS_SIGNAL_FLAGS_NONE, */
 			bluez_signal_interfaces_added, NULL, NULL);
 
-	g_dbus_connection_signal_subscribe(conn, "org.bluez", "org.freedesktop.DBus.Properties",
-			"PropertiesChanged", NULL, "org.bluez.MediaTransport1", G_DBUS_SIGNAL_FLAGS_NONE,
+	g_dbus_connection_signal_subscribe(conn, BLUEZ_SERVICE, "org.freedesktop.DBus.Properties",
+			"PropertiesChanged", NULL, BLUEZ_IFACE_MEDIA_TRANSPORT, G_DBUS_SIGNAL_FLAGS_NONE,
 			bluez_signal_transport_changed, NULL, NULL);
 
 	return 0;
diff --git a/src/ctl.c b/src/ctl.c
index 6f3eb89..0d0d571 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - ctl.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,10 +8,10 @@
  *
  */
 
-#define _GNU_SOURCE
 #include "ctl.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <poll.h>
 #include <pthread.h>
 #include <stdio.h>
@@ -27,6 +27,7 @@
 
 #include "a2dp-codecs.h"
 #include "bluealsa.h"
+#include "bluez-iface.h"
 #include "bluez.h"
 #include "hfp.h"
 #include "transport.h"
@@ -34,9 +35,14 @@
 #include "shared/defs.h"
 #include "shared/log.h"
 
+/* Special PCM type for internal usage only. */
+#define BA_PCM_TYPE_RFCOMM 0x1F
+
+#define ctl_pfds_idx(i) g_array_index(config.ctl.pfds, struct pollfd, i)
+#define ctl_subs_idx(i) g_array_index(config.ctl.subs, enum ba_event, i)
 
 /**
- * Looks up a transport matching BT address and profile.
+ * Lookup a transport matching BT address and profile.
  *
  * This function is not thread-safe. It returns references to objects managed
  * by the devices hash-table. If the devices hash-table is modified in some
@@ -44,14 +50,20 @@
  *
  * @param devices Address of the hash-table with connected devices.
  * @param addr Address to the structure with the looked up BT address.
- * @param type Looked up PCM type.
- * @param stream Looked up PCM stream direction.
+ * @param type Looked up PCM type with stream mask.
  * @param t Address, where the transport structure pointer should be stored.
- * @return If the lookup succeeded, this function returns 0. Otherwise, -1 is
- *   returned and value of transport pointer is undefined. */
-static int _transport_lookup(GHashTable *devices, const bdaddr_t *addr,
-		enum ba_pcm_type type, enum ba_pcm_stream stream, struct ba_transport **t) {
-
+ * @return If the lookup succeeded, this function returns 0. Otherwise, -1 or
+ *   -2 is returned respectively for not found device and not found stream.
+ *   Upon error value of the transport pointer is undefined. */
+static int ctl_lookup_transport(GHashTable *devices, const bdaddr_t *addr,
+		uint8_t type, struct ba_transport **t) {
+
+#if DEBUG
+	/* make sure that the device mutex is acquired */
+	g_assert(pthread_mutex_trylock(&config.devices_mutex) == EBUSY);
+#endif
+
+	bool device_found = false;
 	GHashTableIter iter_d, iter_t;
 	struct ba_device *d;
 
@@ -61,140 +73,76 @@ static int _transport_lookup(GHashTable *devices, const bdaddr_t *addr,
 		if (bacmp(&d->addr, addr) != 0)
 			continue;
 
-		for (g_hash_table_iter_init(&iter_t, d->transports);
-				g_hash_table_iter_next(&iter_t, NULL, (gpointer)t); ) {
+		device_found = true;
 
-			switch (type) {
+		for (g_hash_table_iter_init(&iter_t, d->transports);
+				g_hash_table_iter_next(&iter_t, NULL, (gpointer)t); )
+			switch (BA_PCM_TYPE(type)) {
 			case BA_PCM_TYPE_NULL:
 				continue;
 			case BA_PCM_TYPE_A2DP:
 				if ((*t)->type != TRANSPORT_TYPE_A2DP)
 					continue;
-				switch (stream) {
-				case BA_PCM_STREAM_PLAYBACK:
-					if ((*t)->profile != BLUETOOTH_PROFILE_A2DP_SOURCE)
-						continue;
-					break;
-				case BA_PCM_STREAM_CAPTURE:
-					if ((*t)->profile != BLUETOOTH_PROFILE_A2DP_SINK)
-						continue;
-					break;
-				case BA_PCM_STREAM_DUPLEX:
-					continue;
-				}
-				break;
+				if (type & BA_PCM_STREAM_PLAYBACK &&
+						(*t)->profile == BLUETOOTH_PROFILE_A2DP_SOURCE)
+					return 0;
+				if (type & BA_PCM_STREAM_CAPTURE &&
+						(*t)->profile == BLUETOOTH_PROFILE_A2DP_SINK)
+					return 0;
+				continue;
 			case BA_PCM_TYPE_SCO:
-				if ((*t)->type != TRANSPORT_TYPE_SCO)
-					continue;
-				/* ignore SCO transport if codec is not selected yet */
-				if ((*t)->codec == HFP_CODEC_UNDEFINED)
-					continue;
-				break;
-			}
-
-			return 0;
-		}
-
-	}
-
-	return -1;
-}
-
-static int _transport_lookup_rfcomm(GHashTable *devices, const bdaddr_t *addr,
-		struct ba_transport **t) {
-
-	GHashTableIter iter_d, iter_t;
-	struct ba_device *d;
-
-	for (g_hash_table_iter_init(&iter_d, devices);
-			g_hash_table_iter_next(&iter_d, NULL, (gpointer)&d); ) {
-
-		if (bacmp(&d->addr, addr) != 0)
-			continue;
-
-		for (g_hash_table_iter_init(&iter_t, d->transports);
-				g_hash_table_iter_next(&iter_t, NULL, (gpointer)t); ) {
-
-			if ((*t)->type != TRANSPORT_TYPE_RFCOMM)
+				if ((*t)->type == TRANSPORT_TYPE_SCO)
+					return 0;
+				continue;
+			case BA_PCM_TYPE_RFCOMM:
+				if ((*t)->type == TRANSPORT_TYPE_RFCOMM)
+					return 0;
 				continue;
+			}
 
-			return 0;
-		}
 	}
 
-	return -1;
+	return device_found ? -2 : -1;
 }
 
 /**
- * Get transport PCM structure.
+ * Lookup PCM structure associated with given client.
  *
  * @param t Pointer to the transport structure.
- * @param stream Stream type.
+ * @param type PCM type with stream mask.
+ * @param client Client file descriptor.
  * @return On success address of the PCM structure is returned. If the PCM
  *   structure can not be determined, NULL is returned. */
-static struct ba_pcm *_transport_get_pcm(struct ba_transport *t, enum ba_pcm_stream stream) {
+static struct ba_pcm *ctl_lookup_pcm(struct ba_transport *t, uint8_t type, int client) {
 	switch (t->type) {
 	case TRANSPORT_TYPE_A2DP:
-		return &t->a2dp.pcm;
+		if (t->a2dp.pcm.client == client)
+			return &t->a2dp.pcm;
+		break;
 	case TRANSPORT_TYPE_RFCOMM:
 		debug("Trying to get PCM for RFCOMM transport... that's nuts");
 		break;
 	case TRANSPORT_TYPE_SCO:
-		switch (stream) {
-		case BA_PCM_STREAM_PLAYBACK:
-			return &t->sco.spk_pcm;
-		case BA_PCM_STREAM_CAPTURE:
-			return &t->sco.mic_pcm;
-		case BA_PCM_STREAM_DUPLEX:
-			break;
-		}
-	}
-	return NULL;
-}
-
-/**
- * Release transport resources acquired by the controller module. */
-static void _transport_release(struct ba_transport *t, int client) {
-
-	/* For a source profile (where the stream is read from the PCM) an IO thread
-	 * terminates when the PCM is closed. However, it is asynchronous, so if the
-	 * client closes the connection, and then quickly tries to open it again, we
-	 * might try to acquire not yet released transport. To prevent this, we have
-	 * to make sure, that the transport is released (thread is terminated). */
-	if (t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE) {
-		pthread_cancel(t->thread);
-		pthread_join(t->thread, NULL);
-	}
-
-	switch (t->type) {
-	case TRANSPORT_TYPE_A2DP:
-		transport_release_pcm(&t->a2dp.pcm);
-		t->a2dp.pcm.client = -1;
+		if (type & BA_PCM_STREAM_PLAYBACK)
+			if (t->sco.spk_pcm.client == client)
+				return &t->sco.spk_pcm;
+		if (type & BA_PCM_STREAM_CAPTURE)
+			if (t->sco.mic_pcm.client == client)
+				return &t->sco.mic_pcm;
 		break;
-	case TRANSPORT_TYPE_RFCOMM:
-		break;
-	case TRANSPORT_TYPE_SCO:
-		if (t->sco.spk_pcm.client == client) {
-			transport_release_pcm(&t->sco.spk_pcm);
-			t->sco.spk_pcm.client = -1;
-		}
-		if (t->sco.mic_pcm.client == client) {
-			transport_release_pcm(&t->sco.mic_pcm);
-			t->sco.mic_pcm.client = -1;
-		}
 	}
-
+	return NULL;
 }
 
-static void _ctl_transport(const struct ba_transport *t, struct ba_msg_transport *transport) {
+static struct ba_msg_transport *ctl_transport(const struct ba_transport *t,
+		struct ba_msg_transport *transport) {
 
 	bacpy(&transport->addr, &t->device->addr);
 
 	switch (t->type) {
 	case TRANSPORT_TYPE_A2DP:
-		transport->type = BA_PCM_TYPE_A2DP;
-		transport->stream = t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE ?
-			BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE;
+		transport->type = BA_PCM_TYPE_A2DP | (t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE ?
+				BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE);
 		transport->ch1_muted = t->a2dp.ch1_muted;
 		transport->ch1_volume = t->a2dp.ch1_volume;
 		transport->ch2_muted = t->a2dp.ch2_muted;
@@ -205,8 +153,7 @@ static void _ctl_transport(const struct ba_transport *t, struct ba_msg_transport
 		transport->type = BA_PCM_TYPE_NULL;
 		break;
 	case TRANSPORT_TYPE_SCO:
-		transport->type = BA_PCM_TYPE_SCO;
-		transport->stream = BA_PCM_STREAM_DUPLEX;
+		transport->type = BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE;
 		transport->ch1_muted = t->sco.spk_muted;
 		transport->ch1_volume = t->sco.spk_gain;
 		transport->ch2_muted = t->sco.mic_muted;
@@ -220,11 +167,12 @@ static void _ctl_transport(const struct ba_transport *t, struct ba_msg_transport
 	transport->sampling = transport_get_sampling(t);
 	transport->delay += t->delay;
 
+	return transport;
 }
 
 static void ctl_thread_cmd_ping(const struct ba_request *req, int fd) {
 	(void)req;
-	static const struct ba_msg_status status = { BA_STATUS_CODE_PONG };
+	static const struct ba_msg_status status = { BA_STATUS_CODE_SUCCESS };
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -233,9 +181,9 @@ static void ctl_thread_cmd_subscribe(const struct ba_request *req, int fd) {
 	static const struct ba_msg_status status = { BA_STATUS_CODE_SUCCESS };
 	size_t i;
 
-	for (i = __CTL_IDX_MAX; i < __CTL_IDX_MAX + BLUEALSA_MAX_CLIENTS; i++)
-		if (config.ctl.pfds[i].fd == fd)
-			config.ctl.subs[i - __CTL_IDX_MAX] = req->events;
+	for (i = __CTL_IDX_MAX; i < config.ctl.pfds->len; i++)
+		if (ctl_pfds_idx(i).fd == fd)
+			ctl_subs_idx(i - __CTL_IDX_MAX) = req->events;
 
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
@@ -248,7 +196,7 @@ static void ctl_thread_cmd_list_devices(const struct ba_request *req, int fd) {
 	GHashTableIter iter_d;
 	struct ba_device *d;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
 	for (g_hash_table_iter_init(&iter_d, config.devices);
 			g_hash_table_iter_next(&iter_d, NULL, (gpointer)&d); ) {
@@ -263,7 +211,7 @@ static void ctl_thread_cmd_list_devices(const struct ba_request *req, int fd) {
 		send(fd, &device, sizeof(device), MSG_NOSIGNAL);
 	}
 
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -276,20 +224,17 @@ static void ctl_thread_cmd_list_transports(const struct ba_request *req, int fd)
 	struct ba_device *d;
 	struct ba_transport *t;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
 	for (g_hash_table_iter_init(&iter_d, config.devices);
 			g_hash_table_iter_next(&iter_d, NULL, (gpointer)&d); )
 		for (g_hash_table_iter_init(&iter_t, d->transports);
 				g_hash_table_iter_next(&iter_t, NULL, (gpointer)&t); ) {
-			/* ignore SCO transport if codec is not selected yet */
-			if (t->type == TRANSPORT_TYPE_SCO && t->codec == HFP_CODEC_UNDEFINED)
-				continue;
-			_ctl_transport(t, &transport);
+			ctl_transport(t, &transport);
 			send(fd, &transport, sizeof(transport), MSG_NOSIGNAL);
 		}
 
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -299,18 +244,22 @@ static void ctl_thread_cmd_transport_get(const struct ba_request *req, int fd) {
 	struct ba_msg_transport transport;
 	struct ba_transport *t;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
-	if (_transport_lookup(config.devices, &req->addr, req->type, req->stream, &t) != 0) {
+	switch (ctl_lookup_transport(config.devices, &req->addr, req->type, &t)) {
+	case -1:
 		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
 		goto fail;
+	case -2:
+		status.code = BA_STATUS_CODE_STREAM_NOT_FOUND;
+		goto fail;
 	}
 
-	_ctl_transport(t, &transport);
+	ctl_transport(t, &transport);
 	send(fd, &transport, sizeof(transport), MSG_NOSIGNAL);
 
 fail:
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -319,17 +268,56 @@ static void ctl_thread_cmd_transport_set_volume(const struct ba_request *req, in
 	struct ba_msg_status status = { BA_STATUS_CODE_SUCCESS };
 	struct ba_transport *t;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
-	if (_transport_lookup(config.devices, &req->addr, req->type, req->stream, &t) != 0) {
+	switch (ctl_lookup_transport(config.devices, &req->addr, req->type, &t)) {
+	case -1:
 		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
 		goto fail;
+	case -2:
+		status.code = BA_STATUS_CODE_STREAM_NOT_FOUND;
+		goto fail;
+	}
+
+	debug("Setting volume for %s type %#x: %d<>%d [%c%c]",
+			batostr_(&req->addr), req->type, req->ch1_volume, req->ch2_volume,
+			req->ch1_muted ? 'M' : 'O', req->ch2_muted ? 'M' : 'O');
+
+	switch (BA_PCM_TYPE(req->type)) {
+	case BA_PCM_TYPE_A2DP:
+
+		t->a2dp.ch1_muted = req->ch1_muted;
+		t->a2dp.ch2_muted = req->ch2_muted;
+		t->a2dp.ch1_volume = req->ch1_volume;
+		t->a2dp.ch2_volume = req->ch2_volume;
+
+		if (config.a2dp.volume) {
+			uint16_t volume = (req->ch1_muted | req->ch2_muted) ? 0 : MIN(req->ch1_volume, req->ch2_volume);
+			g_dbus_set_property(config.dbus, t->dbus_owner, t->dbus_path,
+					BLUEZ_IFACE_MEDIA_TRANSPORT, "Volume", g_variant_new_uint16(volume));
+		}
+
+		break;
+
+	case BA_PCM_TYPE_SCO:
+
+		t->sco.spk_muted = req->ch1_muted;
+		t->sco.mic_muted = req->ch2_muted;
+		t->sco.spk_gain = req->ch1_volume;
+		t->sco.mic_gain = req->ch2_volume;
+
+		if (t->sco.rfcomm != NULL)
+			/* notify associated RFCOMM transport */
+			transport_send_signal(t->sco.rfcomm, TRANSPORT_SET_VOLUME);
+
+		break;
 	}
 
-	transport_set_volume(t, req->ch1_muted, req->ch2_muted, req->ch1_volume, req->ch2_volume);
+	/* notify connected clients (including requester) */
+	bluealsa_ctl_send_event(BA_EVENT_VOLUME_CHANGED, &req->addr, req->type);
 
 fail:
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -340,22 +328,27 @@ static void ctl_thread_cmd_pcm_open(const struct ba_request *req, int fd) {
 	struct ba_pcm *t_pcm;
 	int pipefd[2];
 
-	debug("PCM requested for %s type %d stream %d", batostr_(&req->addr), req->type, req->stream);
+	debug("PCM requested for %s type %#x", batostr_(&req->addr), req->type);
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
-	if (_transport_lookup(config.devices, &req->addr, req->type, req->stream, &t) != 0) {
+	switch (ctl_lookup_transport(config.devices, &req->addr, req->type, &t)) {
+	case -1:
 		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
-		goto final;
+		goto fail_lookup;
+	case -2:
+		status.code = BA_STATUS_CODE_STREAM_NOT_FOUND;
+		goto fail_lookup;
 	}
 
-	if ((t_pcm = _transport_get_pcm(t, req->stream)) == NULL) {
-		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
+	pthread_mutex_lock(&t->mutex);
+
+	if (t->type == TRANSPORT_TYPE_SCO && t->codec == HFP_CODEC_UNDEFINED) {
+		status.code = BA_STATUS_CODE_CODEC_NOT_SELECTED;
 		goto final;
 	}
 
-	if (t_pcm->fd != -1) {
-		debug("PCM already requested: %d", t_pcm->fd);
+	if ((t_pcm = ctl_lookup_pcm(t, req->type, -1)) == NULL) {
 		status.code = BA_STATUS_CODE_DEVICE_BUSY;
 		goto final;
 	}
@@ -384,25 +377,23 @@ static void ctl_thread_cmd_pcm_open(const struct ba_request *req, int fd) {
 	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
 	int *fdptr = (int *)CMSG_DATA(cmsg);
 
-	switch (req->stream) {
-	case BA_PCM_STREAM_PLAYBACK:
+	if (req->type & BA_PCM_STREAM_PLAYBACK) {
 		t_pcm->fd = pipefd[0];
 		*fdptr = pipefd[1];
-		break;
-	case BA_PCM_STREAM_CAPTURE:
+	}
+	else {
 		t_pcm->fd = pipefd[1];
 		*fdptr = pipefd[0];
-		break;
-	case BA_PCM_STREAM_DUPLEX:
-		debug("Invalid PCM stream type: %d", req->stream);
+	}
+
+	/* Set our internal FIFO endpoint as non-blocking. */
+	if (fcntl(t_pcm->fd, F_SETFL, O_NONBLOCK) == -1) {
 		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
 		goto fail;
 	}
 
-	/* XXX: This change will notify our sink (and SCO) IO thread, that the FIFO
-	 *      has just been created. Source IO thread should not be started before
-	 *      the PCM open request has been made, so this "notification" mechanism
-	 *      does not apply. */
+	/* Notify our IO thread, that the FIFO has just been created - it may be
+	 * used for poll() right away. */
 	transport_send_signal(t, TRANSPORT_PCM_OPEN);
 
 	/* A2DP source profile should be initialized (acquired) only if the audio
@@ -410,13 +401,15 @@ static void ctl_thread_cmd_pcm_open(const struct ba_request *req, int fd) {
 	 * run voltage converter (power-on its circuit board) until the transport
 	 * is acquired - in order to extend battery life. */
 	if (t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE)
-		if (transport_acquire_bt_a2dp(t) == -1) {
+		if (t->acquire(t) == -1) {
 			status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
 			goto fail;
 		}
 
-	if (sendmsg(fd, &msg, 0) == -1)
+	if (sendmsg(fd, &msg, 0) == -1) {
+		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
 		goto fail;
+	}
 
 	t_pcm->client = fd;
 	close(*fdptr);
@@ -428,38 +421,9 @@ fail:
 	t_pcm->fd = -1;
 
 final:
-	pthread_mutex_unlock(&config.devices_mutex);
-	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
-}
-
-static void ctl_thread_cmd_pcm_close(const struct ba_request *req, int fd) {
-
-	struct ba_msg_status status = { BA_STATUS_CODE_SUCCESS };
-	struct ba_transport *t;
-	struct ba_pcm *t_pcm;
-
-	debug("PCM close for %s type %d stream %d", batostr_(&req->addr), req->type, req->stream);
-
-	pthread_mutex_lock(&config.devices_mutex);
-
-	if (_transport_lookup(config.devices, &req->addr, req->type, req->stream, &t) != 0) {
-		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
-		goto fail;
-	}
-	if ((t_pcm = _transport_get_pcm(t, req->stream)) == NULL) {
-		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
-		goto fail;
-	}
-	if (t_pcm->client != fd) {
-		status.code = BA_STATUS_CODE_FORBIDDEN;
-		goto fail;
-	}
-
-	_transport_release(t, fd);
-	transport_send_signal(t, TRANSPORT_PCM_CLOSE);
-
-fail:
-	pthread_mutex_unlock(&config.devices_mutex);
+	pthread_mutex_unlock(&t->mutex);
+fail_lookup:
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -469,21 +433,17 @@ static void ctl_thread_cmd_pcm_control(const struct ba_request *req, int fd) {
 	struct ba_transport *t;
 	struct ba_pcm *t_pcm;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
-	if (_transport_lookup(config.devices, &req->addr, req->type, req->stream, &t) != 0) {
+	switch (ctl_lookup_transport(config.devices, &req->addr, req->type, &t)) {
+	case -1:
 		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
 		goto fail;
-	}
-	if ((t_pcm = _transport_get_pcm(t, req->stream)) == NULL) {
-		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
+	case -2:
+		status.code = BA_STATUS_CODE_STREAM_NOT_FOUND;
 		goto fail;
 	}
-	if (t_pcm->fd == -1 || t_pcm->client == -1) {
-		status.code = BA_STATUS_CODE_ERROR_UNKNOWN;
-		goto fail;
-	}
-	if (t_pcm->client != fd) {
+	if ((t_pcm = ctl_lookup_pcm(t, req->type, fd)) == NULL) {
 		status.code = BA_STATUS_CODE_FORBIDDEN;
 		goto fail;
 	}
@@ -500,12 +460,15 @@ static void ctl_thread_cmd_pcm_control(const struct ba_request *req, int fd) {
 	case BA_COMMAND_PCM_DRAIN:
 		transport_drain_pcm(t);
 		break;
+	case BA_COMMAND_PCM_DROP:
+		transport_send_signal(t, TRANSPORT_PCM_DROP);
+		break;
 	default:
 		warn("Invalid PCM control command: %d", req->command);
 	}
 
 fail:
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -514,17 +477,21 @@ static void ctl_thread_cmd_rfcomm_send(const struct ba_request *req, int fd) {
 	struct ba_msg_status status = { BA_STATUS_CODE_SUCCESS };
 	struct ba_transport *t;
 
-	pthread_mutex_lock(&config.devices_mutex);
+	bluealsa_devpool_mutex_lock();
 
-	if (_transport_lookup_rfcomm(config.devices, &req->addr, &t) != 0) {
+	switch (ctl_lookup_transport(config.devices, &req->addr, BA_PCM_TYPE_RFCOMM, &t)) {
+	case -1:
 		status.code = BA_STATUS_CODE_DEVICE_NOT_FOUND;
 		goto fail;
+	case -2:
+		status.code = BA_STATUS_CODE_STREAM_NOT_FOUND;
+		goto fail;
 	}
 
 	transport_send_rfcomm(t, req->rfcomm_command);
 
 fail:
-	pthread_mutex_unlock(&config.devices_mutex);
+	bluealsa_devpool_mutex_unlock();
 	send(fd, &status, sizeof(status), MSG_NOSIGNAL);
 }
 
@@ -539,38 +506,30 @@ static void *ctl_thread(void *arg) {
 		[BA_COMMAND_TRANSPORT_GET] = ctl_thread_cmd_transport_get,
 		[BA_COMMAND_TRANSPORT_SET_VOLUME] = ctl_thread_cmd_transport_set_volume,
 		[BA_COMMAND_PCM_OPEN] = ctl_thread_cmd_pcm_open,
-		[BA_COMMAND_PCM_CLOSE] = ctl_thread_cmd_pcm_close,
 		[BA_COMMAND_PCM_PAUSE] = ctl_thread_cmd_pcm_control,
 		[BA_COMMAND_PCM_RESUME] = ctl_thread_cmd_pcm_control,
 		[BA_COMMAND_PCM_DRAIN] = ctl_thread_cmd_pcm_control,
+		[BA_COMMAND_PCM_DROP] = ctl_thread_cmd_pcm_control,
 		[BA_COMMAND_RFCOMM_SEND] = ctl_thread_cmd_rfcomm_send,
 	};
 
 	debug("Starting controller loop");
 	while (config.ctl.thread_created) {
 
-		if (poll(config.ctl.pfds, ARRAYSIZE(config.ctl.pfds), -1) == -1) {
+		if (poll((struct pollfd *)config.ctl.pfds->data, config.ctl.pfds->len, -1) == -1) {
+			if (errno == EINTR)
+				continue;
 			error("Controller poll error: %s", strerror(errno));
 			break;
 		}
 
-		/* Clients handling loop will update this variable to point to the
-		 * first available client structure, which might be later used by
-		 * the connection handling loop. */
-		struct pollfd *pfd = NULL;
 		size_t i;
 
 		/* handle data transmission with connected clients */
-		for (i = __CTL_IDX_MAX; i < __CTL_IDX_MAX + BLUEALSA_MAX_CLIENTS; i++) {
-			const int fd = config.ctl.pfds[i].fd;
-
-			if (fd == -1) {
-				pfd = &config.ctl.pfds[i];
-				continue;
-			}
-
-			if (config.ctl.pfds[i].revents & POLLIN) {
+		for (i = __CTL_IDX_MAX; i < config.ctl.pfds->len; i++)
+			if (ctl_pfds_idx(i).revents & POLLIN) {
 
+				const int fd = ctl_pfds_idx(i).fd;
 				struct ba_request request;
 				ssize_t len;
 
@@ -582,14 +541,42 @@ static void *ctl_thread(void *arg) {
 					else
 						debug("Invalid request length: %zd != %zd", len, sizeof(request));
 
+					GHashTableIter iter_d, iter_t;
+					struct ba_device *d;
 					struct ba_transport *t;
-					if ((t = transport_lookup_pcm_client(config.devices, fd)) != NULL) {
-						_transport_release(t, fd);
-						transport_send_signal(t, TRANSPORT_PCM_CLOSE);
+
+					bluealsa_devpool_mutex_lock();
+
+					/* release PCMs associated with disconnected client */
+					g_hash_table_iter_init(&iter_d, config.devices);
+					while (g_hash_table_iter_next(&iter_d, NULL, (gpointer)&d)) {
+						g_hash_table_iter_init(&iter_t, d->transports);
+						while (g_hash_table_iter_next(&iter_t, NULL, (gpointer)&t))
+							switch (t->type) {
+							case TRANSPORT_TYPE_RFCOMM:
+								continue;
+							case TRANSPORT_TYPE_A2DP:
+								if (t->a2dp.pcm.client == fd) {
+									transport_release_pcm(&t->a2dp.pcm);
+									transport_send_signal(t, TRANSPORT_PCM_CLOSE);
+								}
+								continue;
+							case TRANSPORT_TYPE_SCO:
+								if (t->sco.spk_pcm.client == fd) {
+									transport_release_pcm(&t->sco.spk_pcm);
+									transport_send_signal(t, TRANSPORT_PCM_CLOSE);
+								}
+								if (t->sco.mic_pcm.client == fd) {
+									transport_release_pcm(&t->sco.mic_pcm);
+									transport_send_signal(t, TRANSPORT_PCM_CLOSE);
+								}
+							}
 					}
 
-					config.ctl.pfds[i].fd = -1;
-					config.ctl.subs[i - __CTL_IDX_MAX] = 0;
+					bluealsa_devpool_mutex_unlock();
+
+					g_array_remove_index_fast(config.ctl.pfds, i);
+					g_array_remove_index_fast(config.ctl.subs, i - __CTL_IDX_MAX);
 					close(fd);
 					continue;
 				}
@@ -602,15 +589,13 @@ static void *ctl_thread(void *arg) {
 
 			}
 
-		}
-
 		/* process new connections to our controller */
-		if (config.ctl.pfds[CTL_IDX_SRV].revents & POLLIN && pfd != NULL) {
+		if (ctl_pfds_idx(CTL_IDX_SRV).revents & POLLIN) {
 
 			struct pollfd fd = { -1, POLLIN, 0 };
 			uint16_t ver = 0;
 
-			fd.fd = accept(config.ctl.pfds[CTL_IDX_SRV].fd, NULL, NULL);
+			fd.fd = accept(ctl_pfds_idx(CTL_IDX_SRV).fd, NULL, NULL);
 			debug("Received new connection: %d", fd.fd);
 
 			errno = ETIMEDOUT;
@@ -625,25 +610,26 @@ static void *ctl_thread(void *arg) {
 			}
 			else {
 				debug("New client accepted: %d", fd.fd);
-				pfd->fd = fd.fd;
+				g_array_append_val(config.ctl.pfds, fd);
+				g_array_set_size(config.ctl.subs, config.ctl.subs->len + 1);
 			}
 
 		}
 
 		/* generate notifications for subscribed clients */
-		if (config.ctl.pfds[CTL_IDX_EVT].revents & POLLIN) {
+		if (ctl_pfds_idx(CTL_IDX_EVT).revents & POLLIN) {
 
-			struct ba_msg_event event = { 0 };
+			struct ba_msg_event ev;
 			size_t i;
 
-			if (read(config.ctl.pfds[CTL_IDX_EVT].fd, &event.mask, sizeof(event.mask)) == -1)
+			if (read(ctl_pfds_idx(CTL_IDX_EVT).fd, &ev, sizeof(ev)) == -1)
 				warn("Couldn't read controller event: %s", strerror(errno));
 
-			for (i = 0; i < BLUEALSA_MAX_CLIENTS; i++)
-				if (config.ctl.subs[i] & event.mask) {
-					const int client = config.ctl.pfds[i + __CTL_IDX_MAX].fd;
-					debug("Emitting notification: %B => %d", event.mask, client);
-					send(client, &event, sizeof(event), MSG_NOSIGNAL);
+			for (i = 0; i < config.ctl.subs->len; i++)
+				if (ctl_subs_idx(i) & ev.events) {
+					const int client = ctl_pfds_idx(i + __CTL_IDX_MAX).fd;
+					debug("Sending notification: %B => %d", ev.events, client);
+					send(client, &ev, sizeof(ev), MSG_NOSIGNAL);
 				}
 
 		}
@@ -663,38 +649,46 @@ int bluealsa_ctl_thread_init(void) {
 		return -1;
 	}
 
-	{ /* initialize (mark as closed) all sockets */
-		size_t i;
-		for (i = 0; i < ARRAYSIZE(config.ctl.pfds); i++) {
-			config.ctl.pfds[i].events = POLLIN;
-			config.ctl.pfds[i].fd = -1;
-		}
-	}
+	struct pollfd pfd = { .events = POLLIN };
 
 	struct sockaddr_un saddr = { .sun_family = AF_UNIX };
 	snprintf(saddr.sun_path, sizeof(saddr.sun_path) - 1,
 			BLUEALSA_RUN_STATE_DIR "/%s", config.hci_dev.name);
 
-	if (mkdir(BLUEALSA_RUN_STATE_DIR, 0755) == -1 && errno != EEXIST)
+	if (mkdir(BLUEALSA_RUN_STATE_DIR, 0755) == -1 && errno != EEXIST) {
+		error("Couldn't create run-state directory: %s", strerror(errno));
 		goto fail;
-	if ((config.ctl.pfds[CTL_IDX_SRV].fd = socket(PF_UNIX, SOCK_SEQPACKET, 0)) == -1)
+	}
+
+	if ((pfd.fd = socket(PF_UNIX, SOCK_SEQPACKET, 0)) == -1) {
+		error("Couldn't create controller socket: %s", strerror(errno));
 		goto fail;
-	if (bind(config.ctl.pfds[CTL_IDX_SRV].fd, (struct sockaddr *)(&saddr), sizeof(saddr)) == -1)
+	}
+	g_array_append_val(config.ctl.pfds, pfd);
+	if (bind(pfd.fd, (struct sockaddr *)(&saddr), sizeof(saddr)) == -1) {
+		error("Couldn't bind controller socket: %s", strerror(errno));
 		goto fail;
+	}
 	config.ctl.socket_created = true;
-	if (chmod(saddr.sun_path, 0660) == -1)
-		goto fail;
-	if (chown(saddr.sun_path, -1, config.gid_audio) == -1)
-		goto fail;
-	if (listen(config.ctl.pfds[CTL_IDX_SRV].fd, 2) == -1)
+	if (chmod(saddr.sun_path, 0660) == -1 ||
+			chown(saddr.sun_path, -1, config.gid_audio) == -1)
+		warn("Couldn't set permission for controller socket: %s", strerror(errno));
+	if (listen(pfd.fd, 2) == -1) {
+		error("Couldn't listen on controller socket: %s", strerror(errno));
 		goto fail;
+	}
 
-	if (pipe(config.ctl.evt) == -1)
+	if (pipe(config.ctl.evt) == -1) {
+		error("Couldn't create controller event PIPE: %s", strerror(errno));
 		goto fail;
-	config.ctl.pfds[CTL_IDX_EVT].fd = config.ctl.evt[0];
+	}
+
+	pfd.fd = config.ctl.evt[0];
+	g_array_append_val(config.ctl.pfds, pfd);
 
 	config.ctl.thread_created = true;
 	if ((errno = pthread_create(&config.ctl.thread, NULL, ctl_thread, NULL)) != 0) {
+		error("Couldn't create controller thread: %s", strerror(errno));
 		config.ctl.thread_created = false;
 		goto fail;
 	}
@@ -716,13 +710,10 @@ void bluealsa_ctl_free(void) {
 
 	config.ctl.thread_created = false;
 
-	close(config.ctl.evt[0]);
-	close(config.ctl.evt[1]);
-	config.ctl.pfds[CTL_IDX_EVT].fd = -1;
-
-	for (i = 0; i < ARRAYSIZE(config.ctl.pfds); i++)
-		if (config.ctl.pfds[i].fd != -1)
-			close(config.ctl.pfds[i].fd);
+	for (i = 0; i < config.ctl.pfds->len; i++)
+		close(ctl_pfds_idx(i).fd);
+	if (config.ctl.evt[1] != -1)
+		close(config.ctl.evt[1]);
 
 	if (created) {
 		pthread_cancel(config.ctl.thread);
@@ -738,6 +729,9 @@ void bluealsa_ctl_free(void) {
 
 }
 
-int bluealsa_ctl_event(enum ba_event event) {
-	return write(config.ctl.evt[1], &event, sizeof(event));
+/**
+ * Send notification event to subscribed clients. */
+int bluealsa_ctl_send_event(enum ba_event event, const bdaddr_t *addr, uint8_t type) {
+	struct ba_msg_event ev = { .events = event, .addr = *addr, .type = type };
+	return write(config.ctl.evt[1], &ev, sizeof(ev));
 }
diff --git a/src/ctl.h b/src/ctl.h
index 5fd92ed..0e3c46b 100644
--- a/src/ctl.h
+++ b/src/ctl.h
@@ -13,9 +13,14 @@
 
 #include "shared/ctl-proto.h"
 
+/* Indexes of special file descriptors in the poll array. */
+#define CTL_IDX_SRV 0
+#define CTL_IDX_EVT 1
+#define __CTL_IDX_MAX 2
+
 int bluealsa_ctl_thread_init(void);
 void bluealsa_ctl_free(void);
 
-int bluealsa_ctl_event(enum ba_event event);
+int bluealsa_ctl_send_event(enum ba_event event, const bdaddr_t *addr, uint8_t type);
 
 #endif
diff --git a/src/io.c b/src/io.c
index 8e2b3b4..5e8b44f 100644
--- a/src/io.c
+++ b/src/io.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - io.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -10,6 +10,7 @@
 
 #include "io.h"
 
+#include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <math.h>
@@ -19,6 +20,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 
@@ -32,6 +34,10 @@
 #if ENABLE_APTX
 # include <openaptx.h>
 #endif
+#if ENABLE_LDAC
+# include <ldacBT.h>
+# include <ldacBT_abr.h>
+#endif
 
 #include "a2dp-codecs.h"
 #include "a2dp-rtp.h"
@@ -46,21 +52,16 @@
 
 /**
  * Scale PCM signal according to the transport audio properties. */
-static void io_thread_scale_pcm(struct ba_transport *t, int16_t *buffer,
+static void io_thread_scale_pcm(const struct ba_transport *t, int16_t *buffer,
 		size_t samples, int channels) {
 
-	/* Get a snapshot of audio properties. Please note, that mutex is not
-	 * required here, because we are not modifying these variables. */
-	uint8_t ch1_volume = t->a2dp.ch1_volume;
-	uint8_t ch2_volume = t->a2dp.ch2_volume;
-
 	double ch1_scale = 0;
 	double ch2_scale = 0;
 
 	if (!t->a2dp.ch1_muted)
-		ch1_scale = pow(10, (-64 + 64.0 * ch1_volume / 127 ) / 20);
+		ch1_scale = pow(10, (-64 + 64.0 * t->a2dp.ch1_volume / 127) / 20);
 	if (!t->a2dp.ch2_muted)
-		ch2_scale = pow(10, (-64 + 64.0 * ch2_volume / 127 ) / 20);
+		ch2_scale = pow(10, (-64 + 64.0 * t->a2dp.ch2_volume / 127) / 20);
 
 	snd_pcm_scale_s16le(buffer, samples, channels, ch1_scale, ch2_scale);
 }
@@ -76,14 +77,15 @@ static ssize_t io_thread_read_pcm(struct ba_pcm *pcm, int16_t *buffer, size_t sa
 	 * closed during this call, we will still read correct data, because Linux
 	 * kernel does not decrement file descriptor reference counter until the
 	 * read returns. */
-	while ((ret = read(pcm->fd, buffer, samples * sizeof(int16_t))) == -1 && errno == EINTR)
+	while ((ret = read(pcm->fd, buffer, samples * sizeof(int16_t))) == -1 &&
+			errno == EINTR)
 		continue;
 
 	if (ret > 0)
 		return ret / sizeof(int16_t);
 
 	if (ret == 0)
-		debug("FIFO endpoint has been closed: %d", pcm->fd);
+		debug("PCM has been closed: %d", pcm->fd);
 	if (errno == EBADF)
 		ret = 0;
 	if (ret == 0)
@@ -92,22 +94,37 @@ static ssize_t io_thread_read_pcm(struct ba_pcm *pcm, int16_t *buffer, size_t sa
 	return ret;
 }
 
+/**
+ * Flush read buffer of the transport PCM FIFO. */
+static ssize_t io_thread_read_pcm_flush(struct ba_pcm *pcm) {
+	ssize_t rv = splice(pcm->fd, NULL, config.null_fd, NULL, 1024 * 32, SPLICE_F_NONBLOCK);
+	if (rv == -1 && errno == EAGAIN)
+		rv = 0;
+	debug("PCM read buffer flushed: %zd", rv >= 0 ? (int)(rv / sizeof(int16_t)) : rv);
+	return rv;
+}
+
 /**
  * Write PCM signal to the transport PCM FIFO. */
 static ssize_t io_thread_write_pcm(struct ba_pcm *pcm, const int16_t *buffer, size_t samples) {
 
+	struct pollfd pfd = { pcm->fd, POLLOUT, 0 };
 	const uint8_t *head = (uint8_t *)buffer;
 	size_t len = samples * sizeof(int16_t);
 	ssize_t ret;
 
 	do {
 		if ((ret = write(pcm->fd, head, len)) == -1) {
-			if (errno == EINTR)
+			switch (errno) {
+			case EINTR:
 				continue;
-			if (errno == EPIPE) {
+			case EAGAIN:
+				poll(&pfd, 1, -1);
+				continue;
+			case EPIPE:
 				/* This errno value will be received only, when the SIGPIPE
 				 * signal is caught, blocked or ignored. */
-				debug("FIFO endpoint has been closed: %d", pcm->fd);
+				debug("PCM has been closed: %d", pcm->fd);
 				transport_release_pcm(pcm);
 				return 0;
 			}
@@ -123,18 +140,26 @@ static ssize_t io_thread_write_pcm(struct ba_pcm *pcm, const int16_t *buffer, si
 
 /**
  * Write data to the BT SEQPACKET socket. */
-static ssize_t io_thread_write_bt(int fd, const uint8_t *buffer, size_t len) {
+static ssize_t io_thread_write_bt(const struct ba_transport *t,
+		const uint8_t *buffer, size_t len, int *coutq) {
 
-	struct pollfd pfds[] = {{ fd, POLLOUT, 0 }};
+	struct pollfd pfd = { t->bt_fd, POLLOUT, 0 };
 	ssize_t ret;
 
+	if (ioctl(pfd.fd, TIOCOUTQ, coutq) == -1)
+		warn("Couldn't get BT queued bytes: %s", strerror(errno));
+	else
+		*coutq = abs(t->a2dp.bt_fd_coutq_init - *coutq);
+
 retry:
-	if ((ret = write(fd, buffer, len)) == -1)
+	if ((ret = write(pfd.fd, buffer, len)) == -1)
 		switch (errno) {
 		case EINTR:
 			goto retry;
 		case EAGAIN:
-			poll(pfds, ARRAYSIZE(pfds), -1);
+			poll(&pfd, 1, -1);
+			/* set coutq to some arbitrary big value */
+			*coutq = 1024 * 16;
 			goto retry;
 		}
 
@@ -178,6 +203,11 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
+	/* Lock transport during initialization stage. This lock will ensure,
+	 * that no one will modify critical section until thread state can be
+	 * known - initialization has failed or succeeded. */
+	bool locked = !transport_pthread_cleanup_lock(t);
+
 	if (t->bt_fd == -1) {
 		error("Invalid BT socket: %d", t->bt_fd);
 		goto fail_init;
@@ -203,8 +233,6 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 
 	ffb_uint8_t bt = { 0 };
 	ffb_int16_t pcm = { 0 };
-	uint16_t seq_number = -1;
-
 	pthread_cleanup_push(PTHREAD_CLEANUP(sbc_finish), &sbc);
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt);
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_int16_free), &pcm);
@@ -212,14 +240,23 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 	if (ffb_init(&pcm, sbc_get_codesize(&sbc)) == NULL ||
 			ffb_init(&bt, t->mtu_read) == NULL) {
 		error("Couldn't create data buffers: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
+	/* Lock transport during thread cancellation. This handler shall be at
+	 * the top of the cleanup stack - lastly pushed. */
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
+	uint16_t seq_number = -1;
+
 	struct pollfd pfds[] = {
 		{ t->sig_fd[0], POLLIN, 0 },
 		{ -1, POLLIN, 0 },
 	};
 
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
 	debug("Starting IO loop: %s (%s)",
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
@@ -232,6 +269,8 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 		pfds[1].fd = t->state == TRANSPORT_ACTIVE ? t->bt_fd : -1;
 
 		if (poll(pfds, ARRAYSIZE(pfds), -1) == -1) {
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -312,6 +351,8 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 
 fail:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
@@ -326,6 +367,8 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
+	bool locked = !transport_pthread_cleanup_lock(t);
+
 	sbc_t sbc;
 
 	if ((errno = -sbc_init_a2dp(&sbc, 0, t->a2dp.cconfig, t->a2dp.cconfig_size)) != 0) {
@@ -357,9 +400,11 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 	if (ffb_init(&pcm, sbc_pcm_samples * (mtu_write_payload / sbc_frame_len)) == NULL ||
 			ffb_init(&bt, t->mtu_write) == NULL) {
 		error("Couldn't create data buffers: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
 	rtp_header_t *rtp_header;
 	rtp_media_header_t *rtp_media_header;
 
@@ -368,6 +413,10 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 	uint16_t seq_number = ntohs(rtp_header->seq_number);
 	uint32_t timestamp = ntohl(rtp_header->timestamp);
 
+	/* array with historical data of queued bytes for BT socket */
+	int coutq_history[IO_THREAD_COUTQ_HISTORY_SIZE] = { 0 };
+	size_t coutq_i = 0;
+
 	int poll_timeout = -1;
 	struct asrsync asrs = { .frames = 0 };
 	struct pollfd pfds[] = {
@@ -375,6 +424,9 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 		{ -1, POLLIN, 0 },
 	};
 
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
 	debug("Starting IO loop: %s (%s)",
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
@@ -388,10 +440,17 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 
 		switch (poll(pfds, ARRAYSIZE(pfds), poll_timeout)) {
 		case 0:
-			pthread_cond_signal(&t->a2dp.pcm.drained);
+			pthread_cond_signal(&t->a2dp.drained);
 			poll_timeout = -1;
+			locked = !transport_pthread_cleanup_lock(t);
+			if (t->a2dp.pcm.fd == -1)
+				goto final;
+			transport_pthread_cleanup_unlock(t);
+			locked = false;
 			continue;
 		case -1:
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -402,22 +461,34 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 			if (read(pfds[0].fd, &sig, sizeof(sig)) != sizeof(sig))
 				warn("Couldn't read signal: %s", strerror(errno));
 			switch (sig) {
+			case TRANSPORT_PCM_OPEN:
 			case TRANSPORT_PCM_RESUME:
+				poll_timeout = -1;
 				asrs.frames = 0;
+				continue;
+			case TRANSPORT_PCM_CLOSE:
+				/* reuse PCM read disconnection logic */
 				break;
 			case TRANSPORT_PCM_SYNC:
 				poll_timeout = 100;
-				break;
+				continue;
+			case TRANSPORT_PCM_DROP:
+				io_thread_read_pcm_flush(&t->a2dp.pcm);
+				continue;
 			default:
-				break;
+				continue;
 			}
-			continue;
 		}
 
-		/* read data from the FIFO - this function will block */
-		if ((samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) <= 0) {
-			if (samples == -1)
-				error("FIFO read error: %s", strerror(errno));
+		switch (samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) {
+		case 0:
+			poll_timeout = config.a2dp.keep_alive * 1000;
+			debug("Keep-alive polling: %d", poll_timeout);
+			continue;
+		case -1:
+			if (errno == EAGAIN)
+				continue;
+			error("PCM read error: %s", strerror(errno));
 			goto fail;
 		}
 
@@ -428,7 +499,7 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 		 * In order to correctly calculate time drift, the zero time point has to
 		 * be obtained after the stream has started. */
 		if (asrs.frames == 0)
-			asrsync_init(asrs, samplerate);
+			asrsync_init(&asrs, samplerate);
 
 		if (!config.a2dp.volume)
 			/* scale volume or mute audio signal */
@@ -477,7 +548,8 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 
 		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
 
-		if (io_thread_write_bt(t->bt_fd, bt.data, ffb_len_out(&bt)) == -1) {
+		coutq_i = (coutq_i + 1) % ARRAYSIZE(coutq_history);
+		if (io_thread_write_bt(t, bt.data, ffb_len_out(&bt), &coutq_history[coutq_i]) == -1) {
 			if (errno == ECONNRESET || errno == ENOTCONN) {
 				/* exit thread upon BT socket disconnection */
 				debug("BT socket disconnected: %d", t->bt_fd);
@@ -492,7 +564,9 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 		 * get a timestamp for the next RTP frame */
 		asrsync_sync(&asrs, pcm_frames);
 		timestamp += pcm_frames * 10000 / samplerate;
-		t->delay = asrs.ts_busy.tv_nsec / 100000;
+
+		/* update busy delay (encoding overhead) */
+		t->delay = asrsync_get_busy_usec(&asrs) / 100;
 
 		/* If the input buffer was not consumed (due to codesize limit), we
 		 * have to append new data to the existing one. Since we do not use
@@ -503,7 +577,10 @@ void *io_thread_a2dp_source_sbc(void *arg) {
 	}
 
 fail:
+final:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
@@ -519,6 +596,8 @@ void *io_thread_a2dp_sink_aac(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
+	bool locked = !transport_pthread_cleanup_lock(t);
+
 	if (t->bt_fd == -1) {
 		error("Invalid BT socket: %d", t->bt_fd);
 		goto fail_open;
@@ -558,9 +637,6 @@ void *io_thread_a2dp_sink_aac(void *arg) {
 	ffb_uint8_t bt = { 0 };
 	ffb_uint8_t latm = { 0 };
 	ffb_int16_t pcm = { 0 };
-	uint16_t seq_number = -1;
-	int markbit_quirk = -3;
-
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt);
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &latm);
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_int16_free), &pcm);
@@ -569,14 +645,22 @@ void *io_thread_a2dp_sink_aac(void *arg) {
 			ffb_init(&latm, t->mtu_read) == NULL ||
 			ffb_init(&bt, t->mtu_read) == NULL) {
 		error("Couldn't create data buffers: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
+	uint16_t seq_number = -1;
+	int markbit_quirk = -3;
+
 	struct pollfd pfds[] = {
 		{ t->sig_fd[0], POLLIN, 0 },
 		{ -1, POLLIN, 0 },
 	};
 
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
 	debug("Starting IO loop: %s (%s)",
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
@@ -590,6 +674,8 @@ void *io_thread_a2dp_sink_aac(void *arg) {
 		pfds[1].fd = t->state == TRANSPORT_ACTIVE ? t->bt_fd : -1;
 
 		if (poll(pfds, ARRAYSIZE(pfds), -1) == -1) {
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -690,6 +776,8 @@ void *io_thread_a2dp_sink_aac(void *arg) {
 
 fail:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
@@ -709,6 +797,8 @@ void *io_thread_a2dp_source_aac(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
+	bool locked = !transport_pthread_cleanup_lock(t);
+
 	HANDLE_AACENCODER handle;
 	AACENC_InfoStruct aacinf;
 	AACENC_ERROR err;
@@ -788,55 +878,53 @@ void *io_thread_a2dp_source_aac(void *arg) {
 		goto fail_init;
 	}
 
-	int in_buffer_identifier = IN_AUDIO_DATA;
-	int out_buffer_identifier = OUT_BITSTREAM_DATA;
-	int in_buffer_element_size = sizeof(int16_t);
-	int out_buffer_element_size = 1;
-	int16_t *in_buffer, *in_buffer_tail;
-	uint8_t *out_buffer, *out_payload;
-	int in_buffer_size;
-	int out_payload_size;
-
-	AACENC_BufDesc in_buf = {
-		.numBufs = 1,
-		.bufs = (void **)&in_buffer_tail,
-		.bufferIdentifiers = &in_buffer_identifier,
-		.bufSizes = &in_buffer_size,
-		.bufElSizes = &in_buffer_element_size,
-	};
-	AACENC_BufDesc out_buf = {
-		.numBufs = 1,
-		.bufs = (void **)&out_payload,
-		.bufferIdentifiers = &out_buffer_identifier,
-		.bufSizes = &out_payload_size,
-		.bufElSizes = &out_buffer_element_size,
-	};
-	AACENC_InArgs in_args = { 0 };
-	AACENC_OutArgs out_args = { 0 };
-
-	in_buffer_size = in_buffer_element_size * aacinf.inputChannels * aacinf.frameLength;
-	out_payload_size = aacinf.maxOutBufBytes;
-	in_buffer = malloc(in_buffer_size);
-	out_buffer = malloc(RTP_HEADER_LEN + out_payload_size);
-
-	pthread_cleanup_push(PTHREAD_CLEANUP(free), in_buffer);
-	pthread_cleanup_push(PTHREAD_CLEANUP(free), out_buffer);
+	ffb_uint8_t bt = { 0 };
+	ffb_int16_t pcm = { 0 };
+	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt);
+	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_int16_free), &pcm);
 
-	if (in_buffer == NULL || out_buffer == NULL) {
+	if (ffb_init(&pcm, aacinf.inputChannels * aacinf.frameLength) == NULL ||
+			ffb_init(&bt, RTP_HEADER_LEN + aacinf.maxOutBufBytes) == NULL) {
 		error("Couldn't create data buffers: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
 	rtp_header_t *rtp_header;
 
 	/* initialize RTP header and get anchor for payload */
-	out_payload = io_thread_init_rtp(out_buffer, &rtp_header, NULL);
+	uint8_t *rtp_payload = io_thread_init_rtp(bt.data, &rtp_header, NULL);
 	uint16_t seq_number = ntohs(rtp_header->seq_number);
 	uint32_t timestamp = ntohl(rtp_header->timestamp);
 
-	/* initial input buffer tail and the available capacity */
-	size_t in_samples = in_buffer_size / in_buffer_element_size;
-	in_buffer_tail = in_buffer;
+	int in_bufferIdentifiers[] = { IN_AUDIO_DATA };
+	int out_bufferIdentifiers[] = { OUT_BITSTREAM_DATA };
+	int in_bufSizes[] = { pcm.size * sizeof(*pcm.data) };
+	int out_bufSizes[] = { aacinf.maxOutBufBytes };
+	int in_bufElSizes[] = { sizeof(*pcm.data) };
+	int out_bufElSizes[] = { sizeof(*bt.data) };
+
+	AACENC_BufDesc in_buf = {
+		.numBufs = 1,
+		.bufs = (void **)&pcm.data,
+		.bufferIdentifiers = in_bufferIdentifiers,
+		.bufSizes = in_bufSizes,
+		.bufElSizes = in_bufElSizes,
+	};
+	AACENC_BufDesc out_buf = {
+		.numBufs = 1,
+		.bufs = (void **)&rtp_payload,
+		.bufferIdentifiers = out_bufferIdentifiers,
+		.bufSizes = out_bufSizes,
+		.bufElSizes = out_bufElSizes,
+	};
+	AACENC_InArgs in_args = { 0 };
+	AACENC_OutArgs out_args = { 0 };
+
+	/* array with historical data of queued bytes for BT socket */
+	int coutq_history[IO_THREAD_COUTQ_HISTORY_SIZE] = { 0 };
+	size_t coutq_i = 0;
 
 	int poll_timeout = -1;
 	struct asrsync asrs = { .frames = 0 };
@@ -845,6 +933,9 @@ void *io_thread_a2dp_source_aac(void *arg) {
 		{ -1, POLLIN, 0 },
 	};
 
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
 	debug("Starting IO loop: %s (%s)",
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
@@ -858,10 +949,17 @@ void *io_thread_a2dp_source_aac(void *arg) {
 
 		switch (poll(pfds, ARRAYSIZE(pfds), poll_timeout)) {
 		case 0:
-			pthread_cond_signal(&t->a2dp.pcm.drained);
+			pthread_cond_signal(&t->a2dp.drained);
 			poll_timeout = -1;
+			locked = !transport_pthread_cleanup_lock(t);
+			if (t->a2dp.pcm.fd == -1)
+				goto final;
+			transport_pthread_cleanup_unlock(t);
+			locked = false;
 			continue;
 		case -1:
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -872,40 +970,50 @@ void *io_thread_a2dp_source_aac(void *arg) {
 			if (read(pfds[0].fd, &sig, sizeof(sig)) != sizeof(sig))
 				warn("Couldn't read signal: %s", strerror(errno));
 			switch (sig) {
+			case TRANSPORT_PCM_OPEN:
 			case TRANSPORT_PCM_RESUME:
+				poll_timeout = -1;
 				asrs.frames = 0;
+				continue;
+			case TRANSPORT_PCM_CLOSE:
+				/* reuse PCM read disconnection logic */
 				break;
 			case TRANSPORT_PCM_SYNC:
 				poll_timeout = 100;
-				break;
+				continue;
+			case TRANSPORT_PCM_DROP:
+				io_thread_read_pcm_flush(&t->a2dp.pcm);
+				continue;
 			default:
-				break;
+				continue;
 			}
-			continue;
 		}
 
-		/* read data from the FIFO - this function will block */
-		if ((samples = io_thread_read_pcm(&t->a2dp.pcm, in_buffer_tail, in_samples)) <= 0) {
-			if (samples == -1)
-				error("FIFO read error: %s", strerror(errno));
+		switch (samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) {
+		case 0:
+			poll_timeout = config.a2dp.keep_alive * 1000;
+			debug("Keep-alive polling: %d", poll_timeout);
+			continue;
+		case -1:
+			if (errno == EAGAIN)
+				continue;
+			error("PCM read error: %s", strerror(errno));
 			goto fail;
 		}
 
 		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
 		if (asrs.frames == 0)
-			asrsync_init(asrs, samplerate);
+			asrsync_init(&asrs, samplerate);
 
 		if (!config.a2dp.volume)
 			/* scale volume or mute audio signal */
-			io_thread_scale_pcm(t, in_buffer_tail, samples, channels);
+			io_thread_scale_pcm(t, pcm.tail, samples, channels);
 
-		/* overall input buffer size */
-		samples += in_buffer_tail - in_buffer;
-		/* in the encoding loop tail is used for reading */
-		in_buffer_tail = in_buffer;
+		/* move tail pointer */
+		ffb_seek(&pcm, samples);
 
-		while ((in_args.numInSamples = samples) != 0) {
+		while ((in_args.numInSamples = ffb_len_out(&pcm)) > 0) {
 
 			if ((err = aacEncEncode(handle, &in_buf, &out_buf, &in_args, &out_args)) != AACENC_OK)
 				error("AAC encoding error: %s", aacenc_strerror(err));
@@ -931,7 +1039,8 @@ void *io_thread_a2dp_source_aac(void *arg) {
 
 					pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
 
-					if ((ret = io_thread_write_bt(t->bt_fd, out_buffer, RTP_HEADER_LEN + len)) == -1) {
+					coutq_i = (coutq_i + 1) % ARRAYSIZE(coutq_history);
+					if ((ret = io_thread_write_bt(t, bt.data, RTP_HEADER_LEN + len, &coutq_history[coutq_i])) == -1) {
 						if (errno == ECONNRESET || errno == ENOTCONN) {
 							/* exit thread upon BT socket disconnection */
 							debug("BT socket disconnected: %d", t->bt_fd);
@@ -952,37 +1061,35 @@ void *io_thread_a2dp_source_aac(void *arg) {
 
 					/* move rest of data to the beginning of the payload */
 					debug("Payload fragmentation: extra %zd bytes", payload_len);
-					memmove(out_payload, out_payload + ret, payload_len);
+					memmove(rtp_payload, rtp_payload + ret, payload_len);
 
 				}
 
 			}
 
-			/* progress the tail position by the number of samples consumed by the
-			 * encoder, also adjust the number of samples in the input buffer */
-			in_buffer_tail += out_args.numInSamples;
-			samples -= out_args.numInSamples;
-
 			/* keep data transfer at a constant bit rate, also
 			 * get a timestamp for the next RTP frame */
 			unsigned int frames = out_args.numInSamples / channels;
 			asrsync_sync(&asrs, frames);
 			timestamp += frames * 10000 / samplerate;
-			t->delay = asrs.ts_busy.tv_nsec / 100000;
 
-		}
+			/* update busy delay (encoding overhead) */
+			t->delay = asrsync_get_busy_usec(&asrs) / 100;
+
+			/* If the input buffer was not consumed, we have to append new data to
+			 * the existing one. Since we do not use ring buffer, we will simply
+			 * move unprocessed data to the front of our linear buffer. */
+			ffb_shift(&pcm, out_args.numInSamples);
 
-		/* move leftovers to the beginning */
-		if (samples > 0 && in_buffer != in_buffer_tail)
-			memmove(in_buffer, in_buffer_tail, samples * in_buffer_element_size);
-		/* reposition input buffer tail */
-		in_buffer_tail = in_buffer + samples;
-		in_samples = in_buffer_size / in_buffer_element_size - samples;
+		}
 
 	}
 
 fail:
+final:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
 fail_init:
@@ -1000,6 +1107,8 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
+	bool locked = !transport_pthread_cleanup_lock(t);
+
 	APTXENC handle = malloc(SizeofAptxbtenc());
 	pthread_cleanup_push(PTHREAD_CLEANUP(free), handle);
 
@@ -1021,9 +1130,15 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 	if (ffb_init(&pcm, aptx_pcm_samples * (mtu_write / aptx_code_len)) == NULL ||
 			ffb_init(&bt, mtu_write) == NULL) {
 		error("Couldn't create data buffers: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
+	/* array with historical data of queued bytes for BT socket */
+	int coutq_history[IO_THREAD_COUTQ_HISTORY_SIZE] = { 0 };
+	size_t coutq_i = 0;
+
 	int poll_timeout = -1;
 	struct asrsync asrs = { .frames = 0 };
 	struct pollfd pfds[] = {
@@ -1031,6 +1146,9 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 		{ -1, POLLIN, 0 },
 	};
 
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
 	debug("Starting IO loop: %s (%s)",
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
@@ -1044,10 +1162,17 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 
 		switch (poll(pfds, ARRAYSIZE(pfds), poll_timeout)) {
 		case 0:
-			pthread_cond_signal(&t->a2dp.pcm.drained);
+			pthread_cond_signal(&t->a2dp.drained);
 			poll_timeout = -1;
+			locked = !transport_pthread_cleanup_lock(t);
+			if (t->a2dp.pcm.fd == -1)
+				goto final;
+			transport_pthread_cleanup_unlock(t);
+			locked = false;
 			continue;
 		case -1:
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -1058,29 +1183,41 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 			if (read(pfds[0].fd, &sig, sizeof(sig)) != sizeof(sig))
 				warn("Couldn't read signal: %s", strerror(errno));
 			switch (sig) {
+			case TRANSPORT_PCM_OPEN:
 			case TRANSPORT_PCM_RESUME:
+				poll_timeout = -1;
 				asrs.frames = 0;
+				continue;
+			case TRANSPORT_PCM_CLOSE:
+				/* reuse PCM read disconnection logic */
 				break;
 			case TRANSPORT_PCM_SYNC:
 				poll_timeout = 100;
-				break;
+				continue;
+			case TRANSPORT_PCM_DROP:
+				io_thread_read_pcm_flush(&t->a2dp.pcm);
+				continue;
 			default:
-				break;
+				continue;
 			}
-			continue;
 		}
 
-		/* read data from the FIFO - this function will block */
-		if ((samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) <= 0) {
-			if (samples == -1)
-				error("FIFO read error: %s", strerror(errno));
+		switch (samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) {
+		case 0:
+			poll_timeout = config.a2dp.keep_alive * 1000;
+			debug("Keep-alive polling: %d", poll_timeout);
+			continue;
+		case -1:
+			if (errno == EAGAIN)
+				continue;
+			error("PCM read error: %s", strerror(errno));
 			goto fail;
 		}
 
 		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
 		if (asrs.frames == 0)
-			asrsync_init(asrs, transport_get_sampling(t));
+			asrsync_init(&asrs, transport_get_sampling(t));
 
 		if (!config.a2dp.volume)
 			/* scale volume or mute audio signal */
@@ -1128,7 +1265,8 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 
 			pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
 
-			if (io_thread_write_bt(t->bt_fd, bt.data, ffb_len_out(&bt)) == -1) {
+			coutq_i = (coutq_i + 1) % ARRAYSIZE(coutq_history);
+			if (io_thread_write_bt(t, bt.data, ffb_len_out(&bt), &coutq_history[coutq_i]) == -1) {
 				if (errno == ECONNRESET || errno == ENOTCONN) {
 					/* exit thread upon BT socket disconnection */
 					debug("BT socket disconnected: %d", t->bt_fd);
@@ -1141,7 +1279,9 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 
 			/* keep data transfer at a constant bit rate */
 			asrsync_sync(&asrs, pcm_frames);
-			t->delay = asrs.ts_busy.tv_nsec / 100000;
+
+			/* update busy delay (encoding overhead) */
+			t->delay = asrsync_get_busy_usec(&asrs) / 100;
 
 			/* reinitialize output buffer */
 			ffb_rewind(&bt);
@@ -1157,11 +1297,252 @@ void *io_thread_a2dp_source_aptx(void *arg) {
 	}
 
 fail:
+final:
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
+	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
+fail_init:
+	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
+	return NULL;
+}
+#endif
+
+#if ENABLE_LDAC
+void *io_thread_a2dp_source_ldac(void *arg) {
+	struct ba_transport *t = (struct ba_transport *)arg;
+	const a2dp_ldac_t *cconfig = (a2dp_ldac_t *)t->a2dp.cconfig;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
+
+	bool locked = !transport_pthread_cleanup_lock(t);
+
+	HANDLE_LDAC_BT handle;
+	HANDLE_LDAC_ABR handle_abr;
+
+	if ((handle = ldacBT_get_handle()) == NULL) {
+		error("Couldn't open LDAC encoder: %s", strerror(errno));
+		goto fail_open_ldac;
+	}
+
+	pthread_cleanup_push(PTHREAD_CLEANUP(ldacBT_free_handle), handle);
+
+	if ((handle_abr = ldac_ABR_get_handle()) == NULL) {
+		error("Couldn't open LDAC ABR: %s", strerror(errno));
+		goto fail_open_ldac_abr;
+	}
+
+	pthread_cleanup_push(PTHREAD_CLEANUP(ldac_ABR_free_handle), handle_abr);
+
+	const unsigned int channels = transport_get_channels(t);
+	const unsigned int samplerate = transport_get_sampling(t);
+	const size_t ldac_pcm_samples = LDACBT_ENC_LSU * channels;
+
+	if (ldacBT_init_handle_encode(handle, t->mtu_write - RTP_HEADER_LEN - sizeof(rtp_media_header_t),
+				config.ldac_eqmid, cconfig->channel_mode, LDACBT_SMPL_FMT_S16, samplerate) == -1) {
+		error("Couldn't initialize LDAC encoder: %s", ldacBT_strerror(ldacBT_get_error_code(handle)));
+		goto fail_init;
+	}
+
+	if (ldac_ABR_Init(handle_abr, 1000 * ldac_pcm_samples / channels / samplerate) == -1) {
+		error("Couldn't initialize LDAC ABR");
+		goto fail_init;
+	}
+	if (ldac_ABR_set_thresholds(handle_abr, 6, 4, 2) == -1) {
+		error("Couldn't set LDAC ABR thresholds");
+		goto fail_init;
+	}
+
+	ffb_uint8_t bt = { 0 };
+	ffb_int16_t pcm = { 0 };
+	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt);
+	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_int16_free), &pcm);
+
+	if (ffb_init(&pcm, ldac_pcm_samples) == NULL ||
+			ffb_init(&bt, t->mtu_write) == NULL) {
+		error("Couldn't create data buffers: %s", strerror(ENOMEM));
+		goto fail_ffb;
+	}
+
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup_lock), t);
+
+	rtp_header_t *rtp_header;
+	rtp_media_header_t *rtp_media_header;
+
+	/* initialize RTP headers and get anchor for payload */
+	bt.tail = io_thread_init_rtp(bt.data, &rtp_header, &rtp_media_header);
+	uint16_t seq_number = ntohs(rtp_header->seq_number);
+	uint32_t timestamp = ntohl(rtp_header->timestamp);
+	size_t ts_frames = 0;
+
+	/* number of queued bytes in the BT socket */
+	int coutq = 0;
+
+	int poll_timeout = -1;
+	struct asrsync asrs = { .frames = 0 };
+	struct pollfd pfds[] = {
+		{ t->sig_fd[0], POLLIN, 0 },
+		{ -1, POLLIN, 0 },
+	};
+
+	transport_pthread_cleanup_unlock(t);
+	locked = false;
+
+	debug("Starting IO loop: %s (%s)",
+			bluetooth_profile_to_string(t->profile),
+			bluetooth_a2dp_codec_to_string(t->codec));
+	for (;;) {
+		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+
+		ssize_t samples;
+
+		/* add PCM socket to the poll if transport is active */
+		pfds[1].fd = t->state == TRANSPORT_ACTIVE ? t->a2dp.pcm.fd : -1;
+
+		switch (poll(pfds, ARRAYSIZE(pfds), poll_timeout)) {
+		case 0:
+			pthread_cond_signal(&t->a2dp.drained);
+			poll_timeout = -1;
+			locked = !transport_pthread_cleanup_lock(t);
+			if (t->a2dp.pcm.fd == -1)
+				goto final;
+			transport_pthread_cleanup_unlock(t);
+			locked = false;
+			continue;
+		case -1:
+			if (errno == EINTR)
+				continue;
+			error("Transport poll error: %s", strerror(errno));
+			goto fail;
+		}
+
+		if (pfds[0].revents & POLLIN) {
+			/* dispatch incoming event */
+			enum ba_transport_signal sig = -1;
+			if (read(pfds[0].fd, &sig, sizeof(sig)) != sizeof(sig))
+				warn("Couldn't read signal: %s", strerror(errno));
+			switch (sig) {
+			case TRANSPORT_PCM_OPEN:
+			case TRANSPORT_PCM_RESUME:
+				poll_timeout = -1;
+				asrs.frames = 0;
+				continue;
+			case TRANSPORT_PCM_CLOSE:
+				/* reuse PCM read disconnection logic */
+				break;
+			case TRANSPORT_PCM_SYNC:
+				poll_timeout = 100;
+				continue;
+			case TRANSPORT_PCM_DROP:
+				io_thread_read_pcm_flush(&t->a2dp.pcm);
+				continue;
+			default:
+				continue;
+			}
+		}
+
+		switch (samples = io_thread_read_pcm(&t->a2dp.pcm, pcm.tail, ffb_len_in(&pcm))) {
+		case 0:
+			poll_timeout = config.a2dp.keep_alive * 1000;
+			debug("Keep-alive polling: %d", poll_timeout);
+			continue;
+		case -1:
+			if (errno == EAGAIN)
+				continue;
+			error("PCM read error: %s", strerror(errno));
+			goto fail;
+		}
+
+		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+
+		if (asrs.frames == 0)
+			asrsync_init(&asrs, samplerate);
+
+		if (!config.a2dp.volume)
+			/* scale volume or mute audio signal */
+			io_thread_scale_pcm(t, pcm.tail, samples, channels);
+
+		/* get overall number of input samples */
+		ffb_seek(&pcm, samples);
+		samples = ffb_len_out(&pcm);
+
+		int16_t *input = pcm.data;
+		size_t input_len = samples;
+
+		/* encode and transfer obtained data */
+		while (input_len >= ldac_pcm_samples) {
+
+			int len;
+			int encoded;
+			int frames;
+
+			if (ldacBT_encode(handle, input, &len, bt.tail, &encoded, &frames) != 0) {
+				error("LDAC encoding error: %s", ldacBT_strerror(ldacBT_get_error_code(handle)));
+				break;
+			}
+
+			rtp_media_header->frame_count = frames;
+
+			frames = len / sizeof(int16_t);
+			input += frames;
+			input_len -= frames;
+
+			pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+
+			if (encoded &&
+					io_thread_write_bt(t, bt.data, ffb_len_out(&bt) + encoded, &coutq) == -1) {
+				if (errno == ECONNRESET || errno == ENOTCONN) {
+					/* exit thread upon BT socket disconnection */
+					debug("BT socket disconnected: %d", t->bt_fd);
+					goto fail;
+				}
+				error("BT socket write error: %s", strerror(errno));
+			}
+
+			if (config.ldac_abr)
+				ldac_ABR_Proc(handle, handle_abr, coutq / t->mtu_write, 1);
+
+			pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+
+			/* keep data transfer at a constant bit rate */
+			asrsync_sync(&asrs, frames / channels);
+			ts_frames += frames;
+
+			/* update busy delay (encoding overhead) */
+			t->delay = asrsync_get_busy_usec(&asrs) / 100;
+
+			if (encoded) {
+				timestamp += ts_frames / channels * 10000 / samplerate;
+				rtp_header->timestamp = htonl(timestamp);
+				rtp_header->seq_number = htons(++seq_number);
+				ts_frames = 0;
+			}
+
+		}
+
+		/* If the input buffer was not consumed (due to codesize limit), we
+		 * have to append new data to the existing one. Since we do not use
+		 * ring buffer, we will simply move unprocessed data to the front
+		 * of our linear buffer. */
+		ffb_shift(&pcm, samples - input_len);
+
+	}
+
+fail:
+final:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_pop(!locked);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
 fail_init:
 	pthread_cleanup_pop(1);
+fail_open_ldac_abr:
+	pthread_cleanup_pop(1);
+fail_open_ldac:
 	pthread_cleanup_pop(1);
 	return NULL;
 }
@@ -1173,7 +1554,7 @@ void *io_thread_sco(void *arg) {
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
-	/* buffers for transferring data to and fro SCO socket */
+	/* buffers for transferring data to and from SCO socket */
 	ffb_uint8_t bt_in = { 0 };
 	ffb_uint8_t bt_out = { 0 };
 	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt_in);
@@ -1183,7 +1564,7 @@ void *io_thread_sco(void *arg) {
 	if (ffb_init(&bt_in, 128) == NULL ||
 			ffb_init(&bt_out, 128) == NULL) {
 		error("Couldn't create data buffer: %s", strerror(ENOMEM));
-		goto fail;
+		goto fail_ffb;
 	}
 
 	int poll_timeout = -1;
@@ -1220,15 +1601,20 @@ void *io_thread_sco(void *arg) {
 				pfds[4].fd = t->sco.mic_pcm.fd;
 		}
 
-		if (t->sco.mic_pcm.fd == -1)
+		/* In order not to run this this loop unnecessarily, do not poll SCO for
+		 * reading if microphone (capture) PCM is not connected. For oFono this
+		 * rule does not apply, because we will use read error for SCO release. */
+		if (!t->sco.ofono && t->sco.mic_pcm.fd == -1)
 			pfds[1].fd = -1;
 
 		switch (poll(pfds, ARRAYSIZE(pfds), poll_timeout)) {
 		case 0:
-			pthread_cond_signal(&t->sco.spk_pcm.drained);
+			pthread_cond_signal(&t->sco.spk_drained);
 			poll_timeout = -1;
 			continue;
 		case -1:
+			if (errno == EINTR)
+				continue;
 			error("Transport poll error: %s", strerror(errno));
 			goto fail;
 		}
@@ -1242,14 +1628,32 @@ void *io_thread_sco(void *arg) {
 			if (read(pfds[0].fd, &sig, sizeof(sig)) != sizeof(sig))
 				warn("Couldn't read signal: %s", strerror(errno));
 
-			/* FIXME: Drain functionality for speaker.
-			 * XXX: Right now it is not possible to drain speaker PCM (in a clean
-			 *      fashion), because poll() will not timeout if we've got incoming
-			 *      data from the microphone (BT SCO socket). In order not to hang
-			 *      forever in the transport_drain_pcm() function, we will signal
-			 *      PCM drain right now. */
-			if (sig == TRANSPORT_PCM_SYNC)
-				pthread_cond_signal(&t->sco.spk_pcm.drained);
+			switch (sig) {
+			case TRANSPORT_BT_OPEN:
+			case TRANSPORT_PCM_OPEN:
+			case TRANSPORT_PCM_RESUME:
+				poll_timeout = -1;
+				asrs.frames = 0;
+				break;
+			case TRANSPORT_PCM_SYNC:
+				/* FIXME: Drain functionality for speaker.
+				 * XXX: Right now it is not possible to drain speaker PCM (in a clean
+				 *      fashion), because poll() will not timeout if we've got incoming
+				 *      data from the microphone (BT SCO socket). In order not to hang
+				 *      forever in the transport_drain_pcm() function, we will signal
+				 *      PCM drain right now. */
+				pthread_cond_signal(&t->sco.spk_drained);
+				break;
+			case TRANSPORT_PCM_DROP:
+				io_thread_read_pcm_flush(&t->sco.spk_pcm);
+				continue;
+			default:
+				break;
+			}
+
+			/* connection is managed by oFono */
+			if (t->sco.ofono)
+				continue;
 
 			const enum hfp_ind *inds = t->sco.rfcomm->rfcomm.hfp_inds;
 			bool release = false;
@@ -1259,6 +1663,7 @@ void *io_thread_sco(void *arg) {
 			 * transfered even though we are not reading from it! */
 			if (t->sco.spk_pcm.fd == -1 && t->sco.mic_pcm.fd == -1)
 				release = true;
+
 			/* For HFP HF we have to check if we are in the call stage or in the
 			 * call setup stage. Otherwise, it might be not possible to acquire
 			 * SCO connection. */
@@ -1268,17 +1673,17 @@ void *io_thread_sco(void *arg) {
 				release = true;
 
 			if (release) {
-				transport_release_bt_sco(t);
+				t->release(t);
 				asrs.frames = 0;
 			}
 			else
-				transport_acquire_bt_sco(t);
+				t->acquire(t);
 
 			continue;
 		}
 
 		if (asrs.frames == 0)
-			asrsync_init(asrs, transport_get_sampling(t));
+			asrsync_init(&asrs, transport_get_sampling(t));
 
 		if (pfds[1].revents & POLLIN) {
 			/* dispatch incoming SCO data */
@@ -1290,6 +1695,8 @@ void *io_thread_sco(void *arg) {
 			switch (t->codec) {
 			case HFP_CODEC_CVSD:
 			default:
+				if (t->sco.mic_pcm.fd == -1)
+					ffb_rewind(&bt_in);
 				buffer = bt_in.tail;
 				buffer_len = ffb_len_in(&bt_in);
 			}
@@ -1303,7 +1710,7 @@ retry_sco_read:
 				case 0:
 				case ECONNABORTED:
 				case ECONNRESET:
-					transport_release_bt_sco(t);
+					t->release(t);
 					continue;
 				default:
 					error("SCO read error: %s", strerror(errno));
@@ -1319,7 +1726,7 @@ retry_sco_read:
 		}
 		else if (pfds[1].revents & (POLLERR | POLLHUP)) {
 			debug("SCO poll error status: %#x", pfds[1].revents);
-			transport_release_bt_sco(t);
+			t->release(t);
 		}
 
 		if (pfds[2].revents & POLLOUT) {
@@ -1345,7 +1752,7 @@ retry_sco_write:
 				case 0:
 				case ECONNABORTED:
 				case ECONNRESET:
-					transport_release_bt_sco(t);
+					t->release(t);
 					continue;
 				default:
 					error("SCO write error: %s", strerror(errno));
@@ -1373,10 +1780,9 @@ retry_sco_write:
 				samples = ffb_len_in(&bt_out) / sizeof(int16_t);
 			}
 
-			/* read data from the FIFO - this function will block */
 			if ((samples = io_thread_read_pcm(&t->sco.spk_pcm, buffer, samples)) <= 0) {
-				if (samples == -1)
-					error("FIFO read error: %s", strerror(errno));
+				if (samples == -1 && errno != EAGAIN)
+					error("PCM read error: %s", strerror(errno));
 				continue;
 			}
 
@@ -1392,8 +1798,7 @@ retry_sco_write:
 		}
 		else if (pfds[3].revents & (POLLERR | POLLHUP)) {
 			debug("PCM poll error status: %#x", pfds[3].revents);
-			close(t->sco.spk_pcm.fd);
-			t->sco.spk_pcm.fd = -1;
+			transport_release_pcm(&t->sco.spk_pcm);
 		}
 
 		if (pfds[4].revents & POLLOUT) {
@@ -1425,14 +1830,96 @@ retry_sco_write:
 
 		/* keep data transfer at a constant bit rate */
 		asrsync_sync(&asrs, 48 / 2);
-		t->delay = asrs.ts_busy.tv_nsec / 100000;
+		/* update busy delay (encoding overhead) */
+		t->delay = asrsync_get_busy_usec(&asrs) / 100;
+
+	}
+
+fail:
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+fail_ffb:
+	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
+	return NULL;
+}
+
+#if DEBUG
+/**
+ * Dump incoming BT data to a file. */
+void *io_thread_a2dp_sink_dump(void *arg) {
+	struct ba_transport *t = (struct ba_transport *)arg;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
+
+	ffb_uint8_t bt = { 0 };
+	FILE *f = NULL;
+	char fname[64];
+	char *ptr;
+
+	sprintf(fname, "/tmp/ba-%s-%s.dump",
+			bluetooth_profile_to_string(t->profile),
+			bluetooth_a2dp_codec_to_string(t->codec));
+	for (ptr = fname; *ptr != '\0'; ptr++) {
+		*ptr = tolower(*ptr);
+		if (*ptr == ' ')
+			*ptr = '-';
+	}
+
+	debug("Opening BT dump file: %s", fname);
+	if ((f = fopen(fname, "wb")) == NULL) {
+		error("Couldn't create dump file: %s", strerror(errno));
+		goto fail_open;
+	}
+
+	pthread_cleanup_push(PTHREAD_CLEANUP(ffb_uint8_free), &bt);
+	pthread_cleanup_push(PTHREAD_CLEANUP(fclose), f);
 
+	if (ffb_init(&bt, t->mtu_read) == NULL) {
+		error("Couldn't create data buffer: %s", strerror(ENOMEM));
+		goto fail_ffb;
+	}
+
+	struct pollfd pfds[] = {
+		{ t->sig_fd[0], POLLIN, 0 },
+		{ t->bt_fd, POLLIN, 0 },
+	};
+
+	for (;;) {
+		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+
+		ssize_t len;
+
+		if (poll(pfds, ARRAYSIZE(pfds), -1) == -1) {
+			if (errno == EINTR)
+				continue;
+			error("Transport poll error: %s", strerror(errno));
+			goto fail;
+		}
+
+		if (pfds[0].revents & POLLIN) {
+			if (read(pfds[0].fd, bt.data, ffb_blen_in(&bt)) == -1)
+				warn("Couldn't read signal: %s", strerror(errno));
+			continue;
+		}
+
+		if ((len = read(pfds[1].fd, bt.tail, ffb_len_in(&bt))) == -1) {
+			debug("BT read error: %s", strerror(errno));
+			continue;
+		}
+
+		debug("BT read: %zd", len);
+		fwrite(bt.data, 1, len, f);
 	}
 
 fail:
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+fail_ffb:
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
+fail_open:
 	pthread_cleanup_pop(1);
 	return NULL;
 }
+#endif
diff --git a/src/io.h b/src/io.h
index 7786488..d97a662 100644
--- a/src/io.h
+++ b/src/io.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - io.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -12,9 +12,12 @@
 #define BLUEALSA_IO_H_
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
+/* The number of snapshots of BT socket COUTQ bytes. */
+#define IO_THREAD_COUTQ_HISTORY_SIZE 16
+
 void *io_thread_a2dp_sink_sbc(void *arg);
 void *io_thread_a2dp_source_sbc(void *arg);
 #if ENABLE_AAC
@@ -24,7 +27,14 @@ void *io_thread_a2dp_source_aac(void *arg);
 #if ENABLE_APTX
 void *io_thread_a2dp_source_aptx(void *arg);
 #endif
+#if ENABLE_LDAC
+void *io_thread_a2dp_source_ldac(void *arg);
+#endif
 
 void *io_thread_sco(void *arg);
 
+#if DEBUG
+void *io_thread_a2dp_sink_dump(void *arg);
+#endif
+
 #endif
diff --git a/src/main.c b/src/main.c
index bff057e..e5db265 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - main.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -9,7 +9,7 @@
  */
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <errno.h>
@@ -25,9 +25,16 @@
 #include <glib.h>
 #include <gio/gio.h>
 
+#if ENABLE_LDAC
+# include <ldacBT.h>
+#endif
+
 #include "bluealsa.h"
 #include "bluez.h"
 #include "ctl.h"
+#if ENABLE_OFONO
+# include "ofono.h"
+#endif
 #include "transport.h"
 #include "utils.h"
 #include "shared/defs.h"
@@ -74,10 +81,15 @@ int main(int argc, char **argv) {
 		{ "profile", required_argument, NULL, 'p' },
 		{ "a2dp-force-mono", no_argument, NULL, 6 },
 		{ "a2dp-force-audio-cd", no_argument, NULL, 7 },
-		{ "a2dp-volume", no_argument, NULL, 8 },
+		{ "a2dp-keep-alive", required_argument, NULL, 8 },
+		{ "a2dp-volume", no_argument, NULL, 9 },
 #if ENABLE_AAC
 		{ "aac-afterburner", no_argument, NULL, 4 },
 		{ "aac-vbr-mode", required_argument, NULL, 5 },
+#endif
+#if ENABLE_LDAC
+		{ "ldac-abr", no_argument, NULL, 10 },
+		{ "ldac-eqmid", required_argument, NULL, 11 },
 #endif
 		{ 0, 0, 0, 0 },
 	};
@@ -141,14 +153,22 @@ int main(int argc, char **argv) {
 					"  -p, --profile=NAME\tenable BT profile\n"
 					"  --a2dp-force-mono\tforce monophonic sound\n"
 					"  --a2dp-force-audio-cd\tforce 44.1 kHz sampling\n"
+					"  --a2dp-keep-alive=SEC\tkeep A2DP transport alive\n"
 					"  --a2dp-volume\t\tcontrol volume natively\n"
 #if ENABLE_AAC
 					"  --aac-afterburner\tenable afterburner\n"
 					"  --aac-vbr-mode=NB\tset VBR mode to NB\n"
+#endif
+#if ENABLE_LDAC
+					"  --ldac-abr\t\tenable adaptive bit rate\n"
+					"  --ldac-eqmid=NB\tset encoder quality to NB\n"
 #endif
 					"\nAvailable BT profiles:\n"
 					"  - a2dp-source\tAdvanced Audio Source (%s)\n"
 					"  - a2dp-sink\tAdvanced Audio Sink (%s)\n"
+#if ENABLE_OFONO
+					"  - hfp-ofono\tHands-Free handled by oFono (hf & ag)\n"
+#endif
 					"  - hfp-hf\tHands-Free (%s)\n"
 					"  - hfp-ag\tHands-Free Audio Gateway (%s)\n"
 					"  - hsp-hs\tHeadset (%s)\n"
@@ -210,6 +230,9 @@ int main(int argc, char **argv) {
 			} map[] = {
 				{ "a2dp-source", &config.enable.a2dp_source },
 				{ "a2dp-sink", &config.enable.a2dp_sink },
+#if ENABLE_OFONO
+				{ "hfp-ofono", &config.enable.hfp_ofono },
+#endif
 				{ "hfp-hf", &config.enable.hfp_hf },
 				{ "hfp-ag", &config.enable.hfp_ag },
 				{ "hsp-hs", &config.enable.hsp_hs },
@@ -236,7 +259,10 @@ int main(int argc, char **argv) {
 		case 7 /* --a2dp-force-audio-cd */ :
 			config.a2dp.force_44100 = true;
 			break;
-		case 8 /* --a2dp-volume */ :
+		case 8 /* --a2dp-keep-alive=SEC */ :
+			config.a2dp.keep_alive = atoi(optarg);
+			break;
+		case 9 /* --a2dp-volume */ :
 			config.a2dp.volume = true;
 			break;
 
@@ -253,21 +279,40 @@ int main(int argc, char **argv) {
 			break;
 #endif
 
+#if ENABLE_LDAC
+		case 10 /* --ldac-abr */ :
+			config.ldac_abr = true;
+			break;
+		case 11 /* --ldac-eqmid=NB */ :
+			config.ldac_eqmid = atoi(optarg);
+			if (config.ldac_eqmid >= LDACBT_EQMID_NUM) {
+				error("Invalid encoder quality index [0, %d]: %s", LDACBT_EQMID_NUM - 1, optarg);
+				return EXIT_FAILURE;
+			}
+			break;
+#endif
+
 		default:
 			fprintf(stderr, "Try '%s --help' for more information.\n", argv[0]);
 			return EXIT_FAILURE;
 		}
 
+#if ENABLE_OFONO
+	if (config.enable.hfp_ofono) {
+		debug("Disabling native HFP due to enabled oFono");
+		config.enable.hfp_ag = false;
+		config.enable.hfp_hf = false;
+	}
+#endif
+
 	/* device list is no longer required */
 	free(hci_devs);
 
 	/* initialize random number generator */
 	srandom(time(NULL));
 
-	if ((bluealsa_ctl_thread_init()) == -1) {
-		error("Couldn't initialize controller thread: %s", strerror(errno));
+	if ((bluealsa_ctl_thread_init()) == -1)
 		return EXIT_FAILURE;
-	}
 
 	gchar *address;
 	GError *err;
@@ -283,10 +328,14 @@ int main(int argc, char **argv) {
 	}
 
 	bluez_subscribe_signals();
-
 	bluez_register_a2dp();
 	bluez_register_hfp();
 
+#if ENABLE_OFONO
+	ofono_subscribe_signals();
+	ofono_register();
+#endif
+
 	/* In order to receive EPIPE while writing to the pipe whose reading end
 	 * is closed, the SIGPIPE signal has to be handled. For more information
 	 * see the io_thread_write_pcm() function. */
@@ -305,10 +354,9 @@ int main(int argc, char **argv) {
 
 	debug("Exiting main loop");
 
-	/* From all of the cleanup routines, these ones cannot be omitted. We have
-	 * to unlink named sockets, otherwise service will not start any more. */
+	/* From all of the cleanup routines, this one cannot be omitted. We have
+	 * to unlink named socket, otherwise service will not start any more. */
 	bluealsa_ctl_free();
-	bluealsa_config_free();
 
 	return EXIT_SUCCESS;
 }
diff --git a/src/ofono-iface.c b/src/ofono-iface.c
new file mode 100644
index 0000000..2f3c493
--- /dev/null
+++ b/src/ofono-iface.c
@@ -0,0 +1,59 @@
+/*
+ * BlueALSA - ofono-iface.c
+ * Copyright (c) 2018 Thierry Bultel (thierry.bultel@iot.bzh)
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#include "ofono-iface.h"
+
+static const GDBusArgInfo arg_card = {
+	-1, "card", "o", NULL
+};
+
+static const GDBusArgInfo arg_fd = {
+	-1, "fd", "h", NULL
+};
+
+static const GDBusArgInfo arg_codec = {
+	-1, "codec", "y", NULL
+};
+
+static const GDBusArgInfo *in_NewConnection[] = {
+	&arg_card,
+	&arg_fd,
+	&arg_codec,
+	NULL,
+};
+
+static const GDBusMethodInfo ofono_iface_hf_audio_agent_NewConnection = {
+	-1, "NewConnection",
+	(GDBusArgInfo **)in_NewConnection,
+	NULL,
+	NULL,
+};
+
+static const GDBusMethodInfo ofono_iface_hf_audio_agent_Release = {
+	-1, "Release",
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const GDBusMethodInfo *ofono_iface_hf_audio_agent_methods[] = {
+	&ofono_iface_hf_audio_agent_NewConnection,
+	&ofono_iface_hf_audio_agent_Release,
+	NULL,
+};
+
+
+const GDBusInterfaceInfo ofono_iface_hf_audio_agent = {
+	-1, OFONO_IFACE_HF_AUDIO_AGENT,
+	(GDBusMethodInfo **)ofono_iface_hf_audio_agent_methods,
+	NULL,
+	NULL,
+	NULL,
+};
diff --git a/src/ofono-iface.h b/src/ofono-iface.h
new file mode 100644
index 0000000..4a5f346
--- /dev/null
+++ b/src/ofono-iface.h
@@ -0,0 +1,30 @@
+/*
+ * BlueALSA - ofono-iface.h
+ * Copyright (c) 2018 Thierry Bultel (thierry.bultel@iot.bzh)
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#ifndef BLUEALSA_OFONOIFACE_H_
+#define BLUEALSA_OFONOIFACE_H_
+
+#include <gio/gio.h>
+
+#define OFONO_SERVICE "org.ofono"
+
+#define OFONO_IFACE_HF_AUDIO_AGENT   OFONO_SERVICE ".HandsfreeAudioAgent"
+#define OFONO_IFACE_HF_AUDIO_CARD    OFONO_SERVICE ".HandsfreeAudioCard"
+#define OFONO_IFACE_HF_AUDIO_MANAGER OFONO_SERVICE ".HandsfreeAudioManager"
+
+#define OFONO_AUDIO_CARD_TYPE_AG "gateway"
+#define OFONO_AUDIO_CARD_TYPE_HF "handsfree"
+
+#define OFONO_AUDIO_CODEC_CVSD 0x01
+#define OFONO_AUDIO_CODEC_MSBC 0x02
+
+const GDBusInterfaceInfo ofono_iface_hf_audio_agent;
+
+#endif
diff --git a/src/ofono.c b/src/ofono.c
new file mode 100644
index 0000000..d2f905f
--- /dev/null
+++ b/src/ofono.c
@@ -0,0 +1,555 @@
+/*
+ * BlueALSA - ofono.c
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
+ *               2018 Thierry Bultel
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ * When oFono is running on a system, it registers itself to BlueZ as an HFP
+ * profile, which conflicts with our internal "--hfp-ag" and "--hpf-hf" ones.
+ * This file is an implementation of the oFono back-end for bluez-alsa.
+ *
+ * For more details, see:
+ * https://github.com/rilmodem/ofono/blob/master/doc/handsfree-audio-api.txt
+ *
+ */
+
+#include "ofono.h"
+
+#include <errno.h>
+#include <poll.h>
+
+#include <gio/gunixfdlist.h>
+
+#include "bluealsa.h"
+#include "ctl.h"
+#include "ofono-iface.h"
+#include "transport.h"
+#include "shared/log.h"
+
+#define OFONO_FAKE_DEV_ID 0xffff
+
+static unsigned int dbus_agent_object_id = 0;
+
+/**
+ * Authorize oFono SCO connection.
+ *
+ * @param fd SCO socket file descriptor.
+ * @return On success this function returns 0. Otherwise, -1 is returned and
+ *	 errno is set to indicate the error. */
+static int ofono_sco_socket_authorize(int fd) {
+
+	struct pollfd pfd = { fd, POLLOUT, 0 };
+	char c;
+
+	if (poll(&pfd, 1, 0) == -1)
+		return -1;
+
+	/* If socket is not writable, it means that it is in the defer setup
+	 * state, so it needs to be read to authorize the connection. */
+	if (!(pfd.revents & POLLOUT) && read(fd, &c, 1) == -1)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * Ask oFono to connect to a card (in return it will call NewConnection). */
+static int ofono_acquire_bt_sco(struct ba_transport *t) {
+
+	GDBusConnection *conn = config.dbus;
+	GDBusMessage *msg = NULL, *rep = NULL;
+	GError *err = NULL;
+	int ret = 0;
+
+	debug("Requesting new oFono SCO connection: %s", t->device->name);
+
+	msg = g_dbus_message_new_method_call(OFONO_SERVICE, t->device->name,
+			OFONO_IFACE_HF_AUDIO_CARD, "Connect");
+
+	if ((rep = g_dbus_connection_send_message_with_reply_sync(conn, msg,
+					G_DBUS_SEND_MESSAGE_FLAGS_NONE, -1, NULL, NULL, &err)) == NULL)
+		goto fail;
+
+	if (g_dbus_message_get_message_type(rep) == G_DBUS_MESSAGE_TYPE_ERROR) {
+		g_dbus_message_to_gerror(rep, &err);
+		goto fail;
+	}
+
+	goto final;
+
+fail:
+	ret = -1;
+
+final:
+	if (msg != NULL)
+		g_object_unref(msg);
+	if (rep != NULL)
+		g_object_unref(rep);
+	if (err != NULL) {
+		warn("Couldn't connect to card: %s", err->message);
+		g_error_free(err);
+	}
+
+	return ret;
+}
+
+/**
+ * Disconnects from a card.
+ *
+ * This is basically called when no PCM client is connected, in order to save
+ * bandwidth for Bluetooth.
+ *
+ * @return On success this function returns 0. Otherwise -1 is returned. */
+static int ofono_release_bt_sco(struct ba_transport *t) {
+
+	if (t->bt_fd == -1)
+		return 0;
+
+	debug("Closing oFono SCO: %d", t->bt_fd);
+
+	shutdown(t->bt_fd, SHUT_RDWR);
+	close(t->bt_fd);
+
+	t->bt_fd = -1;
+	t->codec = HFP_CODEC_UNDEFINED;
+
+	bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &t->device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
+
+	return 0;
+}
+
+/**
+ * Create new oFono transport.
+ *
+ * It will be created with an unset codec, which is the condition for it
+ * to be hidden to clients. The codec will be set when the phone call starts.
+ *
+ * @return On success, the pointer to the newly allocated transport structure
+ *   is returned. If error occurs, NULL is returned and the errno variable is
+ *   set to indicated the cause of the error. */
+static struct ba_transport *ofono_transport_new(
+		struct ba_device *device,
+		const char *dbus_owner,
+		const char *dbus_path,
+		enum bluetooth_profile profile) {
+
+	struct ba_transport *t;
+
+	if ((t = transport_new_sco(device, dbus_owner, dbus_path,
+					profile, HFP_CODEC_UNDEFINED)) == NULL)
+		return NULL;
+
+	t->sco.ofono = true;
+	t->acquire = ofono_acquire_bt_sco;
+	t->release = ofono_release_bt_sco;
+
+	return t;
+}
+
+/**
+ * Add new oFono card (phone). */
+static void ofono_card_add(const char *dbus_sender, const char *card,
+		GVariantIter *properties) {
+
+	const char *key = NULL;
+	GVariant *value = NULL;
+	gchar *path = g_strdup_printf("/ofono%s", card);
+	enum bluetooth_profile profile = BLUETOOTH_PROFILE_HFP_HF;
+	bool devpool_mutex_locked = false;
+	struct ba_transport *t;
+	struct ba_device *d;
+	bdaddr_t addr;
+
+	while (g_variant_iter_next(properties, "{&sv}", &key, &value)) {
+		if (strcmp(key, "RemoteAddress") == 0)
+			str2ba(g_variant_get_string(value, NULL), &addr);
+		else if (strcmp(key, "Type") == 0) {
+			const char *type = g_variant_get_string(value, NULL);
+			if (strcmp(type, OFONO_AUDIO_CARD_TYPE_AG) == 0)
+				profile = BLUETOOTH_PROFILE_HFP_AG;
+			else if (strcmp(type, OFONO_AUDIO_CARD_TYPE_HF) == 0)
+				profile = BLUETOOTH_PROFILE_HFP_HF;
+			else {
+				error("Unsupported profile type: %s", type);
+				goto fail;
+			}
+		}
+		g_variant_unref(value);
+		value = NULL;
+	}
+
+	debug("Adding new oFono card: %s", card);
+
+	bluealsa_devpool_mutex_lock();
+	devpool_mutex_locked = true;
+
+	char name[sizeof(d->name)];
+	ba2str(&addr, name);
+
+	if ((d = device_new(OFONO_FAKE_DEV_ID, &addr, name)) == NULL) {
+		error("Couldn't create device: %s", strerror(errno));
+		goto fail;
+	}
+
+	bluealsa_device_insert(card, d);
+
+	if ((t = ofono_transport_new(d, dbus_sender, path, profile)) == NULL) {
+		error("Couldn't create new transport: %s", strerror(errno));
+		goto fail;
+	}
+
+	transport_set_state(t, TRANSPORT_ACTIVE);
+
+fail:
+	if (devpool_mutex_locked)
+		bluealsa_devpool_mutex_unlock();
+	if (value != NULL)
+		g_variant_unref(value);
+	g_free(path);
+}
+
+/**
+ * Get all oFono cards (phones). */
+static int ofono_get_all_cards(void) {
+
+	GDBusConnection *conn = config.dbus;
+	GDBusMessage *msg = NULL, *rep = NULL;
+	GError *err = NULL;
+	int ret = 0;
+
+	msg = g_dbus_message_new_method_call(OFONO_SERVICE, "/",
+			OFONO_IFACE_HF_AUDIO_MANAGER, "GetCards");
+
+	if ((rep = g_dbus_connection_send_message_with_reply_sync(conn, msg,
+					G_DBUS_SEND_MESSAGE_FLAGS_NONE, -1, NULL, NULL, &err)) == NULL)
+		goto fail;
+
+	if (g_dbus_message_get_message_type(rep) == G_DBUS_MESSAGE_TYPE_ERROR) {
+		g_dbus_message_to_gerror(rep, &err);
+		goto fail;
+	}
+
+	const gchar *sender = g_dbus_message_get_sender(rep);
+	GVariant *body = g_dbus_message_get_body(rep);
+
+	GVariantIter *cards;
+	GVariantIter *properties = NULL;
+	const char *card;
+
+	g_variant_get(body, "(a(oa{sv}))", &cards);
+	while (g_variant_iter_next(cards, "(&oa{sv})", &card, &properties))
+		ofono_card_add(sender, card, properties);
+
+	goto final;
+
+fail:
+	ret = -1;
+
+final:
+	if (msg != NULL)
+		g_object_unref(msg);
+	if (rep != NULL)
+		g_object_unref(rep);
+	if (err != NULL) {
+		warn("Couldn't get oFono cards: %s", err->message);
+		g_error_free(err);
+	}
+
+	return ret;
+}
+
+/**
+ * Remove all oFono cards and deletes associated transports. */
+static void ofono_remove_all_cards(void) {
+
+	GHashTableIter iter;
+	struct ba_device *d;
+
+	bluealsa_devpool_mutex_lock();
+
+	g_hash_table_iter_init(&iter, config.devices);
+	while (g_hash_table_iter_next(&iter, NULL, (gpointer)&d)) {
+		if (d->hci_dev_id != OFONO_FAKE_DEV_ID)
+			continue;
+		g_hash_table_iter_remove(&iter);
+	}
+
+	bluealsa_devpool_mutex_unlock();
+}
+
+static void ofono_agent_new_connection(GDBusMethodInvocation *inv, void *userdata) {
+	(void)userdata;
+
+	GDBusMessage *msg = g_dbus_method_invocation_get_message(inv);
+	GVariant *params = g_dbus_method_invocation_get_parameters(inv);
+	bool devpool_mutex_locked = false;
+	struct ba_transport *t;
+	GError *err = NULL;
+	gchar *path = NULL;
+	GUnixFDList *fd_list;
+	const char *card;
+	uint8_t codec;
+	int fd;
+
+	g_variant_get(params, "(&ohy)", &card, &fd, &codec);
+
+	fd_list = g_dbus_message_get_unix_fd_list(msg);
+	if ((fd = g_unix_fd_list_get(fd_list, 0, &err)) == -1) {
+		error("Couldn't obtain SCO socket: %s", err->message);
+		goto fail;
+	}
+
+	bluealsa_devpool_mutex_lock();
+	devpool_mutex_locked = true;
+
+	path = g_strdup_printf("/ofono%s", card);
+	if ((t = transport_lookup(config.devices, path)) == NULL) {
+		error("Transport not available: %s", path);
+		goto fail;
+	}
+
+	if (ofono_sco_socket_authorize(fd) == -1) {
+		error("Couldn't authorize SCO connection: %s", strerror(errno));
+		goto fail;
+	}
+
+	debug("New oFono SCO connection (codec: %#x): %d", codec, fd);
+
+	t->bt_fd = fd;
+	t->codec = codec;
+
+	t->mtu_read = 48;
+	t->mtu_write = 48;
+
+	bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &t->device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
+	transport_send_signal(t, TRANSPORT_BT_OPEN);
+
+	g_dbus_method_invocation_return_value(inv, NULL);
+	goto final;
+
+fail:
+	g_dbus_method_invocation_return_error(inv, G_DBUS_ERROR,
+		G_DBUS_ERROR_INVALID_ARGS, "Unable to get connection");
+
+final:
+	if (devpool_mutex_locked)
+		bluealsa_devpool_mutex_unlock();
+	if (path != NULL)
+		g_free(path);
+	if (err != NULL)
+		g_error_free(err);
+}
+
+/**
+ * Callback for the Release method, called when oFono is properly shutdown. */
+static void ofono_agent_release(GDBusMethodInvocation *inv, void *userdata) {
+	(void)userdata;
+
+	GDBusConnection *conn = g_dbus_method_invocation_get_connection(inv);
+
+	g_dbus_connection_unregister_object(conn, dbus_agent_object_id);
+	ofono_remove_all_cards();
+
+	g_object_unref(inv);
+}
+
+static void ofono_hf_audio_agent_method_call(GDBusConnection *conn, const gchar *sender,
+		const gchar *path, const gchar *interface, const gchar *method, GVariant *params,
+		GDBusMethodInvocation *invocation, void *userdata) {
+	(void)conn;
+	(void)sender;
+	(void)path;
+	(void)interface;
+	(void)params;
+
+	debug("oFono audio agent method call: %s.%s()", interface, method);
+
+	if (strcmp(method, "NewConnection") == 0)
+		ofono_agent_new_connection(invocation, userdata);
+	else if (strcmp(method, "Release") == 0)
+		ofono_agent_release(invocation, userdata);
+	else
+		warn("Unsupported oFono method: %s", method);
+
+}
+
+static const GDBusInterfaceVTable ofono_vtable = {
+	.method_call = ofono_hf_audio_agent_method_call,
+};
+
+/**
+ * Register to the oFono service.
+ *
+ * @return On success this function returns 0. Otherwise -1 is returned. */
+int ofono_register(void) {
+
+	const char *path = "/HandsfreeAudioAgent";
+	GDBusConnection *conn = config.dbus;
+	GDBusMessage *msg = NULL, *rep = NULL;
+	GError *err = NULL;
+	int ret = 0;
+
+	if (!config.enable.hfp_ofono)
+		goto final;
+
+	debug("Registering oFono audio agent");
+	if ((dbus_agent_object_id = g_dbus_connection_register_object(conn, path,
+					(GDBusInterfaceInfo *)&ofono_iface_hf_audio_agent, &ofono_vtable,
+					NULL, NULL, &err)) == 0)
+		goto fail;
+
+	msg = g_dbus_message_new_method_call(OFONO_SERVICE, "/",
+			OFONO_IFACE_HF_AUDIO_MANAGER, "Register");
+
+	GVariantBuilder options;
+
+	g_variant_builder_init(&options, G_VARIANT_TYPE("ay"));
+	g_variant_builder_add(&options, "y", OFONO_AUDIO_CODEC_CVSD);
+
+	g_dbus_message_set_body(msg, g_variant_new("(oay)", path, &options));
+	g_variant_builder_clear(&options);
+
+	if ((rep = g_dbus_connection_send_message_with_reply_sync(conn, msg,
+					G_DBUS_SEND_MESSAGE_FLAGS_NONE, -1, NULL, NULL, &err)) == NULL)
+		goto fail;
+
+	if (g_dbus_message_get_message_type(rep) == G_DBUS_MESSAGE_TYPE_ERROR) {
+		g_dbus_message_to_gerror(rep, &err);
+		goto fail;
+	}
+
+	ofono_get_all_cards();
+
+	goto final;
+
+fail:
+	ret = -1;
+
+final:
+	if (msg != NULL)
+		g_object_unref(msg);
+	if (rep != NULL)
+		g_object_unref(rep);
+	if (err != NULL) {
+		warn("Couldn't register oFono: %s", err->message);
+		g_dbus_connection_unregister_object(conn, dbus_agent_object_id);
+		g_error_free(err);
+	}
+
+	return ret;
+}
+
+/**
+ * Callback for the CardAdded signal (emitted when phone is connected). */
+static void ofono_signal_card_added(GDBusConnection *conn, const gchar *sender,
+		const gchar *path, const gchar *interface, const gchar *signal, GVariant *params,
+		void *userdata) {
+	(void)conn;
+	(void)path;
+	(void)interface;
+	(void)userdata;
+
+	const gchar *signature = g_variant_get_type_string(params);
+	const char *card = NULL;
+	GVariantIter *properties = NULL;
+
+	if (strcmp(signature, "(oa{sv})") != 0) {
+		error("Invalid signature for %s: %s != %s", signal, signature, "(oa{sv})");
+		return;
+	}
+
+	g_variant_get(params, "(&oa{sv})", &card, &properties);
+	ofono_card_add(sender, card, properties);
+
+	g_variant_iter_free(properties);
+}
+
+/**
+ * Callback for the CardRemoved signal (emitted when phone is disconnected). */
+static void ofono_signal_card_removed(GDBusConnection *conn, const gchar *sender,
+		const gchar *path, const gchar *interface, const gchar *signal, GVariant *params,
+		void *userdata) {
+	(void)conn;
+	(void)sender;
+	(void)path;
+	(void)interface;
+	(void)userdata;
+
+	const gchar *signature = g_variant_get_type_string(params);
+	const char *card = NULL;
+
+	if (strcmp(signature, "(o)") != 0) {
+		error("Invalid signature for %s: %s != %s", signal, signature, "(o)");
+		return;
+	}
+
+	g_variant_get(params, "(&o)", &card);
+
+	debug("Removing oFono card: %s", card);
+
+	bluealsa_devpool_mutex_lock();
+	bluealsa_device_remove(card);
+	bluealsa_devpool_mutex_unlock();
+
+}
+
+/**
+ * Monitor oFono service availability.
+ *
+ * When oFono is properly shutdown, we are notified through the Release()
+ * method. Here, we get the opportunity to perform some cleanup if oFono
+ * was killed. */
+static void ofono_signal_name_owner_changed(GDBusConnection *conn, const gchar *sender,
+		const gchar *path, const gchar *interface, const gchar *signal, GVariant *params,
+		void *userdata) {
+	(void)conn;
+	(void)sender;
+	(void)path;
+	(void)interface;
+	(void)signal;
+	(void)userdata;
+
+	const char *name;
+	const char *owner_old;
+	const char *owner_new;
+
+	g_variant_get(params, "(&s&s&s)", &name, &owner_old, &owner_new);
+
+	if (owner_old != NULL && owner_old[0] != '\0') {
+		g_dbus_connection_unregister_object(conn, dbus_agent_object_id);
+		ofono_remove_all_cards();
+	}
+	if (owner_new != NULL && owner_new[0] != '\0')
+		ofono_register();
+
+}
+
+/**
+ * Subscribe to oFono signals.
+ *
+ * @return On success this function returns 0. Otherwise -1 is returned. */
+int ofono_subscribe_signals(void) {
+
+	if (!config.enable.hfp_ofono)
+		return 0;
+
+	GDBusConnection *conn = config.dbus;
+
+	g_dbus_connection_signal_subscribe(conn, OFONO_SERVICE, OFONO_IFACE_HF_AUDIO_MANAGER,
+			"CardAdded", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
+			ofono_signal_card_added, NULL, NULL);
+	g_dbus_connection_signal_subscribe(conn, OFONO_SERVICE, OFONO_IFACE_HF_AUDIO_MANAGER,
+			"CardRemoved", NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE,
+			ofono_signal_card_removed, NULL, NULL);
+
+	g_dbus_connection_signal_subscribe(conn, "org.freedesktop.DBus", "org.freedesktop.DBus",
+			"NameOwnerChanged", NULL, OFONO_SERVICE, G_DBUS_SIGNAL_FLAGS_NONE,
+			ofono_signal_name_owner_changed, NULL, NULL);
+
+	return 0;
+}
diff --git a/src/ofono.h b/src/ofono.h
new file mode 100644
index 0000000..9d3a82b
--- /dev/null
+++ b/src/ofono.h
@@ -0,0 +1,17 @@
+/*
+ * BlueALSA - ofono.h
+ * Copyright (c) 2018 Thierry Bultel (thierry.bultel@iot.bzh)
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#ifndef BLUEALSA_OFONO_H_
+#define BLUEALSA_OFONO_H_
+
+int ofono_register(void);
+int ofono_subscribe_signals(void);
+
+#endif
diff --git a/src/rfcomm.c b/src/rfcomm.c
index 1b68b48..a86ae61 100644
--- a/src/rfcomm.c
+++ b/src/rfcomm.c
@@ -238,7 +238,7 @@ static int rfcomm_handler_ciev_resp_cb(struct rfcomm_conn *c, const struct bt_at
 		switch (c->hfp_ind_map[index - 1]) {
 		case HFP_IND_CALL:
 		case HFP_IND_CALLSETUP:
-			transport_send_signal(t->rfcomm.sco, TRANSPORT_PCM_OPEN);
+			transport_send_signal(t->rfcomm.sco, TRANSPORT_BT_OPEN);
 			break;
 		case HFP_IND_BATTCHG:
 			device_set_battery_level(t->device, value * 100 / 5);
@@ -316,7 +316,8 @@ static int rfcomm_handler_vgm_set_cb(struct rfcomm_conn *c, const struct bt_at *
 	if (rfcomm_write_at(fd, AT_TYPE_RESP, NULL, "OK") == -1)
 		return -1;
 
-	bluealsa_ctl_event(BA_EVENT_UPDATE_VOLUME);
+	bluealsa_ctl_send_event(BA_EVENT_VOLUME_CHANGED, &t->device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_CAPTURE);
 	return 0;
 }
 
@@ -330,7 +331,8 @@ static int rfcomm_handler_vgs_set_cb(struct rfcomm_conn *c, const struct bt_at *
 	if (rfcomm_write_at(fd, AT_TYPE_RESP, NULL, "OK") == -1)
 		return -1;
 
-	bluealsa_ctl_event(BA_EVENT_UPDATE_VOLUME);
+	bluealsa_ctl_send_event(BA_EVENT_VOLUME_CHANGED, &t->device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK);
 	return 0;
 }
 
@@ -374,7 +376,8 @@ static int rfcomm_handler_resp_bcs_ok_cb(struct rfcomm_conn *c, const struct bt_
 	/* When codec selection is completed, notify connected clients, that
 	 * transport has been changed. Note, that this event might be emitted
 	 * for an active transport - codec switching. */
-	bluealsa_ctl_event(BA_EVENT_TRANSPORT_CHANGED);
+	bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &c->t->device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
 	return 0;
 }
 
@@ -552,7 +555,7 @@ void *rfcomm_thread(void *arg) {
 	struct ba_transport *t = (struct ba_transport *)arg;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
-	pthread_cleanup_push(transport_pthread_cleanup, t);
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
 	/* initialize structure used for synchronization */
 	struct rfcomm_conn conn = {
@@ -618,6 +621,7 @@ void *rfcomm_thread(void *arg) {
 						conn.handler = &rfcomm_handler_resp_ok;
 						break;
 					}
+					/* fall-through */
 				case HFP_SLC_BAC_SET_OK:
 					if (rfcomm_write_at(pfds[1].fd, AT_TYPE_CMD_TEST, "+CIND", NULL) == -1)
 						goto ioerror;
@@ -643,15 +647,19 @@ void *rfcomm_thread(void *arg) {
 					break;
 				case HFP_SLC_CMER_SET_OK:
 					rfcomm_set_hfp_state(&conn, HFP_SLC_CONNECTED);
+					/* fall-through */
 				case HFP_SLC_CONNECTED:
 					if (t->rfcomm.hfp_features & HFP_AG_FEAT_CODEC)
 						break;
+					/* fall-through */
 				case HFP_CC_BCS_SET:
 				case HFP_CC_BCS_SET_OK:
 				case HFP_CC_CONNECTED:
 					rfcomm_set_hfp_state(&conn, HFP_CONNECTED);
+					/* fall-through */
 				case HFP_CONNECTED:
-					bluealsa_ctl_event(BA_EVENT_TRANSPORT_ADDED);
+					bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &t->device->addr,
+							BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
 				}
 
 			if (t->profile == BLUETOOTH_PROFILE_HFP_AG)
@@ -667,6 +675,7 @@ void *rfcomm_thread(void *arg) {
 					break;
 				case HFP_SLC_CMER_SET_OK:
 					rfcomm_set_hfp_state(&conn, HFP_SLC_CONNECTED);
+					/* fall-through */
 				case HFP_SLC_CONNECTED:
 					if (t->rfcomm.hfp_features & HFP_HF_FEAT_CODEC) {
 						if (rfcomm_write_at(pfds[1].fd, AT_TYPE_RESP, "+BCS", "1") == -1)
@@ -675,12 +684,15 @@ void *rfcomm_thread(void *arg) {
 						conn.handler = &rfcomm_handler_bcs_set;
 						break;
 					}
+					/* fall-through */
 				case HFP_CC_BCS_SET:
 				case HFP_CC_BCS_SET_OK:
 				case HFP_CC_CONNECTED:
 					rfcomm_set_hfp_state(&conn, HFP_CONNECTED);
+					/* fall-through */
 				case HFP_CONNECTED:
-					bluealsa_ctl_event(BA_EVENT_TRANSPORT_ADDED);
+					bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &t->device->addr,
+							BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
 				}
 
 			if (conn.handler != NULL) {
@@ -701,6 +713,8 @@ void *rfcomm_thread(void *arg) {
 			debug("RFCOMM poll timeout");
 			continue;
 		case -1:
+			if (errno == EINTR)
+				continue;
 			error("RFCOMM poll error: %s", strerror(errno));
 			goto fail;
 		}
diff --git a/src/shared/ctl-client.c b/src/shared/ctl-client.c
index b3eb6cb..320b0e6 100644
--- a/src/shared/ctl-client.c
+++ b/src/shared/ctl-client.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - ctl-client.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -32,6 +32,10 @@ static int bluealsa_status_to_errno(const struct ba_msg_status *status) {
 		return EIO;
 	case BA_STATUS_CODE_DEVICE_NOT_FOUND:
 		return ENODEV;
+	case BA_STATUS_CODE_STREAM_NOT_FOUND:
+		return ENXIO;
+	case BA_STATUS_CODE_CODEC_NOT_SELECTED:
+		return ENOENT;
 	case BA_STATUS_CODE_DEVICE_BUSY:
 		return EBUSY;
 	case BA_STATUS_CODE_FORBIDDEN:
@@ -122,7 +126,7 @@ int bluealsa_open(const char *interface) {
  *   In order to cancel subscription, use empty event mask.
  * @return Upon success this function returns 0. Otherwise, -1 is returned
  *   and errno is set appropriately. */
-int bluealsa_subscribe(int fd, enum ba_event mask) {
+int bluealsa_event_subscribe(int fd, uint8_t mask) {
 	const struct ba_request req = {
 		.command = BA_COMMAND_SUBSCRIBE,
 		.events = mask,
@@ -131,6 +135,24 @@ int bluealsa_subscribe(int fd, enum ba_event mask) {
 	return bluealsa_send_request(fd, &req);
 }
 
+/**
+ * Check whether event matches given transport.
+ *
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @parem event Address to the event structure.
+ * @return This function returns 0 when event matches given transport,
+ *   and any other value otherwise. */
+int bluealsa_event_match(const struct ba_msg_transport *transport,
+		const struct ba_msg_event *event) {
+	int ret;
+	if ((ret = bacmp(&transport->addr, &event->addr)) != 0)
+		return ret;
+	if ((ret = BA_PCM_TYPE(transport->type) - BA_PCM_TYPE(event->type)) != 0)
+		return ret;
+	return transport->type - (transport->type & event->type);
+}
+
 /**
  * Get the list of connected Bluetooth devices.
  *
@@ -193,101 +215,132 @@ ssize_t bluealsa_get_transports(int fd, struct ba_msg_transport **transports) {
  * Get PCM transport.
  *
  * @param fd Opened socket file descriptor.
- * @param addr MAC address of the Bluetooth device.
- * @param type PCM type to get.
- * @param stream Stream direction to get, e.g. playback or capture.
- * @return Upon success this function returns pointer to the newly allocated
- *   transport structure, which should be freed with free(). Otherwise, NULL
- *   is returned and errno is set appropriately. */
-struct ba_msg_transport *bluealsa_get_transport(int fd, bdaddr_t addr,
-		enum ba_pcm_type type, enum ba_pcm_stream stream) {
-
-	struct ba_msg_transport *transport;
+ * @param addr Pointer to the Bluetooth address structure.
+ * @param type PCM type (with stream direction) to get.
+ * @param transport An address where the transport will be stored.
+ * @return Upon success this function returns 0. Otherwise, -1 is returned
+ *   and errno is set appropriately. */
+int bluealsa_get_transport(int fd, const bdaddr_t *addr, uint8_t type,
+		struct ba_msg_transport *transport) {
+
 	struct ba_msg_status status = { 0xAB };
 	struct ba_request req = {
 		.command = BA_COMMAND_TRANSPORT_GET,
-		.addr = addr,
+		.addr = *addr,
 		.type = type,
-		.stream = stream,
 	};
 	ssize_t len;
 
 #if DEBUG
 	char addr_[18];
 	ba2str_(&req.addr, addr_);
-	debug("Getting transport for %s type %d", addr_, type);
+	debug("Getting transport for %s type %#x", addr_, type);
 #endif
 
-	if ((transport = malloc(sizeof(*transport))) == NULL)
-		return NULL;
-
 	if (send(fd, &req, sizeof(req), MSG_NOSIGNAL) == -1)
-		return NULL;
+		return -1;
 	if ((len = read(fd, transport, sizeof(*transport))) == -1)
-		return NULL;
+		return -1;
 
 	/* in case of error, status message is returned */
 	if (len != sizeof(*transport)) {
 		memcpy(&status, transport, sizeof(status));
 		errno = bluealsa_status_to_errno(&status);
-		return NULL;
+		return -1;
 	}
 
 	if (read(fd, &status, sizeof(status)) == -1)
-		return NULL;
+		return -1;
+
+	/* For SCO transport, server will report that both streaming directions are
+	 * possible. Then, when one will use such a transport structure for opening
+	 * PCM, it will be ambiguous which PCM to open. In order to prevent such a
+	 * scenario, update transport type with the requested one. */
+	transport->type = type;
 
-	return transport;
+	return 0;
 }
 
 /**
  * Get PCM transport delay.
  *
- * Note:
- * In fact, it is an alternative implementation of bluealsa_get_transport(),
- * which does not facilitates malloc().
+ * @param fd Opened socket file descriptor.
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @param delay An address where the transport delay will be stored.
+ * @return Upon success this function returns 0. Otherwise, -1 is returned
+ *   and errno is set appropriately. */
+int bluealsa_get_transport_delay(int fd, const struct ba_msg_transport *transport,
+		unsigned int *delay) {
+
+	struct ba_msg_transport t;
+	int ret;
+
+	if ((ret = bluealsa_get_transport(fd, &transport->addr,
+					transport->type, &t)) == 0)
+		*delay = t.delay;
+
+	return ret;
+}
+
+/**
+ * Set PCM transport delay.
  *
  * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
- * @return Upon success this function returns transport delay. Otherwise,
- *   -1 is returned and errno is set appropriately. */
-int bluealsa_get_transport_delay(int fd, const struct ba_msg_transport *transport) {
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @param delay Transport delay.
+ * @return Upon success this function returns 0. Otherwise, -1 is returned
+ *   and errno is set appropriately. */
+int bluealsa_set_transport_delay(int fd, const struct ba_msg_transport *transport,
+		unsigned int delay) {
 
-	struct ba_msg_status status = { 0xAB };
-	struct ba_msg_transport _transport;
 	struct ba_request req = {
-		.command = BA_COMMAND_TRANSPORT_GET,
+		.command = BA_COMMAND_TRANSPORT_SET_DELAY,
 		.addr = transport->addr,
 		.type = transport->type,
-		.stream = transport->stream,
+		.delay = delay,
 	};
-	ssize_t len;
 
-	if (send(fd, &req, sizeof(req), MSG_NOSIGNAL) == -1)
-		return -1;
-	if ((len = read(fd, &_transport, sizeof(_transport))) == -1)
-		return -1;
+	return bluealsa_send_request(fd, &req);
+}
 
-	/* in case of error, status message is returned */
-	if (len != sizeof(_transport)) {
-		memcpy(&status, &_transport, sizeof(status));
-		errno = bluealsa_status_to_errno(&status);
-		return -1;
+/**
+ * Get PCM transport volume.
+ *
+ * @param fd Opened socket file descriptor.
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @param ch1_muted An address where the mute of channel 1 will be stored.
+ * @param ch1_volume An address where the volume of channel 1 will be stored.
+ * @param ch2_muted An address where the mute of channel 2 will be stored.
+ * @param ch2_volume An address where the volume of channel 2 will be stored.
+ * @return Upon success this function returns 0. Otherwise, -1 is returned
+ *   and errno is set appropriately. */
+int bluealsa_get_transport_volume(int fd, const struct ba_msg_transport *transport,
+		bool *ch1_muted, int *ch1_volume, bool *ch2_muted, int *ch2_volume) {
+
+	struct ba_msg_transport t;
+	int ret;
+
+	if ((ret = bluealsa_get_transport(fd, &transport->addr,
+					transport->type, &t)) == 0) {
+		*ch1_muted = t.ch1_muted;
+		*ch1_volume = t.ch1_volume;
+		*ch2_muted = t.ch2_muted;
+		*ch2_volume = t.ch2_volume;
 	}
 
-	if (read(fd, &status, sizeof(status)) == -1)
-		return -1;
-
-	return _transport.delay;
+	return ret;
 }
 
 /**
  * Set PCM transport volume.
  *
  * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
- * @param ch1_muted It true, mute channel 1.
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @param ch1_muted If true, mute channel 1.
  * @param ch1_volume Channel 1 volume in range [0, 127].
  * @param ch2_muted If true, mute channel 2.
  * @param ch2_volume Channel 2 volume in range [0, 127].
@@ -300,7 +353,6 @@ int bluealsa_set_transport_volume(int fd, const struct ba_msg_transport *transpo
 		.command = BA_COMMAND_TRANSPORT_SET_VOLUME,
 		.addr = transport->addr,
 		.type = transport->type,
-		.stream = transport->stream,
 		.ch1_muted = ch1_muted,
 		.ch1_volume = ch1_volume,
 		.ch2_muted = ch2_muted,
@@ -314,8 +366,8 @@ int bluealsa_set_transport_volume(int fd, const struct ba_msg_transport *transpo
  * Open PCM transport.
  *
  * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
  * @return PCM FIFO file descriptor, or -1 on error. */
 int bluealsa_open_transport(int fd, const struct ba_msg_transport *transport) {
 
@@ -324,7 +376,6 @@ int bluealsa_open_transport(int fd, const struct ba_msg_transport *transport) {
 		.command = BA_COMMAND_PCM_OPEN,
 		.addr = transport->addr,
 		.type = transport->type,
-		.stream = transport->stream,
 	};
 	char buf[256] = "";
 	struct iovec io = {
@@ -366,76 +417,30 @@ int bluealsa_open_transport(int fd, const struct ba_msg_transport *transport) {
 }
 
 /**
- * Close PCM transport.
- *
- * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
- * @return Upon success this function returns 0. Otherwise, -1 is returned. */
-int bluealsa_close_transport(int fd, const struct ba_msg_transport *transport) {
-
-	struct ba_request req = {
-		.command = BA_COMMAND_PCM_CLOSE,
-		.addr = transport->addr,
-		.type = transport->type,
-		.stream = transport->stream,
-	};
-
-#if DEBUG
-	char addr_[18];
-	ba2str_(&req.addr, addr_);
-	debug("Closing PCM for %s", addr_);
-#endif
-
-	return bluealsa_send_request(fd, &req);
-}
-
-/**
- * Pause/resume PCM transport.
- *
- * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
- * @param pause If non-zero, pause transport, otherwise resume it.
- * @return Upon success this function returns 0. Otherwise, -1 is returned. */
-int bluealsa_pause_transport(int fd, const struct ba_msg_transport *transport, bool pause) {
-
-	struct ba_request req = {
-		.command = pause ? BA_COMMAND_PCM_PAUSE : BA_COMMAND_PCM_RESUME,
-		.addr = transport->addr,
-		.type = transport->type,
-		.stream = transport->stream,
-	};
-
-#if DEBUG
-	char addr_[18];
-	ba2str_(&req.addr, addr_);
-	debug("Requesting PCM %s for %s", pause ? "pause" : "resume", addr_);
-#endif
-
-	return bluealsa_send_request(fd, &req);
-}
-
-/**
- * Drain PCM transport.
+ * Control opened PCM transport.
  *
  * @param fd Opened socket file descriptor.
- * @param transport Address to the transport structure with the addr, type
- *   and stream fields set - other fields are not used by this function.
+ * @param transport Address to the transport structure with the addr and
+ *   type fields set - other fields are not used by this function.
+ * @param cmd PCM control command, one of: PAUSE, RESUME, DRAIN, DROP.
  * @return Upon success this function returns 0. Otherwise, -1 is returned. */
-int bluealsa_drain_transport(int fd, const struct ba_msg_transport *transport) {
+int bluealsa_control_transport(int fd, const struct ba_msg_transport *transport, enum ba_command cmd) {
 
 	struct ba_request req = {
-		.command = BA_COMMAND_PCM_DRAIN,
+		.command = cmd,
 		.addr = transport->addr,
 		.type = transport->type,
-		.stream = transport->stream,
 	};
 
 #if DEBUG
+	static const char *desc[] = {
+		[BA_COMMAND_PCM_PAUSE] = "pause",
+		[BA_COMMAND_PCM_RESUME] = "resume",
+		[BA_COMMAND_PCM_DRAIN] = "drain",
+		[BA_COMMAND_PCM_DROP] = "drop" };
 	char addr_[18];
 	ba2str_(&req.addr, addr_);
-	debug("Requesting PCM drain for %s", addr_);
+	debug("Requesting PCM %s for %s", desc[cmd], addr_);
 #endif
 
 	return bluealsa_send_request(fd, &req);
@@ -445,18 +450,18 @@ int bluealsa_drain_transport(int fd, const struct ba_msg_transport *transport) {
  * Send RFCOMM message.
  *
  * @param fd Opened socket file descriptor.
- * @param addr MAC address of the Bluetooth device.
+ * @param addr Pointer to the Bluetooth address structure.
  * @param command NULL-terminated command string.
  * @return Upon success this function returns 0. Otherwise, -1 is returned. */
-int bluealsa_send_rfcomm_command(int fd, bdaddr_t addr, const char *command) {
+int bluealsa_send_rfcomm_command(int fd, const bdaddr_t *addr, const char *command) {
 
 	struct ba_request req = {
 		.command = BA_COMMAND_RFCOMM_SEND,
-		.addr = addr,
+		.addr = *addr,
 	};
 
-	/* snprintf() guarantees terminating NULL character */
-	snprintf(req.rfcomm_command, sizeof(req.rfcomm_command), "%s", command);
+	strncpy(req.rfcomm_command, command, sizeof(req.rfcomm_command));
+	req.rfcomm_command[sizeof(req.rfcomm_command) - 1] = '\0';
 
 #if DEBUG
 	char addr_[18];
diff --git a/src/shared/ctl-client.h b/src/shared/ctl-client.h
index 8055af4..3475658 100644
--- a/src/shared/ctl-client.h
+++ b/src/shared/ctl-client.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - ctl-client.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -16,24 +16,29 @@
 
 int bluealsa_open(const char *interface);
 
-int bluealsa_subscribe(int fd, enum ba_event mask);
+int bluealsa_event_subscribe(int fd, uint8_t mask);
+int bluealsa_event_match(const struct ba_msg_transport *transport,
+		const struct ba_msg_event *event);
 
 ssize_t bluealsa_get_devices(int fd, struct ba_msg_device **devices);
 ssize_t bluealsa_get_transports(int fd, struct ba_msg_transport **transports);
 
-struct ba_msg_transport *bluealsa_get_transport(int fd, bdaddr_t addr,
-		enum ba_pcm_type type, enum ba_pcm_stream stream);
+int bluealsa_get_transport(int fd, const bdaddr_t *addr, uint8_t type,
+		struct ba_msg_transport *transport);
 
-int bluealsa_get_transport_delay(int fd, const struct ba_msg_transport *transport);
+int bluealsa_get_transport_delay(int fd, const struct ba_msg_transport *transport,
+		unsigned int *delay);
+int bluealsa_set_transport_delay(int fd, const struct ba_msg_transport *transport,
+		unsigned int delay);
 
+int bluealsa_get_transport_volume(int fd, const struct ba_msg_transport *transport,
+		bool *ch1_muted, int *ch1_volume, bool *ch2_muted, int *ch2_volume);
 int bluealsa_set_transport_volume(int fd, const struct ba_msg_transport *transport,
 		bool ch1_muted, int ch1_volume, bool ch2_muted, int ch2_volume);
 
 int bluealsa_open_transport(int fd, const struct ba_msg_transport *transport);
-int bluealsa_close_transport(int fd, const struct ba_msg_transport *transport);
-int bluealsa_pause_transport(int fd, const struct ba_msg_transport *transport, bool pause);
-int bluealsa_drain_transport(int fd, const struct ba_msg_transport *transport);
+int bluealsa_control_transport(int fd, const struct ba_msg_transport *transport, enum ba_command cmd);
 
-int bluealsa_send_rfcomm_command(int fd, bdaddr_t addr, const char *command);
+int bluealsa_send_rfcomm_command(int fd, const bdaddr_t *addr, const char *command);
 
 #endif
diff --git a/src/shared/ctl-proto.h b/src/shared/ctl-proto.h
index ebfe353..f9b2b62 100644
--- a/src/shared/ctl-proto.h
+++ b/src/shared/ctl-proto.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - ctl-proto.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -12,7 +12,7 @@
 #define BLUEALSA_SHARED_CTLPROTO_H_
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <stdint.h>
@@ -21,7 +21,7 @@
 /* Location where the control socket and pipes are stored. */
 #define BLUEALSA_RUN_STATE_DIR RUN_STATE_DIR "/bluealsa"
 /* Version of the controller communication protocol. */
-#define BLUEALSA_CRL_PROTO_VERSION 0x0100
+#define BLUEALSA_CRL_PROTO_VERSION 0x0500
 
 enum ba_command {
 	BA_COMMAND_PING,
@@ -29,12 +29,13 @@ enum ba_command {
 	BA_COMMAND_LIST_DEVICES,
 	BA_COMMAND_LIST_TRANSPORTS,
 	BA_COMMAND_TRANSPORT_GET,
+	BA_COMMAND_TRANSPORT_SET_DELAY,
 	BA_COMMAND_TRANSPORT_SET_VOLUME,
 	BA_COMMAND_PCM_OPEN,
-	BA_COMMAND_PCM_CLOSE,
 	BA_COMMAND_PCM_PAUSE,
 	BA_COMMAND_PCM_RESUME,
 	BA_COMMAND_PCM_DRAIN,
+	BA_COMMAND_PCM_DROP,
 	BA_COMMAND_RFCOMM_SEND,
 	__BA_COMMAND_MAX
 };
@@ -43,17 +44,18 @@ enum ba_status_code {
 	BA_STATUS_CODE_SUCCESS = 0,
 	BA_STATUS_CODE_ERROR_UNKNOWN,
 	BA_STATUS_CODE_DEVICE_NOT_FOUND,
+	BA_STATUS_CODE_STREAM_NOT_FOUND,
+	BA_STATUS_CODE_CODEC_NOT_SELECTED,
 	BA_STATUS_CODE_DEVICE_BUSY,
 	BA_STATUS_CODE_FORBIDDEN,
-	BA_STATUS_CODE_PONG,
 };
 
 enum ba_event {
 	BA_EVENT_TRANSPORT_ADDED   = 1 << 0,
 	BA_EVENT_TRANSPORT_CHANGED = 1 << 1,
 	BA_EVENT_TRANSPORT_REMOVED = 1 << 2,
-	BA_EVENT_UPDATE_BATTERY    = 1 << 3,
-	BA_EVENT_UPDATE_VOLUME     = 1 << 4,
+	BA_EVENT_VOLUME_CHANGED    = 1 << 3,
+	BA_EVENT_BATTERY           = 1 << 4,
 };
 
 enum ba_pcm_type {
@@ -62,15 +64,17 @@ enum ba_pcm_type {
 	BA_PCM_TYPE_SCO,
 };
 
-enum ba_pcm_stream {
-	BA_PCM_STREAM_PLAYBACK,
-	BA_PCM_STREAM_CAPTURE,
-	/* Special stream type returned by the LIST_TRANSPORTS command to indicate,
-	 * that given transport can act as a playback and capture device. In order
-	 * to open PCM for such a transport, one has to provide one of PLAYBACK or
-	 * CAPTURE stream types. */
-	BA_PCM_STREAM_DUPLEX,
-};
+#define BA_PCM_STREAM_PLAYBACK (1 << 6)
+#define BA_PCM_STREAM_CAPTURE  (1 << 7)
+
+/**
+ * Bit mask for extracting actual PCM type enum value from the
+ * transport type field defined in the message structures. */
+#define BA_PCM_TYPE_MASK 0x3F
+
+/**
+ * Extract PCM type enum from the given value. */
+#define BA_PCM_TYPE(v) ((v) & BA_PCM_TYPE_MASK)
 
 struct __attribute__ ((packed)) ba_request {
 
@@ -78,22 +82,33 @@ struct __attribute__ ((packed)) ba_request {
 
 	/* selected device address */
 	bdaddr_t addr;
+	/* selected transport type */
+	uint8_t type;
 
-	/* requested transport type */
-	enum ba_pcm_type type;
-	enum ba_pcm_stream stream;
+	union {
 
-	/* bit-mask with event subscriptions */
-	enum ba_event events;
+		/* bit-mask with event subscriptions
+		 * used by BA_COMMAND_SUBSCRIBE */
+		enum ba_event events;
 
-	/* fields used by the TRANSPORT_SET_VOLUME command */
-	uint8_t ch1_muted:1;
-	uint8_t ch1_volume:7;
-	uint8_t ch2_muted:1;
-	uint8_t ch2_volume:7;
+		/* transport delay
+		 * used by BA_COMMAND_TRANSPORT_SET_DELAY */
+		uint16_t delay;
+
+		/* transport volume fields
+		 * used by BA_COMMAND_TRANSPORT_SET_VOLUME */
+		struct {
+			uint8_t ch1_muted:1;
+			uint8_t ch1_volume:7;
+			uint8_t ch2_muted:1;
+			uint8_t ch2_volume:7;
+		};
+
+		/* RFCOMM command string to send
+		 * used by BA_COMMAND_RFCOMM_SEND */
+		char rfcomm_command[32];
 
-	/* RFCOMM command string to send */
-	char rfcomm_command[32];
+	};
 
 };
 
@@ -107,7 +122,11 @@ struct __attribute__ ((packed)) ba_msg_status {
 
 struct __attribute__ ((packed)) ba_msg_event {
 	/* bit-mask with events */
-	enum ba_event mask;
+	uint8_t events;
+	/* device address for which event occurred */
+	bdaddr_t addr;
+	/* transport type for which event occurred */
+	uint8_t type;
 };
 
 struct __attribute__ ((packed)) ba_msg_device {
@@ -126,18 +145,17 @@ struct __attribute__ ((packed)) ba_msg_device {
 
 struct __attribute__ ((packed)) ba_msg_transport {
 
-	/* device address for which the transport is created */
+	/* device address */
 	bdaddr_t addr;
-
-	/* selected profile and audio codec */
-	enum ba_pcm_type type;
-	enum ba_pcm_stream stream;
-	uint8_t codec;
+	/* transport type */
+	uint8_t type;
+	/* selected audio codec */
+	uint16_t codec;
 
 	/* number of audio channels */
 	uint8_t channels;
 	/* used sampling frequency */
-	uint16_t sampling;
+	uint32_t sampling;
 
 	/* Levels for channel 1 (left) and 2 (right). These fields are also
 	 * used for SCO. In such a case channel 1 and 2 is responsible for
diff --git a/src/shared/defs.h b/src/shared/defs.h
index bdaeac6..5cebfa4 100644
--- a/src/shared/defs.h
+++ b/src/shared/defs.h
@@ -11,6 +11,8 @@
 #ifndef BLUEALSA_SHARED_DEFS_H_
 #define BLUEALSA_SHARED_DEFS_H_
 
+#include <string.h>
+
 /**
  * Convenient macro for getting "on the stack" array size. */
 #define ARRAYSIZE(a) (sizeof(a) / sizeof(*(a)))
diff --git a/src/shared/log.c b/src/shared/log.c
index 985fc7c..65f0fea 100644
--- a/src/shared/log.c
+++ b/src/shared/log.c
@@ -50,8 +50,12 @@ static void vlog(int priority, const char *format, va_list ap) {
 	 * has to be temporally disabled. */
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate);
 
-	if (_syslog)
-		vsyslog(priority, format, ap);
+	if (_syslog) {
+		va_list ap_syslog;
+		va_copy(ap_syslog, ap);
+		vsyslog(priority, format, ap_syslog);
+		va_end(ap_syslog);
+	}
 
 	flockfile(stderr);
 
@@ -136,7 +140,7 @@ static int printf_arginfo(const struct printf_info *info, size_t n, int *argtype
 	return *size = 1;
 }
 
-static int printf_output(FILE *stream, const struct printf_info *info, const void *const *args) {
+static int printf_output(FILE *stream, const struct printf_info *info, const void * const *args) {
 
 	unsigned int v = *(unsigned int *)(args[0]);
 	bool output = false;
diff --git a/src/shared/log.h b/src/shared/log.h
index 74a701b..8b0c285 100644
--- a/src/shared/log.h
+++ b/src/shared/log.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - log.h
- * Copyright (c) 2016-2017 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -12,7 +12,7 @@
 #define BLUEALSA_SHARED_LOG_H_
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <stdbool.h>
@@ -31,9 +31,9 @@ void info(const char *format, ...) __attribute__ ((format(printf, 1, 2)));
 
 #if DEBUG
 void _debug(const char *format, ...) __attribute__ ((format(printf, 1, 2)));
-# define debug(M, ARGS...) _debug("%s:%d: " M, __FILE__, __LINE__, ## ARGS)
+# define debug(M, ARGS ...) _debug("%s:%d: " M, __FILE__, __LINE__, ## ARGS)
 #else
-# define debug(M, ARGS...) do {} while (0)
+# define debug(M, ARGS ...) do {} while (0)
 #endif
 
 #if DEBUG
diff --git a/src/shared/rt.h b/src/shared/rt.h
index 7d9f447..ec4c29e 100644
--- a/src/shared/rt.h
+++ b/src/shared/rt.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - rt.h
- * Copyright (c) 2016-2017 Arkadiusz Bokowy
+ * Copyright (c) 2016-2018 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -45,12 +45,21 @@ struct asrsync {
 /**
  * Start (initialize) time synchronization.
  *
- * @param asrs Time synchronization structure.
+ * @param asrs Pointer to the time synchronization structure.
  * @param sr Synchronization sampling rate. */
-#define asrsync_init(asrs, sr) do { asrs.rate = sr; asrs.frames = 0; \
-	gettimestamp(&asrs.ts0); asrs.ts = asrs.ts0; } while(0)
+#define asrsync_init(asrs, sr) do { \
+		(asrs)->rate = sr; \
+		gettimestamp(&(asrs)->ts0); \
+		(asrs)->ts = (asrs)->ts0; \
+		(asrs)->frames = 0; \
+	} while (0)
 
-int asrsync_sync(struct asrsync *asr, unsigned int frames);
+int asrsync_sync(struct asrsync *asrs, unsigned int frames);
+
+/**
+ * Get the number of microseconds spent outside of the sync function. */
+#define asrsync_get_busy_usec(asrs) \
+	((asrs)->ts_busy.tv_nsec / 1000)
 
 /**
  * Get system monotonic time-stamp.
diff --git a/src/transport.c b/src/transport.c
index b574538..51abbf5 100644
--- a/src/transport.c
+++ b/src/transport.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - transport.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,7 +8,6 @@
  *
  */
 
-#define _GNU_SOURCE
 #include "transport.h"
 
 #include <errno.h>
@@ -16,6 +15,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 
@@ -27,6 +27,7 @@
 
 #include "a2dp-codecs.h"
 #include "bluealsa.h"
+#include "bluez-iface.h"
 #include "ctl.h"
 #include "hfp.h"
 #include "io.h"
@@ -35,6 +36,18 @@
 #include "shared/log.h"
 
 
+static const char *transport_type_to_string(enum ba_transport_type type) {
+	switch (type) {
+	case TRANSPORT_TYPE_A2DP:
+		return "A2DP";
+	case TRANSPORT_TYPE_RFCOMM:
+		return "RFCOMM";
+	case TRANSPORT_TYPE_SCO:
+		return "SCO";
+	}
+	return "N/A";
+}
+
 static int io_thread_create(struct ba_transport *t) {
 
 	void *(*routine)(void *) = NULL;
@@ -60,6 +73,11 @@ static int io_thread_create(struct ba_transport *t) {
 			case A2DP_CODEC_VENDOR_APTX:
 				routine = io_thread_a2dp_source_aptx;
 				break;
+#endif
+#if ENABLE_LDAC
+			case A2DP_CODEC_VENDOR_LDAC:
+				routine = io_thread_a2dp_source_ldac;
+				break;
 #endif
 			default:
 				warn("Codec not supported: %u", t->codec);
@@ -100,7 +118,8 @@ static int io_thread_create(struct ba_transport *t) {
 	}
 
 	pthread_setname_np(t->thread, "baio");
-	debug("Created new IO thread: %s",
+	debug("Created new IO thread: %s: %s",
+			transport_type_to_string(t->type),
 			bluetooth_profile_to_string(t->profile));
 	return 0;
 }
@@ -159,44 +178,10 @@ void device_free(struct ba_device *d) {
 	free(d);
 }
 
-struct ba_device *device_get(GHashTable *devices, const char *key) {
-
-	struct ba_device *d;
-	char name[sizeof(d->name)];
-	GVariant *property;
-	bdaddr_t addr;
-
-	if ((d = g_hash_table_lookup(devices, key)) != NULL)
-		return d;
-
-	g_dbus_device_path_to_bdaddr(key, &addr);
-	ba2str(&addr, name);
-
-	/* get local (user editable) Bluetooth device name */
-	if ((property = g_dbus_get_property(config.dbus, "org.bluez", key,
-					"org.bluez.Device1", "Alias")) != NULL) {
-		strncpy(name, g_variant_get_string(property, NULL), sizeof(name) - 1);
-		name[sizeof(name) - 1] = '\0';
-		g_variant_unref(property);
-	}
-
-	d = device_new(config.hci_dev.dev_id, &addr, name);
-	g_hash_table_insert(devices, g_strdup(key), d);
-	return d;
-}
-
-struct ba_device *device_lookup(GHashTable *devices, const char *key) {
-	return g_hash_table_lookup(devices, key);
-}
-
-bool device_remove(GHashTable *devices, const char *key) {
-	return g_hash_table_remove(devices, key);
-}
-
 void device_set_battery_level(struct ba_device *d, uint8_t value) {
 	d->battery.enabled = true;
 	d->battery.level = value;
-	bluealsa_ctl_event(BA_EVENT_UPDATE_BATTERY);
+	bluealsa_ctl_send_event(BA_EVENT_BATTERY, &d->addr, 0);
 }
 
 /**
@@ -231,9 +216,7 @@ struct ba_transport *transport_new(
 	t->profile = profile;
 	t->codec = codec;
 
-	/* HSP supports CVSD only */
-	if (profile == BLUETOOTH_PROFILE_HSP_HS || profile == BLUETOOTH_PROFILE_HSP_AG)
-		t->codec = HFP_CODEC_CVSD;
+	pthread_mutex_init(&t->mutex, NULL);
 
 	t->state = TRANSPORT_IDLE;
 	t->thread = config.main_thread;
@@ -260,6 +243,16 @@ fail:
 	return NULL;
 }
 
+/* These acquire/release helper functions should be defined before the
+ * corresponding transport_new_* ones. However, git commit history is
+ * more important, so we're going to keep these functions at original
+ * locations and use forward declarations instead. */
+static int transport_acquire_bt_a2dp(struct ba_transport *t);
+static int transport_release_bt_a2dp(struct ba_transport *t);
+static int transport_release_bt_rfcomm(struct ba_transport *t);
+static int transport_acquire_bt_sco(struct ba_transport *t);
+static int transport_release_bt_sco(struct ba_transport *t);
+
 struct ba_transport *transport_new_a2dp(
 		struct ba_device *device,
 		const char *dbus_owner,
@@ -286,10 +279,16 @@ struct ba_transport *transport_new_a2dp(
 
 	t->a2dp.pcm.fd = -1;
 	t->a2dp.pcm.client = -1;
-	pthread_cond_init(&t->a2dp.pcm.drained, NULL);
-	pthread_mutex_init(&t->a2dp.pcm.drained_mn, NULL);
+	pthread_mutex_init(&t->a2dp.drained_mtx, NULL);
+	pthread_cond_init(&t->a2dp.drained, NULL);
+
+	t->acquire = transport_acquire_bt_a2dp;
+	t->release = transport_release_bt_a2dp;
+
+	bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_ADDED, &device->addr,
+			BA_PCM_TYPE_A2DP | (profile == BLUETOOTH_PROFILE_A2DP_SOURCE ?
+				BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE));
 
-	bluealsa_ctl_event(BA_EVENT_TRANSPORT_ADDED);
 	return t;
 }
 
@@ -307,29 +306,15 @@ struct ba_transport *transport_new_rfcomm(
 		goto fail;
 
 	dbus_path_sco = g_strdup_printf("%s/sco", dbus_path);
-	if ((t_sco = transport_new(device, TRANSPORT_TYPE_SCO,
-					dbus_owner, dbus_path_sco, profile, HFP_CODEC_UNDEFINED)) == NULL)
+	if ((t_sco = transport_new_sco(device, dbus_owner, dbus_path_sco,
+					profile, HFP_CODEC_UNDEFINED)) == NULL)
 		goto fail;
 
 	t->rfcomm.sco = t_sco;
 	t_sco->sco.rfcomm = t;
 
-	t_sco->sco.spk_gain = 15;
-	t_sco->sco.mic_gain = 15;
-
-	t_sco->sco.spk_pcm.fd = -1;
-	t_sco->sco.spk_pcm.client = -1;
-	pthread_cond_init(&t_sco->sco.spk_pcm.drained, NULL);
-	pthread_mutex_init(&t_sco->sco.spk_pcm.drained_mn, NULL);
-
-	t_sco->sco.mic_pcm.fd = -1;
-	t_sco->sco.mic_pcm.client = -1;
-	pthread_cond_init(&t_sco->sco.mic_pcm.drained, NULL);
-	pthread_mutex_init(&t_sco->sco.mic_pcm.drained_mn, NULL);
-
-	transport_set_state(t_sco, TRANSPORT_ACTIVE);
+	t->release = transport_release_bt_rfcomm;
 
-	bluealsa_ctl_event(BA_EVENT_TRANSPORT_ADDED);
 	return t;
 
 fail:
@@ -339,13 +324,53 @@ fail:
 	return NULL;
 }
 
+struct ba_transport *transport_new_sco(
+		struct ba_device *device,
+		const char *dbus_owner,
+		const char *dbus_path,
+		enum bluetooth_profile profile,
+		uint16_t codec) {
+
+	struct ba_transport *t;
+
+	/* HSP supports CVSD only */
+	if (profile == BLUETOOTH_PROFILE_HSP_HS ||
+			profile == BLUETOOTH_PROFILE_HSP_AG)
+		codec = HFP_CODEC_CVSD;
+
+	if ((t = transport_new(device, TRANSPORT_TYPE_SCO,
+					dbus_owner, dbus_path, profile, codec)) == NULL)
+		return NULL;
+
+	t->sco.spk_gain = 15;
+	t->sco.mic_gain = 15;
+
+	t->sco.spk_pcm.fd = -1;
+	t->sco.spk_pcm.client = -1;
+
+	t->sco.mic_pcm.fd = -1;
+	t->sco.mic_pcm.client = -1;
+
+	pthread_mutex_init(&t->sco.spk_drained_mtx, NULL);
+	pthread_cond_init(&t->sco.spk_drained, NULL);
+
+	t->acquire = transport_acquire_bt_sco;
+	t->release = transport_release_bt_sco;
+
+	bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_ADDED, &device->addr,
+			BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
+
+	return t;
+}
+
 void transport_free(struct ba_transport *t) {
 
 	if (t == NULL || t->state == TRANSPORT_LIMBO)
 		return;
 
 	t->state = TRANSPORT_LIMBO;
-	debug("Freeing transport: %s (%s)",
+	debug("Freeing transport: %s: %s (%s)",
+			transport_type_to_string(t->type),
 			bluetooth_profile_to_string(t->profile),
 			bluetooth_a2dp_codec_to_string(t->codec));
 
@@ -353,10 +378,7 @@ void transport_free(struct ba_transport *t) {
 	 * terminate the IO thread (or at least make sure it is not running any
 	 * more). Not doing so might result in an undefined behavior or even a
 	 * race condition (closed and reused file descriptor). */
-	if (!pthread_equal(t->thread, config.main_thread)) {
-		pthread_cancel(t->thread);
-		pthread_join(t->thread, NULL);
-	}
+	transport_pthread_cancel(t->thread);
 
 	/* if possible, try to release resources gracefully */
 	if (t->release != NULL)
@@ -369,12 +391,18 @@ void transport_free(struct ba_transport *t) {
 	if (t->sig_fd[1] != -1)
 		close(t->sig_fd[1]);
 
+	pthread_mutex_destroy(&t->mutex);
+
+	unsigned int pcm_type = BA_PCM_TYPE_NULL;
+
 	/* free type-specific resources */
 	switch (t->type) {
 	case TRANSPORT_TYPE_A2DP:
+		pcm_type = BA_PCM_TYPE_A2DP | (t->profile == BLUETOOTH_PROFILE_A2DP_SOURCE ?
+				BA_PCM_STREAM_PLAYBACK : BA_PCM_STREAM_CAPTURE);
 		transport_release_pcm(&t->a2dp.pcm);
-		pthread_cond_destroy(&t->a2dp.pcm.drained);
-		pthread_mutex_destroy(&t->a2dp.pcm.drained_mn);
+		pthread_mutex_destroy(&t->a2dp.drained_mtx);
+		pthread_cond_destroy(&t->a2dp.drained);
 		free(t->a2dp.cconfig);
 		break;
 	case TRANSPORT_TYPE_RFCOMM:
@@ -383,13 +411,13 @@ void transport_free(struct ba_transport *t) {
 		transport_free(t->rfcomm.sco);
 		break;
 	case TRANSPORT_TYPE_SCO:
+		pcm_type = BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE;
+		pthread_mutex_destroy(&t->sco.spk_drained_mtx);
+		pthread_cond_destroy(&t->sco.spk_drained);
 		transport_release_pcm(&t->sco.spk_pcm);
-		pthread_cond_destroy(&t->sco.spk_pcm.drained);
-		pthread_mutex_destroy(&t->sco.spk_pcm.drained_mn);
 		transport_release_pcm(&t->sco.mic_pcm);
-		pthread_cond_destroy(&t->sco.mic_pcm.drained);
-		pthread_mutex_destroy(&t->sco.mic_pcm.drained_mn);
-		t->sco.rfcomm->rfcomm.sco = NULL;
+		if (t->sco.rfcomm != NULL)
+			t->sco.rfcomm->rfcomm.sco = NULL;
 		break;
 	}
 
@@ -398,7 +426,8 @@ void transport_free(struct ba_transport *t) {
 	 * removed anyway. */
 	g_hash_table_steal(t->device->transports, t->dbus_path);
 
-	bluealsa_ctl_event(BA_EVENT_TRANSPORT_REMOVED);
+	if (pcm_type != BA_PCM_TYPE_NULL)
+		bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_REMOVED, &t->device->addr, pcm_type);
 
 	free(t->dbus_owner);
 	free(t->dbus_path);
@@ -407,6 +436,11 @@ void transport_free(struct ba_transport *t) {
 
 struct ba_transport *transport_lookup(GHashTable *devices, const char *dbus_path) {
 
+#if DEBUG
+	/* make sure that the device mutex is acquired */
+	g_assert(pthread_mutex_trylock(&config.devices_mutex) == EBUSY);
+#endif
+
 	GHashTableIter iter;
 	struct ba_device *d;
 	struct ba_transport *t;
@@ -420,38 +454,13 @@ struct ba_transport *transport_lookup(GHashTable *devices, const char *dbus_path
 	return NULL;
 }
 
-struct ba_transport *transport_lookup_pcm_client(GHashTable *devices, int client) {
-
-	GHashTableIter iter_d, iter_t;
-	struct ba_device *d;
-	struct ba_transport *t;
-
-	g_hash_table_iter_init(&iter_d, devices);
-	while (g_hash_table_iter_next(&iter_d, NULL, (gpointer)&d)) {
-		g_hash_table_iter_init(&iter_t, d->transports);
-		while (g_hash_table_iter_next(&iter_t, NULL, (gpointer)&t)) {
-			switch (t->type) {
-			case TRANSPORT_TYPE_A2DP:
-				if (t->a2dp.pcm.client == client)
-					return t;
-				break;
-			case TRANSPORT_TYPE_RFCOMM:
-				break;
-			case TRANSPORT_TYPE_SCO:
-				if (t->sco.spk_pcm.client == client)
-					return t;
-				if (t->sco.mic_pcm.client == client)
-					return t;
-				break;
-			}
-		}
-	}
-
-	return NULL;
-}
-
 bool transport_remove(GHashTable *devices, const char *dbus_path) {
 
+#if DEBUG
+	/* make sure that the device mutex is acquired */
+	g_assert(pthread_mutex_trylock(&config.devices_mutex) == EBUSY);
+#endif
+
 	GHashTableIter iter;
 	struct ba_device *d;
 	struct ba_transport *t;
@@ -534,6 +543,17 @@ unsigned int transport_get_channels(const struct ba_transport *t) {
 				return 2;
 			}
 			break;
+#endif
+#if ENABLE_LDAC
+		case A2DP_CODEC_VENDOR_LDAC:
+			switch (((a2dp_ldac_t *)t->a2dp.cconfig)->channel_mode) {
+			case LDAC_CHANNEL_MODE_MONO:
+				return 1;
+			case LDAC_CHANNEL_MODE_STEREO:
+			case LDAC_CHANNEL_MODE_DUAL_CHANNEL:
+				return 2;
+			}
+			break;
 #endif
 		}
 		break;
@@ -625,6 +645,24 @@ unsigned int transport_get_sampling(const struct ba_transport *t) {
 				return 48000;
 			}
 			break;
+#endif
+#if ENABLE_LDAC
+		case A2DP_CODEC_VENDOR_LDAC:
+			switch (((a2dp_ldac_t *)t->a2dp.cconfig)->frequency) {
+			case LDAC_SAMPLING_FREQ_44100:
+				return 44100;
+			case LDAC_SAMPLING_FREQ_48000:
+				return 48000;
+			case LDAC_SAMPLING_FREQ_88200:
+				return 88200;
+			case LDAC_SAMPLING_FREQ_96000:
+				return 96000;
+			case LDAC_SAMPLING_FREQ_176400:
+				return 176400;
+			case LDAC_SAMPLING_FREQ_192000:
+				return 192000;
+			}
+			break;
 #endif
 		}
 		break;
@@ -632,12 +670,14 @@ unsigned int transport_get_sampling(const struct ba_transport *t) {
 		break;
 	case TRANSPORT_TYPE_SCO:
 		switch (t->codec) {
-			case HFP_CODEC_CVSD:
-				return 8000;
-			case HFP_CODEC_MSBC:
-				return 16000;
-			default:
-				debug("Unsupported SCO codec: %#x", t->codec);
+		case HFP_CODEC_UNDEFINED:
+			break;
+		case HFP_CODEC_CVSD:
+			return 8000;
+		case HFP_CODEC_MSBC:
+			return 16000;
+		default:
+			debug("Unsupported SCO codec: %#x", t->codec);
 		}
 	}
 
@@ -645,48 +685,6 @@ unsigned int transport_get_sampling(const struct ba_transport *t) {
 	return 0;
 }
 
-int transport_set_volume(struct ba_transport *t, uint8_t ch1_muted, uint8_t ch2_muted,
-		uint8_t ch1_volume, uint8_t ch2_volume) {
-
-	debug("Setting volume for %s profile %d: %d<>%d [%c%c]", batostr_(&t->device->addr),
-			t->profile, ch1_volume, ch2_volume, ch1_muted ? 'M' : 'O', ch2_muted ? 'M' : 'O');
-
-	switch (t->type) {
-	case TRANSPORT_TYPE_A2DP:
-
-		t->a2dp.ch1_muted = ch1_muted;
-		t->a2dp.ch2_muted = ch2_muted;
-		t->a2dp.ch1_volume = ch1_volume;
-		t->a2dp.ch2_volume = ch2_volume;
-
-		if (config.a2dp.volume) {
-			uint16_t volume = (ch1_muted | ch2_muted) ? 0 : MIN(ch1_volume, ch2_volume);
-			g_dbus_set_property(config.dbus, t->dbus_owner, t->dbus_path,
-					"org.bluez.MediaTransport1", "Volume", g_variant_new_uint16(volume));
-		}
-
-		break;
-
-	case TRANSPORT_TYPE_RFCOMM:
-		break;
-
-	case TRANSPORT_TYPE_SCO:
-
-		t->sco.spk_muted = ch1_muted;
-		t->sco.mic_muted = ch2_muted;
-		t->sco.spk_gain = ch1_volume;
-		t->sco.mic_gain = ch2_volume;
-
-		/* notify associated RFCOMM transport */
-		transport_send_signal(t->sco.rfcomm, TRANSPORT_SET_VOLUME);
-
-		break;
-
-	}
-
-	return 0;
-}
-
 int transport_set_state(struct ba_transport *t, enum ba_transport_state state) {
 	debug("State transition: %d -> %d", t->state, state);
 
@@ -699,28 +697,24 @@ int transport_set_state(struct ba_transport *t, enum ba_transport_state state) {
 			t->state == TRANSPORT_IDLE && state != TRANSPORT_PENDING)
 		return 0;
 
-	const int created = !pthread_equal(t->thread, config.main_thread);
 	int ret = 0;
 
 	t->state = state;
 
 	switch (state) {
 	case TRANSPORT_IDLE:
-		if (created) {
-			pthread_cancel(t->thread);
-			ret = pthread_join(t->thread, NULL);
-		}
+		transport_pthread_cancel(t->thread);
 		break;
 	case TRANSPORT_PENDING:
 		/* When transport is marked as pending, try to acquire transport, but only
 		 * if we are handing A2DP sink profile. For source profile, transport has
 		 * to be acquired by our controller (during the PCM open request). */
 		if (t->profile == BLUETOOTH_PROFILE_A2DP_SINK)
-			ret = transport_acquire_bt_a2dp(t);
+			ret = t->acquire(t);
 		break;
 	case TRANSPORT_ACTIVE:
 	case TRANSPORT_PAUSED:
-		if (!created)
+		if (pthread_equal(t->thread, config.main_thread))
 			ret = io_thread_create(t);
 		break;
 	case TRANSPORT_LIMBO:
@@ -734,51 +728,38 @@ int transport_set_state(struct ba_transport *t, enum ba_transport_state state) {
 	return ret;
 }
 
-int transport_set_state_from_string(struct ba_transport *t, const char *state) {
-
-	if (strcmp(state, "idle") == 0)
-		transport_set_state(t, TRANSPORT_IDLE);
-	else if (strcmp(state, "pending") == 0)
-		transport_set_state(t, TRANSPORT_PENDING);
-	else if (strcmp(state, "active") == 0)
-		transport_set_state(t, TRANSPORT_ACTIVE);
-	else {
-		warn("Invalid state: %s", state);
-		return -1;
-	}
-
-	return 0;
-}
-
 int transport_drain_pcm(struct ba_transport *t) {
 
-	struct ba_pcm *pcm = NULL;
+	pthread_mutex_t *mutex = NULL;
+	pthread_cond_t *drained = NULL;
 
 	switch (t->profile) {
 	case BLUETOOTH_PROFILE_NULL:
 	case BLUETOOTH_PROFILE_A2DP_SINK:
 		break;
 	case BLUETOOTH_PROFILE_A2DP_SOURCE:
-		pcm = &t->a2dp.pcm;
+		mutex = &t->a2dp.drained_mtx;
+		drained = &t->a2dp.drained;
 		break;
 	case BLUETOOTH_PROFILE_HSP_AG:
 	case BLUETOOTH_PROFILE_HFP_AG:
-		pcm = &t->sco.spk_pcm;
+		mutex = &t->sco.spk_drained_mtx;
+		drained = &t->sco.spk_drained;
 		break;
 	case BLUETOOTH_PROFILE_HSP_HS:
 	case BLUETOOTH_PROFILE_HFP_HF:
 		break;
 	}
 
-	if (pcm == NULL || t->state != TRANSPORT_ACTIVE)
+	if (mutex == NULL || t->state != TRANSPORT_ACTIVE)
 		return 0;
 
-	pthread_mutex_lock(&pcm->drained_mn);
+	pthread_mutex_lock(mutex);
 
 	transport_send_signal(t, TRANSPORT_PCM_SYNC);
-	pthread_cond_wait(&pcm->drained, &pcm->drained_mn);
+	pthread_cond_wait(drained, mutex);
 
-	pthread_mutex_unlock(&pcm->drained_mn);
+	pthread_mutex_unlock(mutex);
 
 	/* TODO: Asynchronous transport release.
 	 *
@@ -794,19 +775,19 @@ int transport_drain_pcm(struct ba_transport *t) {
 	return 0;
 }
 
-int transport_acquire_bt_a2dp(struct ba_transport *t) {
+static int transport_acquire_bt_a2dp(struct ba_transport *t) {
 
 	GDBusMessage *msg, *rep;
 	GUnixFDList *fd_list;
 	GError *err = NULL;
 
+	/* Check whether transport is already acquired - keep-alive mode. */
 	if (t->bt_fd != -1) {
-		warn("Closing dangling BT socket: %d", t->bt_fd);
-		close(t->bt_fd);
-		t->bt_fd = -1;
+		debug("Reusing transport: %d", t->bt_fd);
+		goto final;
 	}
 
-	msg = g_dbus_message_new_method_call(t->dbus_owner, t->dbus_path, "org.bluez.MediaTransport1",
+	msg = g_dbus_message_new_method_call(t->dbus_owner, t->dbus_path, BLUEZ_IFACE_MEDIA_TRANSPORT,
 			t->state == TRANSPORT_PENDING ? "TryAcquire" : "Acquire");
 
 	if ((rep = g_dbus_connection_send_message_with_reply_sync(config.dbus, msg,
@@ -823,7 +804,6 @@ int transport_acquire_bt_a2dp(struct ba_transport *t) {
 
 	fd_list = g_dbus_message_get_unix_fd_list(rep);
 	t->bt_fd = g_unix_fd_list_get(fd_list, 0, &err);
-	t->release = transport_release_bt_a2dp;
 
 	/* Minimize audio delay and increase responsiveness (seeking, stopping) by
 	 * decreasing the BT socket output buffer. We will use a tripled write MTU
@@ -832,6 +812,9 @@ int transport_acquire_bt_a2dp(struct ba_transport *t) {
 	if (setsockopt(t->bt_fd, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size)) == -1)
 		warn("Couldn't set socket output buffer size: %s", strerror(errno));
 
+	if (ioctl(t->bt_fd, TIOCOUTQ, &t->a2dp.bt_fd_coutq_init) == -1)
+		warn("Couldn't get socket queued bytes: %s", strerror(errno));
+
 	debug("New transport: %d (MTU: R:%zu W:%zu)", t->bt_fd, t->mtu_read, t->mtu_write);
 
 fail:
@@ -842,10 +825,12 @@ fail:
 		error("Couldn't acquire transport: %s", err->message);
 		g_error_free(err);
 	}
+
+final:
 	return t->bt_fd;
 }
 
-int transport_release_bt_a2dp(struct ba_transport *t) {
+static int transport_release_bt_a2dp(struct ba_transport *t) {
 
 	GDBusMessage *msg = NULL, *rep = NULL;
 	GError *err = NULL;
@@ -867,7 +852,7 @@ int transport_release_bt_a2dp(struct ba_transport *t) {
 	if (t->state != TRANSPORT_IDLE && t->dbus_owner != NULL) {
 
 		msg = g_dbus_message_new_method_call(t->dbus_owner, t->dbus_path,
-				"org.bluez.MediaTransport1", "Release");
+				BLUEZ_IFACE_MEDIA_TRANSPORT, "Release");
 
 		if ((rep = g_dbus_connection_send_message_with_reply_sync(config.dbus, msg,
 						G_DBUS_SEND_MESSAGE_FLAGS_NONE, -1, NULL, NULL, &err)) == NULL)
@@ -875,7 +860,8 @@ int transport_release_bt_a2dp(struct ba_transport *t) {
 
 		if (g_dbus_message_get_message_type(rep) == G_DBUS_MESSAGE_TYPE_ERROR) {
 			g_dbus_message_to_gerror(rep, &err);
-			if (err->code == G_DBUS_ERROR_NO_REPLY) {
+			if (err->code == G_DBUS_ERROR_NO_REPLY ||
+					err->code == G_DBUS_ERROR_SERVICE_UNKNOWN) {
 				/* If BlueZ is already terminated (or is terminating), we won't receive
 				 * any response. Do not treat such a case as an error - omit logging. */
 				g_error_free(err);
@@ -890,7 +876,6 @@ int transport_release_bt_a2dp(struct ba_transport *t) {
 	debug("Closing BT: %d", t->bt_fd);
 
 	ret = 0;
-	t->release = NULL;
 	close(t->bt_fd);
 	t->bt_fd = -1;
 
@@ -906,14 +891,13 @@ fail:
 	return ret;
 }
 
-int transport_release_bt_rfcomm(struct ba_transport *t) {
+static int transport_release_bt_rfcomm(struct ba_transport *t) {
 
 	if (t->bt_fd == -1)
 		return 0;
 
 	debug("Closing RFCOMM: %d", t->bt_fd);
 
-	t->release = NULL;
 	shutdown(t->bt_fd, SHUT_RDWR);
 	close(t->bt_fd);
 	t->bt_fd = -1;
@@ -926,7 +910,7 @@ int transport_release_bt_rfcomm(struct ba_transport *t) {
 	return 0;
 }
 
-int transport_acquire_bt_sco(struct ba_transport *t) {
+static int transport_acquire_bt_sco(struct ba_transport *t) {
 
 	struct hci_dev_info di;
 
@@ -945,7 +929,6 @@ int transport_acquire_bt_sco(struct ba_transport *t) {
 
 	t->mtu_read = di.sco_mtu;
 	t->mtu_write = di.sco_mtu;
-	t->release = transport_release_bt_sco;
 
 	/* XXX: It seems, that the MTU values returned by the HCI interface
 	 *      are incorrect (or our interpretation of them is incorrect). */
@@ -957,14 +940,13 @@ int transport_acquire_bt_sco(struct ba_transport *t) {
 	return t->bt_fd;
 }
 
-int transport_release_bt_sco(struct ba_transport *t) {
+static int transport_release_bt_sco(struct ba_transport *t) {
 
 	if (t->bt_fd == -1)
 		return 0;
 
 	debug("Closing SCO: %d", t->bt_fd);
 
-	t->release = NULL;
 	shutdown(t->bt_fd, SHUT_RDWR);
 	close(t->bt_fd);
 	t->bt_fd = -1;
@@ -974,6 +956,9 @@ int transport_release_bt_sco(struct ba_transport *t) {
 
 int transport_release_pcm(struct ba_pcm *pcm) {
 
+	if (pcm->fd == -1)
+		return 0;
+
 	int oldstate;
 
 	/* Transport IO workers are managed using thread cancellation mechanism,
@@ -984,20 +969,37 @@ int transport_release_pcm(struct ba_pcm *pcm) {
 	 * going on, see the io_thread_read_pcm() function. */
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate);
 
-	if (pcm->fd != -1) {
-		debug("Closing PCM: %d", pcm->fd);
-		close(pcm->fd);
-		pcm->fd = -1;
-	}
+	debug("Closing PCM: %d", pcm->fd);
+	close(pcm->fd);
+	pcm->fd = -1;
+	pcm->client = -1;
 
 	pthread_setcancelstate(oldstate, NULL);
 	return 0;
 }
 
 /**
- * Wrapper for release callback, which can be used by the pthread cleanup. */
-void transport_pthread_cleanup(void *arg) {
-	struct ba_transport *t = (struct ba_transport *)arg;
+ * Synchronous transport thread cancellation. */
+void transport_pthread_cancel(pthread_t thread) {
+
+	if (pthread_equal(thread, pthread_self()))
+		return;
+	if (pthread_equal(thread, config.main_thread))
+		return;
+
+	int err;
+	if ((err = pthread_cancel(thread)) != 0)
+		warn("Couldn't cancel transport thread: %s", strerror(err));
+	if ((err = pthread_join(thread, NULL)) != 0)
+		warn("Couldn't join transport thread: %s", strerror(err));
+}
+
+/**
+ * Wrapper for release callback, which can be used by the pthread cleanup.
+ *
+ * This function CAN be used with transport_pthread_cleanup_lock() in order
+ * to guard transport critical section during cleanup process. */
+void transport_pthread_cleanup(struct ba_transport *t) {
 
 	/* During the normal operation mode, the release callback should not
 	 * be NULL. Hence, we will relay on this callback - file descriptors
@@ -1009,7 +1011,22 @@ void transport_pthread_cleanup(void *arg) {
 	 * be used anymore. */
 	t->thread = config.main_thread;
 
+	transport_pthread_cleanup_unlock(t);
+
 	/* XXX: If the order of the cleanup push is right, this function will
 	 *      indicate the end of the IO/RFCOMM thread. */
 	debug("Exiting IO thread");
 }
+
+int transport_pthread_cleanup_lock(struct ba_transport *t) {
+	int ret = pthread_mutex_lock(&t->mutex);
+	t->cleanup_lock = true;
+	return ret;
+}
+
+int transport_pthread_cleanup_unlock(struct ba_transport *t) {
+	if (!t->cleanup_lock)
+		return 0;
+	t->cleanup_lock = false;
+	return pthread_mutex_unlock(&t->mutex);
+}
diff --git a/src/transport.h b/src/transport.h
index 4569c31..d3e5fea 100644
--- a/src/transport.h
+++ b/src/transport.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - transport.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -11,6 +11,10 @@
 #ifndef BLUEALSA_TRANSPORT_H_
 #define BLUEALSA_TRANSPORT_H_
 
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
 #include <pthread.h>
 #include <stdbool.h>
 #include <stddef.h>
@@ -39,11 +43,13 @@ enum ba_transport_state {
 };
 
 enum ba_transport_signal {
+	TRANSPORT_BT_OPEN,
 	TRANSPORT_PCM_OPEN,
 	TRANSPORT_PCM_CLOSE,
 	TRANSPORT_PCM_PAUSE,
 	TRANSPORT_PCM_RESUME,
 	TRANSPORT_PCM_SYNC,
+	TRANSPORT_PCM_DROP,
 	TRANSPORT_SET_VOLUME,
 	TRANSPORT_SEND_RFCOMM,
 };
@@ -82,17 +88,10 @@ struct ba_device {
 };
 
 struct ba_pcm {
-
+	/* FIFO file descriptor */
 	int fd;
-
-	/* client identifier (most likely client socket file descriptor) used
-	 * by the PCM client lookup function - transport_lookup_pcm_client() */
+	/* associated client */
 	int client;
-
-	/* variables used for PCM synchronization */
-	pthread_cond_t drained;
-	pthread_mutex_t drained_mn;
-
 };
 
 struct ba_transport {
@@ -114,6 +113,10 @@ struct ba_transport {
 	enum bluetooth_profile profile;
 	uint16_t codec;
 
+	/* This mutex shall guard modifications of the critical sections in this
+	 * transport structure, e.g. thread creation/termination. */
+	pthread_mutex_t mutex;
+
 	/* IO thread - actual transport layer */
 	enum ba_transport_state state;
 	pthread_t thread;
@@ -156,6 +159,17 @@ struct ba_transport {
 			uint8_t *cconfig;
 			size_t cconfig_size;
 
+			/* Value reported by the ioctl(TIOCOUTQ) when the output buffer is
+			 * empty. Somehow this ioctl call reports "available" buffer space.
+			 * So, in order to get the number of bytes in the queue buffer, we
+			 * have to subtract the initial value from values returned by
+			 * subsequent ioctl() calls. */
+			int bt_fd_coutq_init;
+
+			/* playback synchronization */
+			pthread_mutex_t drained_mtx;
+			pthread_cond_t drained;
+
 		} a2dp;
 
 		struct {
@@ -172,6 +186,9 @@ struct ba_transport {
 
 		struct {
 
+			/* if true, SCO is handled by oFono */
+			bool ofono;
+
 			/* parent RFCOMM transport */
 			struct ba_transport *rfcomm;
 
@@ -188,11 +205,19 @@ struct ba_transport {
 			struct ba_pcm spk_pcm;
 			struct ba_pcm mic_pcm;
 
+			/* playback synchronization */
+			pthread_mutex_t spk_drained_mtx;
+			pthread_cond_t spk_drained;
+
 		} sco;
 
 	};
 
-	/* callback function for self-management */
+	/* indicates cleanup lock */
+	bool cleanup_lock;
+
+	/* callback functions for self-management */
+	int (*acquire)(struct ba_transport *);
 	int (*release)(struct ba_transport *);
 
 };
@@ -200,10 +225,6 @@ struct ba_transport {
 struct ba_device *device_new(int hci_dev_id, const bdaddr_t *addr, const char *name);
 void device_free(struct ba_device *d);
 
-struct ba_device *device_get(GHashTable *devices, const char *key);
-struct ba_device *device_lookup(GHashTable *devices, const char *key);
-bool device_remove(GHashTable *devices, const char *key);
-
 void device_set_battery_level(struct ba_device *d, uint8_t value);
 
 struct ba_transport *transport_new(
@@ -226,10 +247,15 @@ struct ba_transport *transport_new_rfcomm(
 		const char *dbus_owner,
 		const char *dbus_path,
 		enum bluetooth_profile profile);
+struct ba_transport *transport_new_sco(
+		struct ba_device *device,
+		const char *dbus_owner,
+		const char *dbus_path,
+		enum bluetooth_profile profile,
+		uint16_t codec);
 void transport_free(struct ba_transport *t);
 
 struct ba_transport *transport_lookup(GHashTable *devices, const char *dbus_path);
-struct ba_transport *transport_lookup_pcm_client(GHashTable *devices, int client);
 bool transport_remove(GHashTable *devices, const char *dbus_path);
 
 int transport_send_signal(struct ba_transport *t, enum ba_transport_signal sig);
@@ -238,24 +264,14 @@ int transport_send_rfcomm(struct ba_transport *t, const char command[32]);
 unsigned int transport_get_channels(const struct ba_transport *t);
 unsigned int transport_get_sampling(const struct ba_transport *t);
 
-int transport_set_volume(struct ba_transport *t, uint8_t ch1_muted, uint8_t ch2_muted,
-		uint8_t ch1_volume, uint8_t ch2_volume);
-
 int transport_set_state(struct ba_transport *t, enum ba_transport_state state);
-int transport_set_state_from_string(struct ba_transport *t, const char *state);
 
 int transport_drain_pcm(struct ba_transport *t);
-
-int transport_acquire_bt_a2dp(struct ba_transport *t);
-int transport_release_bt_a2dp(struct ba_transport *t);
-
-int transport_release_bt_rfcomm(struct ba_transport *t);
-
-int transport_acquire_bt_sco(struct ba_transport *t);
-int transport_release_bt_sco(struct ba_transport *t);
-
 int transport_release_pcm(struct ba_pcm *pcm);
 
-void transport_pthread_cleanup(void *arg);
+void transport_pthread_cancel(pthread_t thread);
+void transport_pthread_cleanup(struct ba_transport *t);
+int transport_pthread_cleanup_lock(struct ba_transport *t);
+int transport_pthread_cleanup_unlock(struct ba_transport *t);
 
 #endif
diff --git a/src/utils.c b/src/utils.c
index d2f97e7..70d069e 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -18,6 +18,10 @@
 #include <bluetooth/hci_lib.h>
 #include <bluetooth/sco.h>
 
+#if ENABLE_LDAC
+# include "ldacBT.h"
+#endif
+
 #include "a2dp-codecs.h"
 #include "bluez.h"
 #include "shared/log.h"
@@ -157,6 +161,10 @@ const char *g_dbus_get_profile_object_path(enum bluetooth_profile profile, uint1
 #if ENABLE_APTX
 		case A2DP_CODEC_VENDOR_APTX:
 			return "/A2DP/APTX/Source";
+#endif
+#if ENABLE_LDAC
+		case A2DP_CODEC_VENDOR_LDAC:
+			return "/A2DP/LDAC/Source";
 #endif
 		default:
 			warn("Unsupported A2DP codec: %#x", codec);
@@ -177,6 +185,10 @@ const char *g_dbus_get_profile_object_path(enum bluetooth_profile profile, uint1
 #if ENABLE_APTX
 		case A2DP_CODEC_VENDOR_APTX:
 			return "/A2DP/APTX/Sink";
+#endif
+#if ENABLE_LDAC
+		case A2DP_CODEC_VENDOR_LDAC:
+			return "/A2DP/LDAC/Sink";
 #endif
 		default:
 			warn("Unsupported A2DP codec: %#x", codec);
@@ -224,33 +236,6 @@ enum bluetooth_profile g_dbus_object_path_to_profile(const char *path) {
 	return BLUETOOTH_PROFILE_NULL;
 }
 
-/**
- * Convert BlueZ D-Bus object path into a A2DP codec.
- *
- * Prior to the usage, make sure, that the path is for the A2DP profile.
- * To do so, use the g_dbus_object_path_to_profile() function.
- *
- * @param path BlueZ D-Bus object path.
- * @return On success this function returns Bluetooth audio codec. If object
- *   path cannot be recognize, vendor codec is returned. */
-uint16_t g_dbus_object_path_to_a2dp_codec(const char *path) {
-	if (strncmp(path + 5, "/SBC", 4) == 0)
-		return A2DP_CODEC_SBC;
-#if ENABLE_MPEG
-	if (strncmp(path + 5, "/MPEG12", 7) == 0)
-		return A2DP_CODEC_MPEG12;
-#endif
-#if ENABLE_AAC
-	if (strncmp(path + 5, "/MPEG24", 7) == 0)
-		return A2DP_CODEC_MPEG24;
-#endif
-#if ENABLE_APTX
-	if (strncmp(path + 5, "/APTX", 5) == 0)
-		return A2DP_CODEC_VENDOR_APTX;
-#endif
-	return A2DP_CODEC_VENDOR;
-}
-
 /**
  * Convert BlueZ D-Bus device path into a bdaddr_t structure.
  *
@@ -591,3 +576,47 @@ const char *aacenc_strerror(AACENC_ERROR err) {
 	}
 }
 #endif
+
+#if ENABLE_LDAC
+/**
+ * Get string representation of the LDAC error code.
+ *
+ * @param error LDAC error code.
+ * @return Human-readable string. */
+const char *ldacBT_strerror(int err) {
+	switch (LDACBT_API_ERR(err)) {
+	case LDACBT_ERR_NONE:
+		return "Success";
+	case LDACBT_ERR_ASSERT_SAMPLING_FREQ:
+	case LDACBT_ERR_ASSERT_SUP_SAMPLING_FREQ:
+	case LDACBT_ERR_CHECK_SAMPLING_FREQ:
+		return "Invalid sample rate";
+	case LDACBT_ERR_ASSERT_CHANNEL_CONFIG:
+	case LDACBT_ERR_CHECK_CHANNEL_CONFIG:
+		return "Invalid channel config";
+	case LDACBT_ERR_ASSERT_FRAME_LENGTH:
+	case LDACBT_ERR_ASSERT_SUP_FRAME_LENGTH:
+	case LDACBT_ERR_ASSERT_FRAME_STATUS:
+		return "Invalid frame status";
+	case LDACBT_ERR_ASSERT_NSHIFT:
+		return "Invalid N-shift";
+	case LDACBT_ERR_ASSERT_CHANNEL_MODE:
+		return "Invalid channel mode";
+	case LDACBT_ERR_ALTER_EQMID_LIMITED:
+		return "EQMID limited";
+	case LDACBT_ERR_HANDLE_NOT_INIT:
+		return "Invalid handle";
+	case LDACBT_ERR_ILL_EQMID:
+		return "Unsupported EQMID";
+	case LDACBT_ERR_ILL_SAMPLING_FREQ:
+		return "Unsupported sample rate";
+	case LDACBT_ERR_ILL_NUM_CHANNEL:
+		return "Unsupported channels";
+	case LDACBT_ERR_ILL_MTU_SIZE:
+		return "Unsupported MTU";
+	default:
+		debug("Unknown error code: %#x", err);
+		return "Unknown error";
+	}
+}
+#endif
diff --git a/src/utils.h b/src/utils.h
index 9b203b6..bb826b7 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - utils.h
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -12,7 +12,7 @@
 #define BLUEALSA_UTILS_H_
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <stdbool.h>
@@ -35,7 +35,6 @@ const char *batostr_(const bdaddr_t *ba);
 
 const char *g_dbus_get_profile_object_path(enum bluetooth_profile profile, uint16_t codec);
 enum bluetooth_profile g_dbus_object_path_to_profile(const char *path);
-uint16_t g_dbus_object_path_to_a2dp_codec(const char *path);
 int g_dbus_device_path_to_bdaddr(const char *path, bdaddr_t *addr);
 
 GVariant *g_dbus_get_property(GDBusConnection *conn, const char *name,
@@ -54,4 +53,8 @@ const char *aacdec_strerror(AAC_DECODER_ERROR err);
 const char *aacenc_strerror(AACENC_ERROR err);
 #endif
 
+#if ENABLE_LDAC
+const char *ldacBT_strerror(int err);
+#endif
+
 #endif
diff --git a/test/Makefile.am b/test/Makefile.am
index 1c8d489..104dc63 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,37 +1,49 @@
 # BlueALSA - Makefile.am
-# Copyright (c) 2016-2017 Arkadiusz Bokowy
+# Copyright (c) 2016-2019 Arkadiusz Bokowy
 
 TESTS = \
 	test-at \
+	test-ctl \
 	test-io \
+	test-pcm \
 	test-utils
 
-if ENABLE_PCM_TEST
-TESTS += test-pcm
-endif
-
 check_PROGRAMS = \
+	server-mock \
 	test-at \
+	test-ctl \
 	test-io \
 	test-pcm \
-	test-server \
 	test-utils
 
+check_LTLIBRARIES = \
+	aloader.la
+aloader_la_LDFLAGS = \
+	-rpath /nowhere \
+	-avoid-version \
+	-shared -module
+
 AM_CFLAGS = \
 	-I$(top_srcdir)/src \
+	@AAC_CFLAGS@ \
 	@ALSA_CFLAGS@ \
+	@APTX_CFLAGS@ \
 	@BLUEZ_CFLAGS@ \
-	@GLIB2_CFLAGS@ \
+	@CHECK_CFLAGS@ \
 	@GIO2_CFLAGS@ \
-	@AAC_CFLAGS@ \
-	@APTX_CFLAGS@ \
+	@GLIB2_CFLAGS@ \
+	@LDAC_ABR_CFLAGS@ \
+	@LDAC_CFLAGS@ \
 	@SBC_CFLAGS@
 
 LDADD = \
+	@AAC_LIBS@ \
 	@ALSA_LIBS@ \
+	@APTX_LIBS@ \
 	@BLUEZ_LIBS@ \
-	@GLIB2_LIBS@ \
+	@CHECK_LIBS@ \
 	@GIO2_LIBS@ \
-	@AAC_LIBS@ \
-	@APTX_LIBS@ \
+	@GLIB2_LIBS@ \
+	@LDAC_ABR_LIBS@ \
+	@LDAC_LIBS@ \
 	@SBC_LIBS@
diff --git a/test/aloader.c b/test/aloader.c
new file mode 100644
index 0000000..59ed4b7
--- /dev/null
+++ b/test/aloader.c
@@ -0,0 +1,30 @@
+/*
+ * aloader.c
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <dlfcn.h>
+#include <string.h>
+
+typedef void *(*dlopen_t)(const char *filename, int flags);
+
+dlopen_t dlopen_orig = NULL;
+
+void *dlopen(const char *filename, int flags) {
+	if (dlopen_orig == NULL)
+		dlopen_orig = (dlopen_t)dlsym(RTLD_NEXT, __func__);
+	if (strstr(filename, "libasound_module_ctl_bluealsa.so") != NULL)
+		filename = "../src/asound/.libs/libasound_module_ctl_bluealsa.so";
+	if (strstr(filename, "libasound_module_pcm_bluealsa.so") != NULL)
+		filename = "../src/asound/.libs/libasound_module_pcm_bluealsa.so";
+	return dlopen_orig(filename, flags);
+}
diff --git a/test/inc/preload.inc b/test/inc/preload.inc
new file mode 100644
index 0000000..8881028
--- /dev/null
+++ b/test/inc/preload.inc
@@ -0,0 +1,36 @@
+/*
+ * preload.inc
+ * vim: ft=c
+ *
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LDPRELOAD "LD_PRELOAD"
+int preload(int argc, char *argv[], const char *filename) {
+	(void)argc;
+
+	char *tmp;
+	if ((tmp = getenv(LDPRELOAD)) != NULL &&
+			strstr(tmp, filename) != NULL)
+		return 0;
+
+	char preload[1024];
+	char *envp[] = { preload, NULL };
+
+	sprintf(preload, "%s=%s:", LDPRELOAD, filename);
+	if (tmp != NULL)
+		strcat(preload, tmp);
+
+	fprintf(stderr, "EXECV PRELOAD: %s\n", filename);
+	return execve(argv[0], argv, envp);
+}
diff --git a/test/inc/server.inc b/test/inc/server.inc
new file mode 100644
index 0000000..212f480
--- /dev/null
+++ b/test/inc/server.inc
@@ -0,0 +1,57 @@
+/*
+ * server.inc
+ * vim: ft=c
+ *
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+
+static char *bin_path = ".";
+
+/**
+ * Spawn bluealsa server mock.
+ *
+ * @param hci HCI device name.
+ * @param timeout Timeout passed to the server-mock.
+ * @param fuzzing Enable fuzzing - delayed startup.
+ * @param source Start A2DP source.
+ * @param sink Start A2DP sink.
+ * @return PID of the bluealsa server mock. */
+pid_t spawn_bluealsa_server(const char *hci, unsigned int timeout, bool fuzzing, bool source, bool sink) {
+
+	char path[256];
+	char arg_device[32];
+	char arg_timeout[16];
+	pid_t pid;
+
+	sprintf(arg_device, "--device=%s", hci);
+	sprintf(arg_timeout, "--timeout=%d", timeout);
+
+	char *argv[] = {
+		"server-mock",
+		arg_device,
+		arg_timeout,
+		fuzzing ? "--fuzzing" : "",
+		source ? "--source" : "",
+		sink ? "--sink" : "",
+		NULL,
+	};
+
+	sprintf(path, "%s/server-mock", bin_path);
+	/* assert(posix_spawn(&pid, path, NULL, NULL, argv, NULL) == 0); */
+
+	/* XXX: workaround for valgrind-3.13.0 */
+	if ((pid = fork()) == 0)
+		execv(path, argv);
+
+	usleep(100000);
+	return pid;
+}
diff --git a/test/inc/sine.inc b/test/inc/sine.inc
index b79c5b1..a044cec 100644
--- a/test/inc/sine.inc
+++ b/test/inc/sine.inc
@@ -12,6 +12,7 @@
 
 #include <limits.h>
 #include <math.h>
+#include <stdint.h>
 #include <stdlib.h>
 
 /**
diff --git a/test/inc/test.inc b/test/inc/test.inc
deleted file mode 100644
index 5e4a3f6..0000000
--- a/test/inc/test.inc
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * test.inc
- * vim: ft=c
- *
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
- *
- * This file is a part of bluez-alsa.
- *
- * This project is licensed under the terms of the MIT license.
- *
- * This file contains definitions of log functions for testing purposes. It
- * should be included as is in the test program.
- *
- */
-
-#include <assert.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-
-static int test_sigusr1_count;
-static int test_sigusr2_count;
-
-static int test_error_count;
-static int test_warn_count;
-static int test_info_count;
-
-static char test_error_msg[512];
-static char test_warn_msg[512];
-static char test_info_msg[512];
-
-#define test_run(f) do { \
-		test_sigusr1_count = test_sigusr2_count = 0; \
-		test_error_count = test_warn_count = test_info_count = 0; \
-		*test_error_msg = *test_warn_msg = *test_info_msg = '\0'; \
-		assert(!f()); \
-	} while (0)
-
-static void vlog(const char *format, va_list ap) {
-	int oldstate;
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate);
-	flockfile(stderr);
-	vfprintf(stderr, format, ap);
-	fputs("\n", stderr);
-	funlockfile(stderr);
-	pthread_setcancelstate(oldstate, NULL);
-}
-
-void error(const char *format, ...) {
-	va_list ap;
-	va_start(ap, format);
-	vsprintf(test_error_msg, format, ap);
-	va_end(ap);
-	va_start(ap, format);
-	vlog(format, ap);
-	va_end(ap);
-	test_error_count++;
-}
-
-void warn(const char *format, ...) {
-	va_list ap;
-	va_start(ap, format);
-	vsprintf(test_warn_msg, format, ap);
-	va_end(ap);
-	va_start(ap, format);
-	vlog(format, ap);
-	va_end(ap);
-	test_warn_count++;
-}
-
-void info(const char *format, ...) {
-	va_list ap;
-	va_start(ap, format);
-	vsprintf(test_info_msg, format, ap);
-	va_end(ap);
-	va_start(ap, format);
-	vlog(format, ap);
-	va_end(ap);
-	test_info_count++;
-}
-
-void _debug(const char *format, ...) {
-	va_list ap;
-	va_start(ap, format);
-	vlog(format, ap);
-	va_end(ap);
-}
-
-static void test_sigusr_handler(int sig) {
-	switch (sig) {
-	case SIGUSR1:
-		_debug("Dispatching SIGUSR1");
-		test_sigusr1_count++;
-		break;
-	case SIGUSR2:
-		_debug("Dispatching SIGUSR2");
-		test_sigusr2_count++;
-		break;
-	default:
-		error("Unsupported signal: %d", sig);
-	}
-}
diff --git a/test/test-server.c b/test/server-mock.c
similarity index 50%
rename from test/test-server.c
rename to test/server-mock.c
index 612b007..cb55991 100644
--- a/test/test-server.c
+++ b/test/server-mock.c
@@ -1,6 +1,6 @@
 /*
- * test-server.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * server-mock.c
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,34 +8,34 @@
  *
  * This program might be used to debug or check the functionality of ALSA
  * plug-ins. It should work exactly the same as the BlueALSA server. When
- * connecting to the bluealsa device, one should use "hci-test" interface.
+ * connecting to the bluealsa device, one should use "hci-mock" interface.
  *
  */
 
-#define _GNU_SOURCE
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <assert.h>
 #include <fcntl.h>
 #include <getopt.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
 #include "inc/sine.inc"
-#include "inc/test.inc"
 
 #include "../src/bluealsa.c"
 #include "../src/at.c"
 #include "../src/ctl.c"
 #include "../src/io.h"
 #define io_thread_a2dp_sink_sbc _io_thread_a2dp_sink_sbc
-#define io_thread_a2dp_source_sbc _io_thread_a2dp_source_sbc
 #include "../src/io.c"
 #undef io_thread_a2dp_sink_sbc
-#undef io_thread_a2dp_source_sbc
 #include "../src/rfcomm.c"
-#define transport_acquire_bt_a2dp _transport_acquire_bt_a2dp
 #include "../src/transport.c"
-#undef transport_acquire_bt_a2dp
 #include "../src/utils.c"
 #include "../src/shared/ffb.c"
+#include "../src/shared/log.c"
 #include "../src/shared/rt.c"
 
 static const a2dp_sbc_t cconfig = {
@@ -48,9 +48,15 @@ static const a2dp_sbc_t cconfig = {
 	.max_bitpool = SBC_MAX_BITPOOL,
 };
 
+static const char *device = "hci-mock";
+static unsigned int timeout = 5;
+static bool fuzzing = false;
+static bool source = false;
+static bool sink = false;
+static bool sco = false;
+
 static void test_pcm_setup_free(void) {
 	bluealsa_ctl_free();
-	bluealsa_config_free();
 }
 
 static bool main_loop_on = true;
@@ -60,24 +66,76 @@ static void test_pcm_setup_free_handler(int sig) {
 	test_pcm_setup_free();
 }
 
-int transport_acquire_bt_a2dp(struct ba_transport *t) {
-	t->delay = 1; /* suppress delay check trigger */
+static int sigusr1_count = 0;
+static int sigusr2_count = 0;
+static void test_sigusr_handler(int sig) {
+	switch (sig) {
+	case SIGUSR1:
+		sigusr1_count++;
+		debug("Dispatching SIGUSR1: %d", sigusr1_count);
+		break;
+	case SIGUSR2:
+		sigusr2_count++;
+		debug("Dispatching SIGUSR2: %d", sigusr2_count);
+		break;
+	default:
+		error("Unsupported signal: %d", sig);
+	}
+}
+
+int test_transport_acquire(struct ba_transport *t) {
+
+	int bt_fds[2];
+	assert(socketpair(AF_UNIX, SOCK_SEQPACKET, 0, bt_fds) == 0);
+
+	t->bt_fd = bt_fds[0];
+	t->mtu_read = 256;
+	t->mtu_write = 256;
+
 	t->state = TRANSPORT_ACTIVE;
 	assert(io_thread_create(t) == 0);
+
+	return 0;
+}
+
+int test_transport_release(struct ba_transport *t) {
+	if (t->bt_fd != -1)
+		close(t->bt_fd);
+	t->bt_fd = -1;
 	return 0;
 }
 
+struct ba_transport *test_transport_new_a2dp(struct ba_device *d,
+		const char *owner, const char *path, enum bluetooth_profile profile,
+		uint16_t codec, const uint8_t *config, size_t csize) {
+	if (fuzzing)
+		sleep(1);
+	struct ba_transport *t = transport_new_a2dp(d, owner, path, profile, codec, config, csize);
+	t->acquire = test_transport_acquire;
+	t->release = test_transport_release;
+	return t;
+}
+
+struct ba_transport *test_transport_new_sco(struct ba_device *d,
+		const char *owner, const char *path, enum bluetooth_profile profile,
+		uint16_t codec) {
+	if (fuzzing)
+		sleep(1);
+	struct ba_transport *t = transport_new_sco(d, owner, path, profile, codec);
+	t->acquire = test_transport_acquire;
+	t->release = test_transport_release;
+	return t;
+}
+
 void *io_thread_a2dp_sink_sbc(void *arg) {
 	struct ba_transport *t = (struct ba_transport *)arg;
-
-	struct sigaction sigact = { .sa_handler = SIG_IGN };
-	sigaction(SIGPIPE, &sigact, NULL);
+	pthread_cleanup_push(PTHREAD_CLEANUP(transport_pthread_cleanup), t);
 
 	struct asrsync asrs = { .frames = 0 };
 	int16_t buffer[1024 * 2];
 	int x = 0;
 
-	while (test_sigusr1_count == 0) {
+	while (sigusr1_count == 0) {
 
 		if (t->a2dp.pcm.fd == -1) {
 			usleep(10000);
@@ -87,7 +145,7 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 		fprintf(stderr, ".");
 
 		if (asrs.frames == 0)
-			asrsync_init(asrs, transport_get_sampling(t));
+			asrsync_init(&asrs, transport_get_sampling(t));
 
 		int samples = sizeof(buffer) / sizeof(int16_t);
 		x = snd_pcm_sine_s16le(buffer, samples, 2, x, 0.01);
@@ -98,83 +156,58 @@ void *io_thread_a2dp_sink_sbc(void *arg) {
 		asrsync_sync(&asrs, samples / 2);
 	}
 
-	transport_release_pcm(&t->a2dp.pcm);
-	return NULL;
-}
-
-void *io_thread_a2dp_source_sbc(void *arg) {
-	struct ba_transport *t = (struct ba_transport *)arg;
-
-	while (t->a2dp.pcm.fd == -1)
-		usleep(10000);
-
-	struct asrsync asrs = { .frames = 0 };
-	int16_t buffer[1024 * 2];
-	ssize_t samples;
-
-	while (test_sigusr2_count == 0) {
-		fprintf(stderr, ".");
-
-		if (asrs.frames == 0)
-			asrsync_init(asrs, transport_get_sampling(t));
-
-		const size_t in_samples = sizeof(buffer) / sizeof(int16_t);
-		if ((samples = io_thread_read_pcm(&t->a2dp.pcm, buffer, in_samples)) <= 0) {
-			if (samples == -1)
-				error("FIFO read error: %s", strerror(errno));
-			break;
-		}
-
-		asrsync_sync(&asrs, samples / 2);
-	}
-
-	transport_release_pcm(&t->a2dp.pcm);
+	pthread_cleanup_pop(1);
 	return NULL;
 }
 
 int main(int argc, char *argv[]) {
 
 	int opt;
-	const char *opts = "hsit:";
+	const char *opts = "hsit:F";
 	struct option longopts[] = {
 		{ "help", no_argument, NULL, 'h' },
-		{ "source", no_argument, NULL, 's' },
-		{ "sink", no_argument, NULL, 'i' },
+		{ "device", required_argument, NULL, 'i' },
 		{ "timeout", required_argument, NULL, 't' },
+		{ "fuzzing", no_argument, NULL, 'F' },
+		{ "source", no_argument, NULL, 1 },
+		{ "sink", no_argument, NULL, 2 },
+		{ "sco", no_argument, NULL, 3 },
 		{ 0, 0, 0, 0 },
 	};
 
-	int source = 0;
-	int sink = 0;
-	int timeout = 5;
-
 	while ((opt = getopt_long(argc, argv, opts, longopts, NULL)) != -1)
 		switch (opt) {
 		case 'h':
-			printf("usage: %s [--source] [--sink] [--timeout SEC]\n", argv[0]);
+			printf("usage: %s [--source] [--sink] [--sco] [--device HCI] [--timeout SEC]\n", argv[0]);
 			return EXIT_SUCCESS;
-		case 's':
-			source = 1;
+		case 1:
+			source = true;
+			break;
+		case 2:
+			sink = true;
+			break;
+		case 3:
+			sco = true;
 			break;
 		case 'i':
-			sink = 1;
+			device = optarg;
 			break;
 		case 't':
 			timeout = atoi(optarg);
 			break;
+		case 'F':
+			fuzzing = true;
+			break;
 		default:
 			fprintf(stderr, "Try '%s --help' for more information.\n", argv[0]);
 			return EXIT_FAILURE;
 		}
 
 	/* emulate dummy test HCI device */
-	strncpy(config.hci_dev.name, "hci-xxx", sizeof(config.hci_dev.name) - 1);
+	strncpy(config.hci_dev.name, device, sizeof(config.hci_dev.name) - 1);
 
 	assert(bluealsa_config_init() == 0);
-	if ((bluealsa_ctl_thread_init() == -1)) {
-		perror("ctl_thread_init");
-		return EXIT_FAILURE;
-	}
+	assert(bluealsa_ctl_thread_init() == 0);
 
 	/* make sure to cleanup named pipes */
 	struct sigaction sigact = { .sa_handler = test_pcm_setup_free_handler };
@@ -182,6 +215,10 @@ int main(int argc, char *argv[]) {
 	sigaction(SIGTERM, &sigact, NULL);
 	atexit(test_pcm_setup_free);
 
+	/* receive EPIPE error code */
+	sigact.sa_handler = SIG_IGN;
+	sigaction(SIGPIPE, &sigact, NULL);
+
 	/* register USR signals handler */
 	sigact.sa_handler = test_sigusr_handler;
 	sigaction(SIGUSR1, &sigact, NULL);
@@ -195,31 +232,51 @@ int main(int argc, char *argv[]) {
 
 	str2ba("12:34:56:78:9A:BC", &addr);
 	assert((d1 = device_new(1, &addr, "Test Device With Long Name")) != NULL);
-	g_hash_table_insert(config.devices, g_strdup("/device/1"), d1);
+	bluealsa_device_insert("/device/1", d1);
 
 	str2ba("12:34:56:9A:BC:DE", &addr);
 	assert((d2 = device_new(1, &addr, "Test Device With Long Name")) != NULL);
-	g_hash_table_insert(config.devices, g_strdup("/device/2"), d2);
+	bluealsa_device_insert("/device/2", d2);
 
 	if (source) {
-		assert(transport_new_a2dp(d1, ":test", "/source/1", BLUETOOTH_PROFILE_A2DP_SOURCE,
+		assert(test_transport_new_a2dp(d1, ":test", "/source/1", BLUETOOTH_PROFILE_A2DP_SOURCE,
 					A2DP_CODEC_SBC, (uint8_t *)&cconfig, sizeof(cconfig)) != NULL);
-		assert(transport_new_a2dp(d2, ":test", "/source/2", BLUETOOTH_PROFILE_A2DP_SOURCE,
+		assert(test_transport_new_a2dp(d2, ":test", "/source/2", BLUETOOTH_PROFILE_A2DP_SOURCE,
 					A2DP_CODEC_SBC, (uint8_t *)&cconfig, sizeof(cconfig)) != NULL);
 	}
 
 	if (sink) {
 		struct ba_transport *t;
-		assert((t = transport_new_a2dp(d1, ":test", "/sink/1", BLUETOOTH_PROFILE_A2DP_SINK,
+		assert((t = test_transport_new_a2dp(d1, ":test", "/sink/1", BLUETOOTH_PROFILE_A2DP_SINK,
 						A2DP_CODEC_SBC, (uint8_t *)&cconfig, sizeof(cconfig))) != NULL);
-		assert(transport_acquire_bt_a2dp(t) == 0);
-		assert((t = transport_new_a2dp(d2, ":test", "/sink/2", BLUETOOTH_PROFILE_A2DP_SINK,
+		assert(t->acquire(t) == 0);
+		assert((t = test_transport_new_a2dp(d2, ":test", "/sink/2", BLUETOOTH_PROFILE_A2DP_SINK,
 						A2DP_CODEC_SBC, (uint8_t *)&cconfig, sizeof(cconfig))) != NULL);
-		assert(transport_acquire_bt_a2dp(t) == 0);
+		assert(t->acquire(t) == 0);
+	}
+
+	if (sco) {
+		struct ba_transport *t;
+		assert((t = test_transport_new_sco(d1, ":test", "/sco/1", BLUETOOTH_PROFILE_HSP_AG,
+						HFP_CODEC_UNDEFINED)) != NULL);
+		assert((t = test_transport_new_sco(d2, ":test", "/sco/2", BLUETOOTH_PROFILE_HFP_AG,
+						HFP_CODEC_UNDEFINED)) != NULL);
+		if (fuzzing) {
+			t->codec = HFP_CODEC_CVSD;
+			bluealsa_ctl_send_event(BA_EVENT_TRANSPORT_CHANGED, &t->device->addr,
+					BA_PCM_TYPE_SCO | BA_PCM_STREAM_PLAYBACK | BA_PCM_STREAM_CAPTURE);
+		}
 	}
 
 	while (timeout != 0 && main_loop_on)
 		timeout = sleep(timeout);
 
+	if (fuzzing) {
+		bluealsa_device_remove("/device/1");
+		sleep(1);
+		bluealsa_device_remove("/device/2");
+		sleep(1);
+	}
+
 	return EXIT_SUCCESS;
 }
diff --git a/test/test-at.c b/test/test-at.c
index 1a62051..8cff264 100644
--- a/test/test-at.c
+++ b/test/test-at.c
@@ -1,6 +1,6 @@
 /*
  * test-at.c
- * Copyright (c) 2016-2017 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,102 +8,171 @@
  *
  */
 
-#include "inc/test.inc"
+#include <check.h>
+
 #include "../src/at.c"
+#include "../src/shared/log.c"
 
-int main(void) {
+START_TEST(test_at_build) {
 
-	struct bt_at at;
-	enum hfp_ind indmap[20];
-	enum hfp_ind indmap_ok[20];
 	char buffer[256];
 
+	/* build commands */
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_RAW, "\r\nRING", NULL), "\r\nRING");
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_CMD, "+CLCC", NULL), "AT+CLCC\r");
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_CMD_GET, "+COPS", NULL), "AT+COPS?\r");
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_CMD_SET, "+BCS", "1"), "AT+BCS=1\r");
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_CMD_TEST, "+CIND", NULL), "AT+CIND=?\r");
+
+	/* build response result code */
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_RESP, "+CIND", ""), "\r\n+CIND:\r\n");
+
+	/* build unsolicited result code */
+	ck_assert_str_eq(at_build(buffer, AT_TYPE_RESP, NULL, "OK"), "\r\nOK\r\n");
+
+} END_TEST
+
+START_TEST(test_at_parse_invalid) {
+	struct bt_at at;
 	/* invalid AT command lines */
-	assert(at_parse("ABC\r", &at) == NULL);
-	assert(at_parse("AT+CLCK?", &at) == NULL);
-	assert(at_parse("\r\r", &at) == NULL);
-	assert(at_parse("\r\nOK", &at) == NULL);
+	ck_assert_ptr_eq(at_parse("ABC\r", &at), NULL);
+	ck_assert_ptr_eq(at_parse("AT+CLCK?", &at), NULL);
+	ck_assert_ptr_eq(at_parse("\r\r", &at), NULL);
+	ck_assert_ptr_eq(at_parse("\r\nOK", &at), NULL);
+} END_TEST
 
+START_TEST(test_at_parse_cmd) {
+	struct bt_at at;
 	/* parse AT plain command */
-	assert(at_parse("AT+CLCC\r", &at) != NULL);
-	assert(at.type == AT_TYPE_CMD);
-	assert(strcmp(at.command, "+CLCC") == 0);
-	assert(at.value == NULL);
+	ck_assert_ptr_ne(at_parse("AT+CLCC\r", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_CMD);
+	ck_assert_str_eq(at.command, "+CLCC");
+	ck_assert_ptr_eq(at.value, NULL);
+} END_TEST
 
+START_TEST(test_at_parse_cmd_get) {
+	struct bt_at at;
 	/* parse AT GET command */
-	assert(at_parse("AT+COPS?\r", &at) != NULL);
-	assert(at.type == AT_TYPE_CMD_GET);
-	assert(strcmp(at.command, "+COPS") == 0);
-	assert(at.value == NULL);
+	ck_assert_ptr_ne(at_parse("AT+COPS?\r", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_CMD_GET);
+	ck_assert_str_eq(at.command, "+COPS");
+	ck_assert_ptr_eq(at.value, NULL);
+} END_TEST
 
+START_TEST(test_at_parse_cmd_set) {
+	struct bt_at at;
 	/* parse AT SET command */
-	assert(at_parse("AT+CLCK=\"SC\",0,\"1234\"\r", &at) != NULL);
-	assert(at.type == AT_TYPE_CMD_SET);
-	assert(strcmp(at.command, "+CLCK") == 0);
-	assert(strcmp(at.value, "\"SC\",0,\"1234\"") == 0);
+	ck_assert_ptr_ne(at_parse("AT+CLCK=\"SC\",0,\"1234\"\r", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_CMD_SET);
+	ck_assert_str_eq(at.command, "+CLCK");
+	ck_assert_str_eq(at.value, "\"SC\",0,\"1234\"");
+} END_TEST
 
+START_TEST(test_at_parse_cmd_test) {
+	struct bt_at at;
 	/* parse AT TEST command */
-	assert(at_parse("AT+COPS=?\r", &at) != NULL);
-	assert(at.type == AT_TYPE_CMD_TEST);
-	assert(strcmp(at.command, "+COPS") == 0);
-	assert(at.value == NULL);
+	ck_assert_ptr_ne(at_parse("AT+COPS=?\r", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_CMD_TEST);
+	ck_assert_str_eq(at.command, "+COPS");
+	ck_assert_ptr_eq(at.value, NULL);
+} END_TEST
 
+START_TEST(test_at_parse_resp) {
+	struct bt_at at;
 	/* parse response result code */
-	assert(at_parse("\r\n+CIND:0,0,1,4,0,4,0\r\n", &at) != NULL);
-	assert(at.type == AT_TYPE_RESP);
-	assert(strcmp(at.command, "+CIND") == 0);
-	assert(strcmp(at.value, "0,0,1,4,0,4,0") == 0);
+	ck_assert_ptr_ne(at_parse("\r\n+CIND:0,0,1,4,0,4,0\r\n", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_RESP);
+	ck_assert_str_eq(at.command, "+CIND");
+	ck_assert_str_eq(at.value, "0,0,1,4,0,4,0");
+} END_TEST
 
+START_TEST(test_at_parse_resp_empty) {
+	struct bt_at at;
 	/* parse response result code with empty value */
-	assert(at_parse("\r\n+CIND:\r\n", &at) != NULL);
-	assert(at.type == AT_TYPE_RESP);
-	assert(strcmp(at.command, "+CIND") == 0);
-	assert(strcmp(at.value, "") == 0);
+	ck_assert_ptr_ne(at_parse("\r\n+CIND:\r\n", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_RESP);
+	ck_assert_str_eq(at.command, "+CIND");
+	ck_assert_str_eq(at.value, "");
+} END_TEST
 
+START_TEST(test_at_parse_resp_unsolicited) {
+	struct bt_at at;
 	/* parse unsolicited result code */
-	assert(at_parse("\r\nRING\r\n", &at) != NULL);
-	assert(at.type == AT_TYPE_RESP);
-	assert(strcmp(at.command, "") == 0);
-	assert(strcmp(at.value, "RING") == 0);
+	ck_assert_ptr_ne(at_parse("\r\nRING\r\n", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_RESP);
+	ck_assert_str_eq(at.command, "");
+	ck_assert_str_eq(at.value, "RING");
+} END_TEST
 
+START_TEST(test_at_parse_case_sensitivity) {
+	struct bt_at at;
 	/* case-insensitive command and case-sensitive value */
-	assert(at_parse("aT+tEsT=VaLuE\r", &at) != NULL);
-	assert(at.type == AT_TYPE_CMD_SET);
-	assert(strcmp(at.command, "+TEST") == 0);
-	assert(strcmp(at.value, "VaLuE") == 0);
+	ck_assert_ptr_ne(at_parse("aT+tEsT=VaLuE\r", &at), NULL);
+	ck_assert_int_eq(at.type, AT_TYPE_CMD_SET);
+	ck_assert_str_eq(at.command, "+TEST");
+	ck_assert_str_eq(at.value, "VaLuE");
+} END_TEST
 
+START_TEST(test_at_parse_multiple_cmds) {
+	struct bt_at at;
 	/* concatenated commands */
 	const char *cmd = "\r\nOK\r\n\r\n+COPS:1\r\n";
-	assert(at_parse(cmd, &at) == &cmd[6]);
-	assert(at.type == AT_TYPE_RESP);
-	assert(strcmp(at.command, "") == 0);
-	assert(strcmp(at.value, "OK") == 0);
-
-	/* build commands */
-	assert(strcmp(at_build(buffer, AT_TYPE_RAW, "\r\nRING", NULL), "\r\nRING") == 0);
-	assert(strcmp(at_build(buffer, AT_TYPE_CMD, "+CLCC", NULL), "AT+CLCC\r") == 0);
-	assert(strcmp(at_build(buffer, AT_TYPE_CMD_GET, "+COPS", NULL), "AT+COPS?\r") == 0);
-	assert(strcmp(at_build(buffer, AT_TYPE_CMD_SET, "+BCS", "1"), "AT+BCS=1\r") == 0);
-	assert(strcmp(at_build(buffer, AT_TYPE_CMD_TEST, "+CIND", NULL), "AT+CIND=?\r") == 0);
+	ck_assert_str_eq(at_parse(cmd, &at), &cmd[6]);
+	ck_assert_int_eq(at.type, AT_TYPE_RESP);
+	ck_assert_str_eq(at.command, "");
+	ck_assert_str_eq(at.value, "OK");
+} END_TEST
 
-	/* build response result code */
-	assert(strcmp(at_build(buffer, AT_TYPE_RESP, "+CIND", ""), "\r\n+CIND:\r\n") == 0);
+START_TEST(test_at_parse_cind) {
 
-	/* build unsolicited result code */
-	assert(strcmp(at_build(buffer, AT_TYPE_RESP, NULL, "OK"), "\r\nOK\r\n") == 0);
+	enum hfp_ind indmap[20];
+	enum hfp_ind indmap_ok[20];
 
 	/* parse +CIND response result code */
-	assert(at_parse_cind("(\"call\",(0,1)),(\"xxx\",(0-3)),(\"signal\",(0-5))", indmap) == 0);
+	ck_assert_int_eq(at_parse_cind("(\"call\",(0,1)),(\"xxx\",(0-3)),(\"signal\",(0-5))", indmap), 0);
 	memset(indmap_ok, HFP_IND_NULL, sizeof(indmap_ok));
 	indmap_ok[0] = HFP_IND_CALL;
 	indmap_ok[2] = HFP_IND_SIGNAL;
-	assert(memcmp(indmap, indmap_ok, sizeof(indmap)) == 0);
+	ck_assert_int_eq(memcmp(indmap, indmap_ok, sizeof(indmap)), 0);
 
 	/* parse +CIND response with white-spaces */
-	assert(at_parse_cind(" ( \"call\", ( 0, 1 ) ), ( \"signal\", ( 0-3 ) )", indmap) == 0);
+	ck_assert_int_eq(at_parse_cind(" ( \"call\", ( 0, 1 ) ), ( \"signal\", ( 0-3 ) )", indmap), 0);
 
 	/* parse +CIND invalid response */
-	assert(at_parse_cind("(incorrect,1-2)", indmap) == -1);
+	ck_assert_int_eq(at_parse_cind("(incorrect,1-2)", indmap), -1);
+
+} END_TEST
+
+START_TEST(test_at_type2str) {
+	ck_assert_str_eq(at_type2str(AT_TYPE_RAW), "RAW");
+	ck_assert_str_eq(at_type2str(AT_TYPE_RESP), "RESP");
+} END_TEST
+
+int main(void) {
 
-	return 0;
+	Suite *s = suite_create(__FILE__);
+	TCase *tc = tcase_create(__FILE__);
+	SRunner *sr = srunner_create(s);
+
+	suite_add_tcase(s, tc);
+
+	tcase_add_test(tc, test_at_build);
+	tcase_add_test(tc, test_at_parse_invalid);
+	tcase_add_test(tc, test_at_parse_cmd);
+	tcase_add_test(tc, test_at_parse_cmd_get);
+	tcase_add_test(tc, test_at_parse_cmd_set);
+	tcase_add_test(tc, test_at_parse_cmd_test);
+	tcase_add_test(tc, test_at_parse_resp);
+	tcase_add_test(tc, test_at_parse_resp_empty);
+	tcase_add_test(tc, test_at_parse_resp_unsolicited);
+	tcase_add_test(tc, test_at_parse_case_sensitivity);
+	tcase_add_test(tc, test_at_parse_multiple_cmds);
+	tcase_add_test(tc, test_at_parse_cind);
+	tcase_add_test(tc, test_at_type2str);
+
+	srunner_run_all(sr, CK_ENV);
+	int nf = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return nf == 0 ? 0 : 1;
 }
diff --git a/test/test-ctl.c b/test/test-ctl.c
new file mode 100644
index 0000000..540acec
--- /dev/null
+++ b/test/test-ctl.c
@@ -0,0 +1,212 @@
+/*
+ * test-ctl.c
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
+ *
+ * This file is a part of bluez-alsa.
+ *
+ * This project is licensed under the terms of the MIT license.
+ *
+ */
+
+#include <libgen.h>
+#include <sys/wait.h>
+
+#include <check.h>
+
+#include "inc/server.inc"
+#include "../src/shared/ctl-client.c"
+#include "../src/shared/log.c"
+
+static bdaddr_t addr0;
+static bdaddr_t addr1;
+
+START_TEST(test_open) {
+
+	const char *hci = "hci-tc0";
+
+	ck_assert_int_eq(bluealsa_open(hci), -1);
+	ck_assert_int_eq(errno, ENOENT);
+
+	pid_t pid = spawn_bluealsa_server(hci, 1, false, false, false);
+	ck_assert_int_ne(bluealsa_open(hci), -1);
+
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+START_TEST(test_subscribe) {
+
+	const char *hci = "hci-tc1";
+	pid_t pid = spawn_bluealsa_server(hci, 1, true, true, false);
+
+	int fd = -1;
+	ck_assert_int_ne(fd = bluealsa_open(hci), -1);
+
+	ck_assert_int_ne(bluealsa_event_subscribe(fd, BA_EVENT_TRANSPORT_ADDED), -1);
+
+	struct ba_msg_event ev0, ev1;
+	ck_assert_int_eq(read(fd, &ev0, sizeof(ev0)), sizeof(ev0));
+	ck_assert_int_eq(read(fd, &ev1, sizeof(ev1)), sizeof(ev1));
+
+	struct ba_msg_transport t0, t1;
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr0, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t0), -1);
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr1, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t1), -1);
+
+	ck_assert_int_eq(bluealsa_event_match(&t0, &ev0), 0);
+	ck_assert_int_eq(bluealsa_event_match(&t1, &ev1), 0);
+
+	close(fd);
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+START_TEST(test_get_devices) {
+
+	const char *hci = "hci-tc2";
+	pid_t pid = spawn_bluealsa_server(hci, 1, false, true, true);
+
+	int fd = -1;
+	ck_assert_int_ne(fd = bluealsa_open(hci), -1);
+
+	struct ba_msg_device *devices;
+	ck_assert_int_eq(bluealsa_get_devices(fd, &devices), 2);
+
+	ck_assert_int_eq(bacmp(&devices[0].addr, &addr0), 0);
+	ck_assert_str_eq(devices[0].name, "Test Device With Long Name");
+	ck_assert_int_eq(bacmp(&devices[1].addr, &addr1), 0);
+	ck_assert_str_eq(devices[1].name, "Test Device With Long Name");
+
+	struct ba_msg_transport *transports;
+	ck_assert_int_eq(bluealsa_get_transports(fd, &transports), 4);
+
+	ck_assert_int_eq(bacmp(&transports[0].addr, &addr0), 0);
+	ck_assert_int_eq(transports[0].type, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK);
+	ck_assert_int_eq(bacmp(&transports[1].addr, &addr0), 0);
+	ck_assert_int_eq(transports[1].type, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_CAPTURE);
+	ck_assert_int_eq(bacmp(&transports[2].addr, &addr1), 0);
+	ck_assert_int_eq(transports[2].type, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK);
+	ck_assert_int_eq(bacmp(&transports[3].addr, &addr1), 0);
+	ck_assert_int_eq(transports[3].type, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_CAPTURE);
+
+	ck_assert_int_eq(transports[0].codec, 0);
+	ck_assert_int_eq(transports[0].channels, 2);
+	ck_assert_int_eq(transports[0].sampling, 44100);
+	ck_assert_int_eq(transports[0].ch1_muted, 0);
+	ck_assert_int_eq(transports[0].ch1_volume, 127);
+	ck_assert_int_eq(transports[0].ch2_muted, 0);
+	ck_assert_int_eq(transports[0].ch2_volume, 127);
+	ck_assert_int_eq(transports[0].delay, 0);
+
+	close(fd);
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+START_TEST(test_get_transport) {
+
+	const char *hci = "hci-tc3";
+	pid_t pid = spawn_bluealsa_server(hci, 1, false, true, false);
+
+	int fd = -1;
+	ck_assert_int_ne(fd = bluealsa_open(hci), -1);
+
+	struct ba_msg_transport t;
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr0, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t), -1);
+
+	unsigned int delay = 0;
+	ck_assert_int_eq(bluealsa_get_transport_delay(fd, &t, &delay), 0);
+	ck_assert_int_eq(delay, 0);
+
+	bool ch1_muted = false, ch2_muted = false;
+	int ch1_volume = 0, ch2_volume = 0;
+	ck_assert_int_eq(bluealsa_set_transport_volume(fd, &t, true, 15, true, 50), 0);
+	ck_assert_int_eq(bluealsa_get_transport_volume(fd, &t, &ch1_muted, &ch1_volume, &ch2_muted, &ch2_volume), 0);
+	ck_assert_int_eq(ch1_muted, true);
+	ck_assert_int_eq(ch1_volume, 15);
+	ck_assert_int_eq(ch2_muted, true);
+	ck_assert_int_eq(ch2_volume, 50);
+
+	close(fd);
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+START_TEST(test_open_transport) {
+
+	const char *hci = "hci-tc4";
+	pid_t pid = spawn_bluealsa_server(hci, 2, false, true, false);
+
+	int fd = -1;
+	ck_assert_int_ne(fd = bluealsa_open(hci), -1);
+
+	struct ba_msg_transport t0, t1;
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr0, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t0), -1);
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr1, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t1), -1);
+
+	int pcm_fd0 = -1;
+	int pcm_fd1 = -1;
+	ck_assert_int_ne(pcm_fd0 = bluealsa_open_transport(fd, &t0), -1);
+	ck_assert_int_ne(pcm_fd1 = bluealsa_open_transport(fd, &t1), -1);
+
+	close(fd);
+	/* ensure that we can reopen PCM after client disconnection */
+
+	ck_assert_int_ne(fd = bluealsa_open(hci), -1);
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr0, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t0), -1);
+	ck_assert_int_ne(bluealsa_get_transport(fd, &addr1, BA_PCM_TYPE_A2DP | BA_PCM_STREAM_PLAYBACK, &t1), -1);
+	ck_assert_int_ne(pcm_fd0 = bluealsa_open_transport(fd, &t0), -1);
+	ck_assert_int_ne(pcm_fd1 = bluealsa_open_transport(fd, &t1), -1);
+
+	ck_assert_int_ne(bluealsa_control_transport(fd, &t0, BA_COMMAND_PCM_PAUSE), -1);
+	ck_assert_int_ne(bluealsa_control_transport(fd, &t0, BA_COMMAND_PCM_RESUME), -1);
+	ck_assert_int_ne(bluealsa_control_transport(fd, &t0, BA_COMMAND_PCM_DRAIN), -1);
+	ck_assert_int_ne(bluealsa_control_transport(fd, &t0, BA_COMMAND_PCM_DROP), -1);
+
+	ck_assert_int_ne(close(pcm_fd0), -1);
+	ck_assert_int_ne(close(pcm_fd1), -1);
+
+	/* XXX: PCM closing is an asynchronous call. It is possible, that the
+	 *      server will not process close() action right away. Right now it
+	 *      is not possible to open PCM more then once. So, in order to pass
+	 *      this test we will have to wait some time before reconnection. */
+	sleep(1);
+
+	/* ensure that we can reopen closed PCM */
+	ck_assert_int_ne(pcm_fd0 = bluealsa_open_transport(fd, &t0), -1);
+	ck_assert_int_ne(close(pcm_fd0), -1);
+
+	close(fd);
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+int main(int argc, char *argv[]) {
+	(void)argc;
+
+	/* test-pcm and server-mock shall be placed in the same directory */
+	bin_path = dirname(argv[0]);
+
+	str2ba("12:34:56:78:9A:BC", &addr0);
+	str2ba("12:34:56:9A:BC:DE", &addr1);
+
+	Suite *s = suite_create(__FILE__);
+	TCase *tc = tcase_create(__FILE__);
+	SRunner *sr = srunner_create(s);
+
+	suite_add_tcase(s, tc);
+
+	/* test_subscribe requires at least 5s */
+	tcase_set_timeout(tc, 10);
+
+	tcase_add_test(tc, test_open);
+	tcase_add_test(tc, test_subscribe);
+	tcase_add_test(tc, test_get_devices);
+	tcase_add_test(tc, test_get_transport);
+	tcase_add_test(tc, test_open_transport);
+
+	srunner_run_all(sr, CK_ENV);
+	int nf = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return nf == 0 ? 0 : 1;
+}
diff --git a/test/test-io.c b/test/test-io.c
index 96576ce..b7faa0b 100644
--- a/test/test-io.c
+++ b/test/test-io.c
@@ -1,6 +1,6 @@
 /*
  * test-io.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,9 +8,13 @@
  *
  */
 
-#define _GNU_SOURCE
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <check.h>
+
 #include "inc/sine.inc"
-#include "inc/test.inc"
 #include "../src/at.c"
 #include "../src/bluealsa.c"
 #include "../src/ctl.c"
@@ -19,6 +23,7 @@
 #include "../src/transport.c"
 #include "../src/utils.c"
 #include "../src/shared/ffb.c"
+#include "../src/shared/log.c"
 #include "../src/shared/rt.c"
 
 static const a2dp_sbc_t config_sbc_44100_stereo = {
@@ -46,6 +51,13 @@ static const a2dp_aptx_t config_aptx_44100_stereo = {
 	.channel_mode = APTX_CHANNEL_MODE_STEREO,
 };
 
+static const a2dp_ldac_t config_ldac_44100_stereo = {
+	.info.vendor_id = LDAC_VENDOR_ID,
+	.info.codec_id = LDAC_CODEC_ID,
+	.frequency = LDAC_SAMPLING_FREQ_44100,
+	.channel_mode = LDAC_CHANNEL_MODE_STEREO,
+};
+
 /**
  * Helper function for timed thread join.
  *
@@ -71,13 +83,13 @@ static struct {
 	size_t len;
 } test_a2dp_bt_data[10];
 
-static int test_a2dp_encoding(struct ba_transport *t, void *(*cb)(void *)) {
+static void test_a2dp_encoding(struct ba_transport *t, void *(*cb)(void *)) {
 
 	int bt_fds[2];
 	int pcm_fds[2];
 
-	assert(socketpair(AF_UNIX, SOCK_SEQPACKET, 0, bt_fds) == 0);
-	assert(socketpair(AF_UNIX, SOCK_STREAM, 0, pcm_fds) == 0);
+	ck_assert_int_eq(socketpair(AF_UNIX, SOCK_SEQPACKET, 0, bt_fds), 0);
+	ck_assert_int_eq(socketpair(AF_UNIX, SOCK_STREAM, 0, pcm_fds), 0);
 
 	t->profile = BLUETOOTH_PROFILE_A2DP_SOURCE;
 	t->state = TRANSPORT_ACTIVE;
@@ -92,43 +104,38 @@ static int test_a2dp_encoding(struct ba_transport *t, void *(*cb)(void *)) {
 	size_t i = 0;
 
 	snd_pcm_sine_s16le(buffer, sizeof(buffer) / sizeof(int16_t), 2, 0, 0.01);
-	assert(write(pcm_fds[0], buffer, sizeof(buffer)) == sizeof(buffer));
+	ck_assert_int_eq(write(pcm_fds[0], buffer, sizeof(buffer)), sizeof(buffer));
 
 	memset(test_a2dp_bt_data, 0, sizeof(test_a2dp_bt_data));
 	while (poll(pfds, ARRAYSIZE(pfds), 500) > 0) {
 
-		uint8_t *p = (uint8_t *)buffer;
-		ssize_t len = read(bt_fds[1], p, t->mtu_write);
+		char label[32];
+		ssize_t len = read(bt_fds[1], buffer, t->mtu_write);
 
 		if (i < ARRAYSIZE(test_a2dp_bt_data)) {
-			memcpy(test_a2dp_bt_data[i].data, p, len);
+			memcpy(test_a2dp_bt_data[i].data, buffer, len);
 			test_a2dp_bt_data[i++].len = len;
 		}
 
-		flockfile(stderr);
-		fprintf(stderr, "BT data [len: %3zd]:", len);
-		while (len--)
-			fprintf(stderr, " %02x", *p++ & 0xFF);
-		fprintf(stderr, "\n");
-		funlockfile(stderr);
+		sprintf(label, "BT data [len: %3zd]", len);
+		hexdump(label, buffer, len);
 
 	}
 
-	assert(pthread_cancel(thread) == 0);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
+	ck_assert_int_eq(pthread_cancel(thread), 0);
+	ck_assert_int_eq(pthread_timedjoin(thread, NULL, 1e6), 0);
 
 	close(pcm_fds[0]);
 	close(bt_fds[1]);
-	return 0;
 }
 
-static int test_a2dp_decoding(struct ba_transport *t, void *(*cb)(void *)) {
+static void test_a2dp_decoding(struct ba_transport *t, void *(*cb)(void *)) {
 
 	int bt_fds[2];
 	int pcm_fds[2];
 
-	assert(socketpair(AF_UNIX, SOCK_SEQPACKET, 0, bt_fds) == 0);
-	assert(socketpair(AF_UNIX, SOCK_STREAM, 0, pcm_fds) == 0);
+	ck_assert_int_eq(socketpair(AF_UNIX, SOCK_SEQPACKET, 0, bt_fds), 0);
+	ck_assert_int_eq(socketpair(AF_UNIX, SOCK_STREAM, 0, pcm_fds), 0);
 
 	t->profile = BLUETOOTH_PROFILE_A2DP_SINK;
 	t->state = TRANSPORT_ACTIVE;
@@ -141,65 +148,17 @@ static int test_a2dp_decoding(struct ba_transport *t, void *(*cb)(void *)) {
 	size_t i;
 	for (i = 0; i < ARRAYSIZE(test_a2dp_bt_data); i++)
 		if (test_a2dp_bt_data[i].len != 0)
-			assert(write(bt_fds[0], test_a2dp_bt_data[i].data, test_a2dp_bt_data[i].len) > 0);
+			ck_assert_int_gt(write(bt_fds[0], test_a2dp_bt_data[i].data, test_a2dp_bt_data[i].len), 0);
 
 	sleep(1);
-	assert(pthread_cancel(thread) == 0);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
+	ck_assert_int_eq(pthread_cancel(thread), 0);
+	ck_assert_int_eq(pthread_timedjoin(thread, NULL, 1e6), 0);
 
 	close(pcm_fds[1]);
 	close(bt_fds[0]);
-	return 0;
 }
 
-int test_a2dp_sbc_invalid_setup(void) {
-
-	const uint8_t codec[] = { 0xff, 0xff, 0xff, 0xff };
-	struct ba_transport transport = {
-		.profile = BLUETOOTH_PROFILE_A2DP_SOURCE,
-		.codec = A2DP_CODEC_SBC,
-		.a2dp = {
-			.cconfig = (uint8_t *)&codec,
-			.cconfig_size = sizeof(a2dp_sbc_t),
-		},
-		.state = TRANSPORT_IDLE,
-		.bt_fd = -1,
-	};
-
-	pthread_t thread;
-
-	pthread_create(&thread, NULL, io_thread_a2dp_sink_sbc, &transport);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
-	assert(test_error_count == 1);
-	assert(strcmp(test_error_msg, "Invalid BT socket: -1") == 0);
-
-	transport.bt_fd = 0;
-
-	pthread_create(&thread, NULL, io_thread_a2dp_sink_sbc, &transport);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
-	assert(test_error_count == 2);
-	assert(strcmp(test_error_msg, "Invalid reading MTU: 0") == 0);
-
-	transport.mtu_read = 475;
-
-	pthread_create(&thread, NULL, io_thread_a2dp_sink_sbc, &transport);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
-	assert(test_error_count == 3);
-	assert(strcmp(test_error_msg, "Couldn't initialize SBC codec: Invalid argument") == 0);
-
-	transport.a2dp.cconfig = (uint8_t *)&config_sbc_44100_stereo;
-	*test_error_msg = '\0';
-
-	pthread_create(&thread, NULL, io_thread_a2dp_sink_sbc, &transport);
-	assert(pthread_cancel(thread) == 0);
-	assert(pthread_timedjoin(thread, NULL, 1e6) == 0);
-	assert(test_error_count == 3);
-	assert(strcmp(test_error_msg, "") == 0);
-
-	return 0;
-}
-
-int test_a2dp_sbc(void) {
+START_TEST(test_a2dp_sbc) {
 
 	struct ba_transport transport = {
 		.codec = A2DP_CODEC_SBC,
@@ -210,18 +169,15 @@ int test_a2dp_sbc(void) {
 	};
 
 	transport.mtu_write = 153 * 3,
-	assert(test_a2dp_encoding(&transport, io_thread_a2dp_source_sbc) == 0);
-	assert(test_warn_count == 0 && test_error_count == 0);
+	test_a2dp_encoding(&transport, io_thread_a2dp_source_sbc);
 
 	transport.mtu_read = transport.mtu_write;
-	assert(test_a2dp_decoding(&transport, io_thread_a2dp_sink_sbc) == 0);
-	assert(test_warn_count == 0 && test_error_count == 0);
+	test_a2dp_decoding(&transport, io_thread_a2dp_sink_sbc);
 
-	return 0;
-}
+} END_TEST
 
 #if ENABLE_AAC
-int test_a2dp_aac(void) {
+START_TEST(test_a2dp_aac) {
 
 	struct ba_transport transport = {
 		.codec = A2DP_CODEC_MPEG24,
@@ -232,19 +188,16 @@ int test_a2dp_aac(void) {
 	};
 
 	transport.mtu_write = 64;
-	assert(test_a2dp_encoding(&transport, io_thread_a2dp_source_aac) == 0);
-	assert(test_warn_count == 0 && test_error_count == 0);
+	test_a2dp_encoding(&transport, io_thread_a2dp_source_aac);
 
 	transport.mtu_read = transport.mtu_write;
-	assert(test_a2dp_decoding(&transport, io_thread_a2dp_sink_aac) == 0);
-	assert(test_warn_count == 0 && test_error_count == 0);
+	test_a2dp_decoding(&transport, io_thread_a2dp_sink_aac);
 
-	return 0;
-}
+} END_TEST
 #endif
 
 #if ENABLE_APTX
-int test_a2dp_aptx(void) {
+START_TEST(test_a2dp_aptx) {
 
 	struct ba_transport transport = {
 		.codec = A2DP_CODEC_VENDOR_APTX,
@@ -255,21 +208,54 @@ int test_a2dp_aptx(void) {
 	};
 
 	transport.mtu_write = 40;
-	assert(test_a2dp_encoding(&transport, io_thread_a2dp_source_aptx) == 0);
-	assert(test_warn_count == 0 && test_error_count == 0);
+	test_a2dp_encoding(&transport, io_thread_a2dp_source_aptx);
 
-	return 0;
-}
+} END_TEST
+#endif
+
+#if ENABLE_LDAC
+START_TEST(test_a2dp_ldac) {
+
+	struct ba_transport transport = {
+		.profile = BLUETOOTH_PROFILE_A2DP_SOURCE,
+		.codec = A2DP_CODEC_VENDOR_LDAC,
+		.a2dp = {
+			.cconfig = (uint8_t *)&config_ldac_44100_stereo,
+			.cconfig_size = sizeof(config_ldac_44100_stereo),
+		},
+	};
+
+	transport.mtu_write = RTP_HEADER_LEN + sizeof(rtp_media_header_t) + 679;
+	test_a2dp_encoding(&transport, io_thread_a2dp_source_ldac);
+
+} END_TEST
 #endif
 
 int main(void) {
-	test_run(test_a2dp_sbc_invalid_setup);
-	test_run(test_a2dp_sbc);
+
+	Suite *s = suite_create(__FILE__);
+	TCase *tc = tcase_create(__FILE__);
+	SRunner *sr = srunner_create(s);
+
+	suite_add_tcase(s, tc);
+
+	tcase_add_test(tc, test_a2dp_sbc);
 #if ENABLE_AAC
-	test_run(test_a2dp_aac);
+	config.aac_afterburner = true;
+	tcase_add_test(tc, test_a2dp_aac);
 #endif
 #if ENABLE_APTX
-	test_run(test_a2dp_aptx);
+	tcase_add_test(tc, test_a2dp_aptx);
+#endif
+#if ENABLE_LDAC
+	config.ldac_abr = true;
+	config.ldac_eqmid = LDACBT_EQMID_HQ;
+	tcase_add_test(tc, test_a2dp_ldac);
 #endif
-	return 0;
+
+	srunner_run_all(sr, CK_ENV);
+	int nf = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return nf == 0 ? 0 : 1;
 }
diff --git a/test/test-pcm.c b/test/test-pcm.c
index 06923c9..4c878e4 100644
--- a/test/test-pcm.c
+++ b/test/test-pcm.c
@@ -1,6 +1,6 @@
 /*
  * test-pcm.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,65 +8,48 @@
  *
  */
 
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <getopt.h>
 #include <libgen.h>
 #include <spawn.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/wait.h>
+
+#include <check.h>
 #include <alsa/asoundlib.h>
+
+#include "inc/preload.inc"
+#include "inc/server.inc"
 #include "inc/sine.inc"
-#include "inc/test.inc"
 #include "../src/shared/ffb.c"
-#include "../src/shared/log.h"
-
-
-static char *bin_path = NULL;
-static pid_t bluealsa_pid = 0;
-
-static pid_t start_bluealsa(bool source, unsigned int timeout) {
-
-	char path[256];
-	char arg_timeout[16];
-	pid_t pid;
-
-	sprintf(arg_timeout, "--timeout=%d", timeout);
-
-	char *argv[] = {
-		"test-server",
-		source ? "--source" : "--sink",
-		arg_timeout,
-		NULL,
-	};
-
-	sprintf(path, "%s/test-server", bin_path);
-	/* assert(posix_spawn(&pid, path, NULL, NULL, argv, NULL) == 0); */
-
-	/* XXX: workaround for valgrind-3.13.0 */
-	if ((pid = fork()) == 0)
-		execv(path, argv);
-
-	usleep(100000);
-	return pid;
-}
+#include "../src/shared/log.c"
 
-static int snd_pcm_open_bluealsa(snd_pcm_t **pcmp, snd_pcm_stream_t stream, int mode) {
+#define buffer_test_frames 1024
+#define dumprv(fn) fprintf(stderr, #fn " = %d\n", (int)fn)
 
-	static char buffer[] =
-		"pcm.bluealsa {\n"
-		"  type bluealsa\n"
-		"  interface \"hci-xxx\"\n"
-		"  device \"12:34:56:78:9A:BC\"\n"
-		"  profile \"a2dp\"\n"
-		"  delay 0\n"
-		"}\n";
+static int snd_pcm_open_bluealsa(snd_pcm_t **pcmp, const char *hci, snd_pcm_stream_t stream, int mode) {
 
+	char buffer[256];
 	snd_config_t *conf = NULL;
 	snd_input_t *input = NULL;
 	int err;
 
+	sprintf(buffer,
+			"pcm.bluealsa {\n"
+			"  type bluealsa\n"
+			"  interface \"%s\"\n"
+			"  device \"12:34:56:78:9A:BC\"\n"
+			"  profile \"a2dp\"\n"
+			"  delay 0\n"
+			"}\n", hci);
+
 	if ((err = snd_config_top(&conf)) < 0)
 		goto fail;
-	if ((err = snd_input_buffer_open(&input, buffer, sizeof(buffer) - 1)) != 0)
+	if ((err = snd_input_buffer_open(&input, buffer, strlen(buffer))) != 0)
 		goto fail;
 	if ((err = snd_config_load(conf, input)) != 0)
 		goto fail;
@@ -144,9 +127,12 @@ static int set_sw_params(snd_pcm_t *pcm, snd_pcm_uframes_t buffer_size, snd_pcm_
 	return 0;
 }
 
-int test_playback_hw_constraints(void) {
+START_TEST(test_playback_hw_constraints) {
+
+	const char *hci = "hci-tp1";
+	pid_t pid = spawn_bluealsa_server(hci, 1, false, true, false);
 
-	/* hard-coded values used in the test-server */
+	/* hard-coded values used in the server-mock */
 	const unsigned int server_channels = 2;
 	const unsigned int server_rate = 44100;
 
@@ -154,50 +140,71 @@ int test_playback_hw_constraints(void) {
 	snd_pcm_hw_params_t *params;
 	int d;
 
-	assert(snd_pcm_open_bluealsa(&pcm, SND_PCM_STREAM_PLAYBACK, 0) == 0);
+	ck_assert_int_eq(snd_pcm_open_bluealsa(&pcm, hci, SND_PCM_STREAM_PLAYBACK, 0), 0);
 
 	snd_pcm_hw_params_alloca(&params);
 	snd_pcm_hw_params_any(pcm, params);
 
-	assert(snd_pcm_hw_params_test_access(pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED) == 0);
-	assert(snd_pcm_hw_params_test_access(pcm, params, SND_PCM_ACCESS_MMAP_INTERLEAVED) == 0);
-	assert(snd_pcm_hw_params_set_access(pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED) == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_test_access(pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED), 0);
+	ck_assert_int_eq(snd_pcm_hw_params_test_access(pcm, params, SND_PCM_ACCESS_MMAP_INTERLEAVED), 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_access(pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED), 0);
 
 	snd_pcm_format_t format;
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_format_first(pcm, params, &format) == 0 && format == SND_PCM_FORMAT_S16_LE);
+	ck_assert_int_eq(snd_pcm_hw_params_set_format_first(pcm, params, &format), 0);
+	ck_assert_int_eq(format, SND_PCM_FORMAT_S16_LE);
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_format_last(pcm, params, &format) == 0 && format == SND_PCM_FORMAT_S16_LE);
+	ck_assert_int_eq(snd_pcm_hw_params_set_format_last(pcm, params, &format), 0);
+	ck_assert_int_eq(format, SND_PCM_FORMAT_S16_LE);
 
 	unsigned int channels;
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_channels_first(pcm, params, &channels) == 0 && channels == server_channels);
+	ck_assert_int_eq(snd_pcm_hw_params_set_channels_first(pcm, params, &channels), 0);
+	ck_assert_int_eq(channels, server_channels);
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_channels_last(pcm, params, &channels) == 0 && channels == server_channels);
+	ck_assert_int_eq(snd_pcm_hw_params_set_channels_last(pcm, params, &channels), 0);
+	ck_assert_int_eq(channels, server_channels);
 
 	unsigned int rate;
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_rate_first(pcm, params, &rate, &d) == 0 && rate == server_rate && d == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_rate_first(pcm, params, &rate, &d), 0);
+	ck_assert_int_eq(rate, server_rate);
+	ck_assert_int_eq(d, 0);
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_rate_last(pcm, params, &rate, &d) == 0 && rate == server_rate && d == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_rate_last(pcm, params, &rate, &d), 0);
+	ck_assert_int_eq(rate, server_rate);
+	ck_assert_int_eq(d, 0);
 
 	unsigned int periods;
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_periods_first(pcm, params, &periods, &d) == 0 && periods == 3 && d == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_periods_first(pcm, params, &periods, &d), 0);
+	ck_assert_int_eq(periods, 3);
+	ck_assert_int_eq(d, 0);
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_periods_last(pcm, params, &periods, &d) == 0 && periods == 1024 && d == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_periods_last(pcm, params, &periods, &d), 0);
+	ck_assert_int_eq(periods, 1024);
+	ck_assert_int_eq(d, 0);
 
 	unsigned int time;
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_buffer_time_first(pcm, params, &time, &d) == 0 && time == 200000 && d == 0);
+	ck_assert_int_eq(snd_pcm_hw_params_set_buffer_time_first(pcm, params, &time, &d), 0);
+	ck_assert_int_eq(time, 200000);
+	ck_assert_int_eq(d, 0);
 	snd_pcm_hw_params_any(pcm, params);
-	assert(snd_pcm_hw_params_set_buffer_time_last(pcm, params, &time, &d) == 0 && time == 95108934 && d == 1);
+	ck_assert_int_eq(snd_pcm_hw_params_set_buffer_time_last(pcm, params, &time, &d), 0);
+	ck_assert_int_eq(time, 95108934);
+	ck_assert_int_eq(d, 1);
 
-	assert(snd_pcm_close(pcm) == 0);
-	return 0;
-}
+	ck_assert_int_eq(snd_pcm_close(pcm), 0);
+
+	waitpid(pid, NULL, 0);
+
+} END_TEST
+
+START_TEST(test_playback) {
 
-int test_playback(void) {
+	const char *hci = "hci-tp2";
+	pid_t pid = spawn_bluealsa_server(hci, 2, false, true, false);
 
 	int pcm_channels = 2;
 	int pcm_sampling = 44100;
@@ -209,11 +216,11 @@ int test_playback(void) {
 	snd_pcm_uframes_t period_size;
 	snd_pcm_sframes_t delay;
 
-	assert(snd_pcm_open_bluealsa(&pcm, SND_PCM_STREAM_PLAYBACK, 0) == 0);
-	assert(set_hw_params(pcm, pcm_channels, pcm_sampling, &pcm_buffer_time, &pcm_period_time) == 0);
-	assert(snd_pcm_get_params(pcm, &buffer_size, &period_size) == 0);
-	assert(set_sw_params(pcm, buffer_size, period_size) == 0);
-	assert(snd_pcm_prepare(pcm) == 0);
+	ck_assert_int_eq(snd_pcm_open_bluealsa(&pcm, hci, SND_PCM_STREAM_PLAYBACK, 0), 0);
+	ck_assert_int_eq(set_hw_params(pcm, pcm_channels, pcm_sampling, &pcm_buffer_time, &pcm_period_time), 0);
+	ck_assert_int_eq(snd_pcm_get_params(pcm, &buffer_size, &period_size), 0);
+	ck_assert_int_eq(set_sw_params(pcm, buffer_size, period_size), 0);
+	ck_assert_int_eq(snd_pcm_prepare(pcm), 0);
 
 	int16_t *period = malloc(period_size * pcm_channels * sizeof(int16_t));
 	int i, x = 0;
@@ -222,116 +229,223 @@ int test_playback(void) {
 	int buffer_period_count = (buffer_size - 10) / period_size + 1;
 	for (i = 0; i < buffer_period_count - 1; i++) {
 		x = snd_pcm_sine_s16le(period, period_size * pcm_channels, pcm_channels, x, 441.0 / pcm_sampling);
-		assert(snd_pcm_writei(pcm, period, period_size) > 0);
+		ck_assert_int_gt(snd_pcm_writei(pcm, period, period_size), 0);
 	}
 
 	usleep(100000);
 
 	/* check if playback was not started and if delay is correctly calculated */
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_PREPARED);
-	assert(snd_pcm_delay(pcm, &delay) == 0);
-	assert(delay == 18375);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_PREPARED);
+	ck_assert_int_eq(snd_pcm_delay(pcm, &delay), 0);
+	ck_assert_int_eq(delay, 18375);
 
 	/* start playback - start threshold will be exceeded */
 	x = snd_pcm_sine_s16le(period, period_size * pcm_channels, pcm_channels, x, 441.0 / pcm_sampling);
-	assert(snd_pcm_writei(pcm, period, period_size) > 0);
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_RUNNING);
+	ck_assert_int_gt(snd_pcm_writei(pcm, period, period_size), 0);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_RUNNING);
 
 	/* at this point buffer should be still almost full */
-	assert(snd_pcm_delay(pcm, &delay) == 0);
-	assert(delay > 20000);
+	ck_assert_int_eq(snd_pcm_delay(pcm, &delay), 0);
+	ck_assert_int_gt(delay, 20000);
 
 	snd_pcm_pause(pcm, 1);
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_PAUSED);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_PAUSED);
 
 	/* during pause buffer shall not be consumed */
 	usleep(100000);
-	assert(snd_pcm_delay(pcm, &delay) == 0);
-	assert(delay > 10000);
+	ck_assert_int_eq(snd_pcm_delay(pcm, &delay), 0);
+	ck_assert_int_gt(delay, 10000);
 
 	snd_pcm_pause(pcm, 0);
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_RUNNING);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_RUNNING);
 
 	/* allow under-run to occur */
 	usleep(500000);
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_XRUN);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_XRUN);
 
 	/* check successful recovery */
-	assert(snd_pcm_prepare(pcm) == 0);
+	ck_assert_int_eq(snd_pcm_prepare(pcm), 0);
 	for (i = 0; i < buffer_period_count * 2; i++) {
 		x = snd_pcm_sine_s16le(period, period_size * pcm_channels, pcm_channels, x, 441.0 / pcm_sampling);
-		assert(snd_pcm_writei(pcm, period, period_size) > 0);
+		ck_assert_int_gt(snd_pcm_writei(pcm, period, period_size), 0);
 	}
-	assert(snd_pcm_state(pcm) == SND_PCM_STATE_RUNNING);
+	ck_assert_int_eq(snd_pcm_state(pcm), SND_PCM_STATE_RUNNING);
 
-	assert(snd_pcm_close(pcm) == 0);
+	ck_assert_int_eq(snd_pcm_close(pcm), 0);
 
 	free(period);
-	return 0;
-}
+	waitpid(pid, NULL, 0);
 
-int test_playback_termination(void) {
+} END_TEST
 
-	int pcm_channels = 2;
-	int pcm_sampling = 44100;
+/**
+ * Make reference test for playback termination.
+ *
+ * Values obtained with an external USB sound card:
+ * - frames = -19
+ * - snd_pcm_poll_descriptors_count(pcm) = 1
+ * - snd_pcm_poll_descriptors(pcm, pfds, 4) = 1
+ * - snd_pcm_poll_descriptors_revents(pcm, pfds, 4, &revents) = 0
+ * - snd_pcm_prepare(pcm) = -19
+ * - snd_pcm_reset(pcm) = 0
+ * - snd_pcm_start(pcm) = -19
+ * - snd_pcm_drop(pcm) = -19
+ * - snd_pcm_drain(pcm) = -19
+ * - snd_pcm_pause(pcm, 0) = -19
+ * - snd_pcm_delay(pcm, &frames) = -19
+ * - snd_pcm_resume(pcm) = -38
+ * - snd_pcm_avail(pcm) = -19
+ * - snd_pcm_avail_update(pcm) = 15081
+ * - snd_pcm_writei(pcm, buffer, buffer_test_frames) = -19
+ * - snd_pcm_wait(pcm, 10) = -19
+ * - snd_pcm_close(pcm) = 0
+ */
+void test_playback_termination_reference(const char *name) {
+
+	snd_pcm_t *pcm = NULL;
 	unsigned int pcm_buffer_time = 500000;
 	unsigned int pcm_period_time = 100000;
+	struct pollfd pfds[2];
+	unsigned short revents;
+	int err;
+
+	if ((err = snd_pcm_open(&pcm, name, SND_PCM_STREAM_PLAYBACK, 0)) != 0) {
+		error("snd_pcm_open: %s", snd_strerror(err));
+		return;
+	}
+	if (set_hw_params(pcm, 2, 44100, &pcm_buffer_time, &pcm_period_time) != 0)
+		return;
+	if ((err = snd_pcm_prepare(pcm)) != 0) {
+		error("snd_pcm_prepare: %s", snd_strerror(err));
+		return;
+	}
+
+	int16_t buffer[buffer_test_frames * 2] = { 0 };
+	snd_pcm_sframes_t frames = 0;
+
+	fprintf(stderr, "Unplug PCM device...");
+	while (frames >= 0)
+		frames = snd_pcm_writei(pcm, buffer, buffer_test_frames);
+	fprintf(stderr, "\n");
+
+	dumprv(frames);
+	dumprv(snd_pcm_poll_descriptors_count(pcm));
+	dumprv(snd_pcm_poll_descriptors(pcm, pfds, 4));
+	dumprv(snd_pcm_poll_descriptors_revents(pcm, pfds, 4, &revents));
+	dumprv(snd_pcm_prepare(pcm));
+	dumprv(snd_pcm_reset(pcm));
+	dumprv(snd_pcm_start(pcm));
+	dumprv(snd_pcm_drop(pcm));
+	dumprv(snd_pcm_drain(pcm));
+	dumprv(snd_pcm_pause(pcm, 0));
+	dumprv(snd_pcm_delay(pcm, &frames));
+	dumprv(snd_pcm_resume(pcm));
+	dumprv(snd_pcm_avail(pcm));
+	dumprv(snd_pcm_avail_update(pcm));
+	dumprv(snd_pcm_writei(pcm, buffer, buffer_test_frames));
+	dumprv(snd_pcm_wait(pcm, 10));
+	dumprv(snd_pcm_close(pcm));
+
+}
+
+START_TEST(test_playback_termination) {
+
+	const char *hci = "hci-tp3";
+	pid_t pid = spawn_bluealsa_server(hci, 2, false, true, false);
 
 	snd_pcm_t *pcm = NULL;
-	snd_pcm_uframes_t buffer_size;
-	snd_pcm_uframes_t period_size;
+	unsigned int pcm_buffer_time = 500000;
+	unsigned int pcm_period_time = 100000;
 
-	assert(snd_pcm_open_bluealsa(&pcm, SND_PCM_STREAM_PLAYBACK, 0) == 0);
-	assert(set_hw_params(pcm, pcm_channels, pcm_sampling, &pcm_buffer_time, &pcm_period_time) == 0);
-	assert(snd_pcm_get_params(pcm, &buffer_size, &period_size) == 0);
-	assert(snd_pcm_prepare(pcm) == 0);
+	ck_assert_int_eq(snd_pcm_open_bluealsa(&pcm, hci, SND_PCM_STREAM_PLAYBACK, 0), 0);
+	ck_assert_int_eq(set_hw_params(pcm, 2, 44100, &pcm_buffer_time, &pcm_period_time), 0);
+	ck_assert_int_eq(snd_pcm_prepare(pcm), 0);
 
-	int16_t *period = malloc(period_size * pcm_channels * sizeof(int16_t));
+	int16_t buffer[buffer_test_frames * 2] = { 0 };
 	snd_pcm_sframes_t frames = 0;
 	size_t i = 0;
 
 	/* write samples until server disconnects */
 	while (frames >= 0) {
 		if (i++ == 10)
-			kill(bluealsa_pid, SIGUSR2);
-		frames = snd_pcm_writei(pcm, period, period_size);
+			kill(pid, SIGUSR2);
+		frames = snd_pcm_writei(pcm, buffer, buffer_test_frames);
 	}
 
+#if 0
 	/* check if most commonly used calls will report missing device */
 
-	struct pollfd pfds[2];
+	struct pollfd pfds[4];
 	unsigned short revents;
 
-	assert(frames == -ENODEV);
-	assert(snd_pcm_poll_descriptors_revents(pcm, pfds, 2, &revents) == -ENODEV);
-	assert(snd_pcm_writei(pcm, period, period_size) == -ENODEV);
-	assert(snd_pcm_avail_update(pcm) == -ENODEV);
-	assert(snd_pcm_delay(pcm, &frames) == -ENODEV);
-	assert(snd_pcm_prepare(pcm) == -EBADFD);
-	assert(snd_pcm_close(pcm) == -EACCES);
-
-	free(period);
-	return 0;
-}
+	ck_assert_int_eq(frames, -ENODEV);
+	ck_assert_int_eq(snd_pcm_poll_descriptors_count(pcm), 2);
+	ck_assert_int_eq(snd_pcm_poll_descriptors(pcm, pfds, 4), 2);
+	ck_assert_int_eq(snd_pcm_poll_descriptors_revents(pcm, pfds, 4, &revents), -ENODEV);
+	ck_assert_int_eq(snd_pcm_prepare(pcm), -ENODEV);
+	ck_assert_int_eq(snd_pcm_reset(pcm), 0);
+	ck_assert_int_eq(snd_pcm_start(pcm), -EBADFD);
+	ck_assert_int_eq(snd_pcm_drop(pcm), 0);
+	ck_assert_int_eq(snd_pcm_drain(pcm), -EBADFD);
+	ck_assert_int_eq(snd_pcm_pause(pcm, 0), -EBADFD);
+	ck_assert_int_eq(snd_pcm_delay(pcm, &frames), -ENODEV);
+	ck_assert_int_eq(snd_pcm_resume(pcm), 0);
+	ck_assert_int_eq(snd_pcm_avail(pcm), -EPIPE);
+	ck_assert_int_eq(snd_pcm_avail_update(pcm), -EPIPE);
+	ck_assert_int_eq(snd_pcm_writei(pcm, buffer, buffer_test_frames), -EPIPE);
+	ck_assert_int_eq(snd_pcm_wait(pcm, 10), -EPIPE);
+	ck_assert_int_eq(snd_pcm_close(pcm), 0);
+#endif
+
+	waitpid(pid, NULL, 0);
+
+} END_TEST
 
 int test_capture(void) {
 	return 0;
 }
 
 int main(int argc, char *argv[]) {
-	(void)argc;
 
-	/* test-pcm and test-server shall be placed in the same directory */
+	preload(argc, argv, ".libs/aloader.so");
+
+	int opt;
+	const char *opts = "h";
+	struct option longopts[] = {
+		{ "help", no_argument, NULL, 'h' },
+		{ "pcm", required_argument, NULL, 'd' },
+		{ 0, 0, 0, 0 },
+	};
+
+	while ((opt = getopt_long(argc, argv, opts, longopts, NULL)) != -1)
+		switch (opt) {
+		case 'h' /* --help */ :
+			printf("usage: %s [--pcm=NAME]\n", argv[0]);
+			return 0;
+		case 'd' /* --pcm */ :
+			test_playback_termination_reference(optarg);
+			return 0;
+		default:
+			fprintf(stderr, "Try '%s --help' for more information.\n", argv[0]);
+			return 1;
+		}
+
+	/* test-pcm and server-mock shall be placed in the same directory */
 	bin_path = dirname(argv[0]);
 
-	bluealsa_pid = start_bluealsa(true, 3);
-	test_run(test_playback_hw_constraints);
-	test_run(test_playback);
-	waitpid(bluealsa_pid, NULL, 0);
+	Suite *s = suite_create(__FILE__);
+	TCase *tc = tcase_create(__FILE__);
+	SRunner *sr = srunner_create(s);
+
+	suite_add_tcase(s, tc);
+
+	tcase_add_test(tc, test_playback_hw_constraints);
+	tcase_add_test(tc, test_playback);
+	tcase_add_test(tc, test_playback_termination);
 
-	bluealsa_pid = start_bluealsa(true, 2);
-	test_run(test_playback_termination);
-	waitpid(bluealsa_pid, NULL, 0);
+	srunner_run_all(sr, CK_ENV);
+	int nf = srunner_ntests_failed(sr);
+	srunner_free(sr);
 
-	return EXIT_SUCCESS;
+	return nf == 0 ? 0 : 1;
 }
diff --git a/test/test-utils.c b/test/test-utils.c
index 9ffabd1..b704b42 100644
--- a/test/test-utils.c
+++ b/test/test-utils.c
@@ -1,6 +1,6 @@
 /*
  * test-utils.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -8,13 +8,15 @@
  *
  */
 
-#include "inc/test.inc"
+#include <check.h>
+
 #include "../src/utils.c"
 #include "../src/shared/defs.h"
 #include "../src/shared/ffb.c"
+#include "../src/shared/log.c"
 #include "../src/shared/rt.c"
 
-int test_dbus_profile_object_path(void) {
+START_TEST(test_dbus_profile_object_path) {
 
 	static const struct {
 		enum bluetooth_profile profile;
@@ -40,6 +42,10 @@ int test_dbus_profile_object_path(void) {
 #if ENABLE_APTX
 		{ BLUETOOTH_PROFILE_A2DP_SOURCE, A2DP_CODEC_VENDOR_APTX, "/A2DP/APTX/Source" },
 		{ BLUETOOTH_PROFILE_A2DP_SINK, A2DP_CODEC_VENDOR_APTX, "/A2DP/APTX/Sink" },
+#endif
+#if ENABLE_LDAC
+		{ BLUETOOTH_PROFILE_A2DP_SOURCE, A2DP_CODEC_VENDOR_LDAC, "/A2DP/LDAC/Source" },
+		{ BLUETOOTH_PROFILE_A2DP_SINK, A2DP_CODEC_VENDOR_LDAC, "/A2DP/LDAC/Sink" },
 #endif
 		/* test HSP/HFP profiles */
 		{ BLUETOOTH_PROFILE_HSP_HS, -1, "/HSP/Headset" },
@@ -52,118 +58,182 @@ int test_dbus_profile_object_path(void) {
 
 	for (i = 0; i < ARRAYSIZE(profiles); i++) {
 		const char *path = g_dbus_get_profile_object_path(profiles[i].profile, profiles[i].codec);
-		assert(strstr(profiles[i].path, path) == profiles[i].path);
-		assert(g_dbus_object_path_to_profile(profiles[i].path) == profiles[i].profile);
-		if (profiles[i].codec != -1)
-			assert(g_dbus_object_path_to_a2dp_codec(profiles[i].path) == profiles[i].codec);
+		ck_assert_str_eq(strstr(profiles[i].path, path), profiles[i].path);
+		ck_assert_int_eq(g_dbus_object_path_to_profile(profiles[i].path), profiles[i].profile);
 	}
 
-	return 0;
-}
+} END_TEST
+
+START_TEST(test_batostr_) {
 
-int test_pcm_scale_s16le(void) {
+	const bdaddr_t ba = {{ 1, 2, 3, 4, 5, 6 }};
+	char tmp[18];
+
+	ba2str(&ba, tmp);
+	ck_assert_str_eq(batostr_(&ba), tmp);
+
+} END_TEST
+
+START_TEST(test_snd_pcm_scale_s16le) {
 
 	const int16_t mute[] = { 0x0000, 0x0000, 0x0000, 0x0000 };
 	const int16_t half[] = { 0x1234 / 2, 0x2345 / 2, (int16_t)0xBCDE / 2, (int16_t)0xCDEF / 2 };
-	const int16_t halfl[] = { 0x1234 / 2, 0x2345, (int16_t)0xBCDE / 2, 0xCDEF };
-	const int16_t halfr[] = { 0x1234, 0x2345 / 2, 0xBCDE, (int16_t)0xCDEF / 2 };
-	const int16_t in[] = { 0x1234, 0x2345, 0xBCDE, 0xCDEF };
+	const int16_t halfl[] = { 0x1234 / 2, 0x2345, (int16_t)0xBCDE / 2, (int16_t)0xCDEF };
+	const int16_t halfr[] = { 0x1234, 0x2345 / 2, (int16_t)0xBCDE, (int16_t)0xCDEF / 2 };
+	const int16_t in[] = { 0x1234, 0x2345, (int16_t)0xBCDE, (int16_t)0xCDEF };
 	int16_t tmp[ARRAYSIZE(in)];
 
 	memcpy(tmp, in, sizeof(tmp));
 	snd_pcm_scale_s16le(tmp, ARRAYSIZE(tmp), 1, 0, 0);
-	assert(memcmp(tmp, mute, sizeof(mute)) == 0);
+	ck_assert_int_eq(memcmp(tmp, mute, sizeof(mute)), 0);
 
 	memcpy(tmp, in, sizeof(tmp));
 	snd_pcm_scale_s16le(tmp, ARRAYSIZE(tmp), 1, 1.0, 1.0);
-	assert(memcmp(tmp, in, sizeof(in)) == 0);
+	ck_assert_int_eq(memcmp(tmp, in, sizeof(in)), 0);
 
 	memcpy(tmp, in, sizeof(tmp));
 	snd_pcm_scale_s16le(tmp, ARRAYSIZE(tmp), 1, 0.5, 0.5);
-	assert(memcmp(tmp, half, sizeof(half)) == 0);
+	ck_assert_int_eq(memcmp(tmp, half, sizeof(half)), 0);
 
 	memcpy(tmp, in, sizeof(tmp));
 	snd_pcm_scale_s16le(tmp, ARRAYSIZE(tmp), 2, 0.5, 1.0);
-	assert(memcmp(tmp, halfl, sizeof(halfl)) == 0);
+	ck_assert_int_eq(memcmp(tmp, halfl, sizeof(halfl)), 0);
 
 	memcpy(tmp, in, sizeof(tmp));
 	snd_pcm_scale_s16le(tmp, ARRAYSIZE(tmp), 2, 1.0, 0.5);
-	assert(memcmp(tmp, halfr, sizeof(halfr)) == 0);
+	ck_assert_int_eq(memcmp(tmp, halfr, sizeof(halfr)), 0);
 
-	return 0;
-}
+} END_TEST
 
-int test_difftimespec(void) {
+START_TEST(test_difftimespec) {
 
 	struct timespec ts1, ts2, ts;
 
 	ts1.tv_sec = ts2.tv_sec = 12345;
 	ts1.tv_nsec = ts2.tv_nsec = 67890;
-	assert(difftimespec(&ts1, &ts2, &ts) == 0);
-	assert(ts.tv_sec == 0 && ts.tv_nsec == 0);
+	ck_assert_int_eq(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 0);
+	ck_assert_int_eq(ts.tv_nsec, 0);
 
 	ts1.tv_sec = 10;
 	ts1.tv_nsec = 100000000;
 	ts2.tv_sec = 10;
 	ts2.tv_nsec = 500000000;
-	assert(difftimespec(&ts1, &ts2, &ts) > 0);
-	assert(ts.tv_sec == 0 && ts.tv_nsec == 400000000);
+	ck_assert_int_gt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 0);
+	ck_assert_int_eq(ts.tv_nsec, 400000000);
+
+	ts1.tv_sec = 10;
+	ts1.tv_nsec = 100000000;
+	ts2.tv_sec = 11;
+	ts2.tv_nsec = 500000000;
+	ck_assert_int_gt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 1);
+	ck_assert_int_eq(ts.tv_nsec, 400000000);
 
 	ts1.tv_sec = 10;
 	ts1.tv_nsec = 800000000;
 	ts2.tv_sec = 12;
 	ts2.tv_nsec = 100000000;
-	assert(difftimespec(&ts1, &ts2, &ts) > 0);
-	assert(ts.tv_sec == 1 && ts.tv_nsec == 300000000);
+	ck_assert_int_gt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 1);
+	ck_assert_int_eq(ts.tv_nsec, 300000000);
 
 	ts1.tv_sec = 10;
 	ts1.tv_nsec = 500000000;
 	ts2.tv_sec = 10;
 	ts2.tv_nsec = 100000000;
-	assert(difftimespec(&ts1, &ts2, &ts) < 0);
-	assert(ts.tv_sec == 0 && ts.tv_nsec == 400000000);
+	ck_assert_int_lt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 0);
+	ck_assert_int_eq(ts.tv_nsec, 400000000);
 
 	ts1.tv_sec = 12;
 	ts1.tv_nsec = 100000000;
 	ts2.tv_sec = 10;
 	ts2.tv_nsec = 800000000;
-	assert(difftimespec(&ts1, &ts2, &ts) < 0);
-	assert(ts.tv_sec == 1 && ts.tv_nsec == 300000000);
+	ck_assert_int_lt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 1);
+	ck_assert_int_eq(ts.tv_nsec, 300000000);
 
-	return 0;
-}
+	ts1.tv_sec = 12;
+	ts1.tv_nsec = 500000000;
+	ts2.tv_sec = 10;
+	ts2.tv_nsec = 500000000;
+	ck_assert_int_lt(difftimespec(&ts1, &ts2, &ts), 0);
+	ck_assert_int_eq(ts.tv_sec, 2);
+	ck_assert_int_eq(ts.tv_nsec, 0);
 
-int test_fifo_buffer(void) {
+} END_TEST
 
-	ffb_uint8_t ffb = { 0 };
+START_TEST(test_fifo_buffer) {
 
-	assert(ffb_init(&ffb, 64) != NULL);
-	assert(ffb.data == ffb.tail);
-	assert(ffb.size == 64);
+	ffb_uint8_t ffb_u8 = { 0 };
+	ffb_int16_t ffb_16 = { 0 };
 
-	memcpy(ffb.data, "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ", 36);
-	ffb_seek(&ffb, 36);
+	/* allow free before allocation */
+	ffb_uint8_free(&ffb_u8);
+	ffb_int16_free(&ffb_16);
 
-	assert(ffb_len_in(&ffb) == 64 - 36);
-	assert(ffb_len_out(&ffb) == 36);
-	assert(ffb.tail[-1] == 'Z');
+	ck_assert_ptr_ne(ffb_init(&ffb_u8, 64), NULL);
+	ck_assert_ptr_eq(ffb_u8.data, ffb_u8.tail);
+	ck_assert_int_eq(ffb_u8.size, 64);
 
-	ffb_shift(&ffb, 15);
-	assert(ffb_len_in(&ffb) == 64 - (36 - 15));
-	assert(ffb_len_out(&ffb) == 36 - 15);
-	assert(memcmp(ffb.data, "FGHIJKLMNOPQRSTUVWXYZ", ffb_len_out(&ffb)) == 0);
-	assert(ffb.tail[-1] == 'Z');
+	ck_assert_ptr_ne(ffb_init(&ffb_16, 64), NULL);
+	ck_assert_ptr_eq(ffb_16.data, ffb_16.tail);
+	ck_assert_int_eq(ffb_16.size, 64);
 
-	ffb_rewind(&ffb);
-	assert(ffb.data == ffb.tail);
+	memcpy(ffb_u8.data, "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ", 36);
+	ffb_seek(&ffb_u8, 36);
 
-	return 0;
-}
+	memcpy(ffb_16.data, "11223344556677889900AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ", 36 * 2);
+	ffb_seek(&ffb_16, 36);
+
+	ck_assert_int_eq(ffb_len_in(&ffb_u8), 64 - 36);
+	ck_assert_int_eq(ffb_blen_in(&ffb_u8), 64 - 36);
+	ck_assert_int_eq(ffb_len_out(&ffb_u8), 36);
+	ck_assert_int_eq(ffb_blen_out(&ffb_u8), 36);
+	ck_assert_int_eq(ffb_u8.tail[-1], 'Z');
+
+	ck_assert_int_eq(ffb_len_in(&ffb_16), 64 - 36);
+	ck_assert_int_eq(ffb_blen_in(&ffb_16), (64 - 36) * 2);
+	ck_assert_int_eq(ffb_len_out(&ffb_16), 36);
+	ck_assert_int_eq(ffb_blen_out(&ffb_16), 36 * 2);
+	ck_assert_int_eq(ffb_16.tail[-1], 0x5a5a);
+
+	ffb_shift(&ffb_u8, 15);
+	ck_assert_int_eq(ffb_len_in(&ffb_u8), 64 - (36 - 15));
+	ck_assert_int_eq(ffb_len_out(&ffb_u8), 36 - 15);
+	ck_assert_int_eq(memcmp(ffb_u8.data, "FGHIJKLMNOPQRSTUVWXYZ", ffb_len_out(&ffb_u8)), 0);
+	ck_assert_int_eq(ffb_u8.tail[-1], 'Z');
+
+	ffb_rewind(&ffb_u8);
+	ck_assert_ptr_eq(ffb_u8.data, ffb_u8.tail);
+
+	ffb_uint8_free(&ffb_u8);
+	ck_assert_ptr_eq(ffb_u8.data, NULL);
+
+	ffb_int16_free(&ffb_16);
+	ck_assert_ptr_eq(ffb_16.data, NULL);
+
+} END_TEST
 
 int main(void) {
-	test_run(test_dbus_profile_object_path);
-	test_run(test_pcm_scale_s16le);
-	test_run(test_difftimespec);
-	test_run(test_fifo_buffer);
-	return 0;
+
+	Suite *s = suite_create(__FILE__);
+	TCase *tc = tcase_create(__FILE__);
+	SRunner *sr = srunner_create(s);
+
+	suite_add_tcase(s, tc);
+
+	tcase_add_test(tc, test_dbus_profile_object_path);
+	tcase_add_test(tc, test_batostr_);
+	tcase_add_test(tc, test_snd_pcm_scale_s16le);
+	tcase_add_test(tc, test_difftimespec);
+	tcase_add_test(tc, test_fifo_buffer);
+
+	srunner_run_all(sr, CK_ENV);
+	int nf = srunner_ntests_failed(sr);
+	srunner_free(sr);
+
+	return nf == 0 ? 0 : 1;
 }
diff --git a/utils/aplay.c b/utils/aplay.c
index c154910..2225312 100644
--- a/utils/aplay.c
+++ b/utils/aplay.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - aplay.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -9,7 +9,7 @@
  */
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <getopt.h>
@@ -39,8 +39,6 @@ struct pcm_worker {
 	int pcm_fd;
 	/* opened playback PCM device */
 	snd_pcm_t *pcm;
-	/* if true, worker is marked for eviction */
-	bool eviction;
 	/* if true, playback is active */
 	bool active;
 	/* human-readable BT address */
@@ -50,9 +48,12 @@ struct pcm_worker {
 static unsigned int verbose = 0;
 static const char *device = "default";
 static const char *ba_interface = "hci0";
+static enum ba_pcm_type ba_type = BA_PCM_TYPE_A2DP;
+static bool ba_addr_any = false;
+static bdaddr_t *ba_addrs = NULL;
+static size_t ba_addrs_count = 0;
 static unsigned int pcm_buffer_time = 500000;
 static unsigned int pcm_period_time = 100000;
-static enum ba_pcm_type ba_type = BA_PCM_TYPE_A2DP;
 static bool pcm_mixer = true;
 
 static GDBusConnection *dbus = NULL;
@@ -73,6 +74,25 @@ static void main_loop_stop(int sig) {
 	main_loop_on = false;
 }
 
+/**
+ * Validate given device address and transport type. */
+static bool validate_transport(const bdaddr_t *addr, uint8_t type) {
+
+	if (BA_PCM_TYPE(type) != ba_type ||
+			!(type & BA_PCM_STREAM_CAPTURE))
+		return false;
+
+	if (ba_addr_any)
+		return true;
+
+	size_t i;
+	for (i = 0; i < ba_addrs_count; i++)
+		if (bacmp(&ba_addrs[i], addr) == 0)
+			return true;
+
+	return false;
+}
+
 static int pcm_set_hw_params(snd_pcm_t *pcm, int channels, int rate,
 		unsigned int *buffer_time, unsigned int *period_time, char **msg) {
 
@@ -85,7 +105,7 @@ static int pcm_set_hw_params(snd_pcm_t *pcm, int channels, int rate,
 
 	snd_pcm_hw_params_alloca(&params);
 
-	if ((err = snd_pcm_hw_params_any(pcm, params)) != 0) {
+	if ((err = snd_pcm_hw_params_any(pcm, params)) < 0) {
 		snprintf(buf, sizeof(buf), "Set all possible ranges: %s", snd_strerror(err));
 		goto fail;
 	}
@@ -269,7 +289,6 @@ final:
 
 static void pcm_worker_routine_exit(struct pcm_worker *worker) {
 	if (worker->pcm_fd != -1) {
-		bluealsa_close_transport(worker->ba_fd, &worker->transport);
 		close(worker->pcm_fd);
 		worker->pcm_fd = -1;
 	}
@@ -281,7 +300,6 @@ static void pcm_worker_routine_exit(struct pcm_worker *worker) {
 		snd_pcm_close(worker->pcm);
 		worker->pcm = NULL;
 	}
-	worker->eviction = true;
 	debug("Exiting PCM worker %s", worker->addr);
 }
 
@@ -309,7 +327,7 @@ static void *pcm_worker_routine(void *arg) {
 		goto fail;
 	}
 
-	w->transport.stream = BA_PCM_STREAM_CAPTURE;
+	w->transport.type = BA_PCM_TYPE(w->transport.type) | BA_PCM_STREAM_CAPTURE;
 	if ((w->pcm_fd = bluealsa_open_transport(w->ba_fd, &w->transport)) == -1) {
 		error("Couldn't open PCM FIFO: %s", strerror(errno));
 		goto fail;
@@ -344,15 +362,19 @@ static void *pcm_worker_routine(void *arg) {
 		case -1:
 			if (errno == EINTR)
 				continue;
+			error("PCM FIFO poll error: %s", strerror(errno));
+			goto fail;
 		case 0:
 			debug("Device marked as inactive: %s", w->addr);
 			pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 			pcm_max_read_len = pcm_1s_samples / 100;
 			pause_counter = pause_bytes = 0;
-			snd_pcm_close(w->pcm);
 			ffb_rewind(&buffer);
+			if (w->pcm != NULL) {
+				snd_pcm_close(w->pcm);
+				w->pcm = NULL;
+			}
 			w->active = false;
-			w->pcm = NULL;
 			timeout = -1;
 			continue;
 		}
@@ -462,6 +484,65 @@ fail:
 	return NULL;
 }
 
+static int start_pcm_worker_routine(struct ba_msg_transport *transport) {
+
+	/* check whether SCO has selected codec */
+	if (BA_PCM_TYPE(transport->type) == BA_PCM_TYPE_SCO &&
+			transport->codec == 0) {
+		debug("Skipping SCO with codec not selected");
+		return 0;
+	}
+
+	pthread_rwlock_wrlock(&workers_lock);
+
+	workers_count++;
+	if (workers_size < workers_count) {
+		workers_size += 4;  /* coarse-grained realloc */
+		if ((workers = realloc(workers, sizeof(*workers) * workers_size)) == NULL) {
+			error("Couldn't (re)allocate memory for PCM workers: %s", strerror(ENOMEM));
+			pthread_rwlock_unlock(&workers_lock);
+			return -1;
+		}
+	}
+
+	struct pcm_worker *worker = &workers[workers_count - 1];
+	memcpy(&worker->transport, transport, sizeof(worker->transport));
+	ba2str(&worker->transport.addr, worker->addr);
+	worker->active = false;
+	worker->pcm_fd = -1;
+	worker->ba_fd = -1;
+	worker->pcm = NULL;
+
+	pthread_rwlock_unlock(&workers_lock);
+
+	debug("Creating PCM worker %s", worker->addr);
+
+	if ((errno = pthread_create(&worker->thread, NULL, pcm_worker_routine, worker)) != 0) {
+		error("Couldn't create PCM worker %s: %s", worker->addr, strerror(errno));
+		workers_count--;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int start_available_transports(int ba_fd) {
+
+	struct ba_msg_transport *transports;
+	ssize_t len;
+	ssize_t i;
+
+	if ((len = bluealsa_get_transports(ba_fd, &transports)) == -1)
+		return -1;
+
+	for (i = 0; i < len; i++)
+		if (validate_transport(&transports[i].addr, transports[i].type))
+			start_pcm_worker_routine(&transports[i]);
+
+	free(transports);
+	return 0;
+}
+
 int main(int argc, char *argv[]) {
 
 	int opt;
@@ -548,12 +629,9 @@ usage:
 
 	log_open(argv[0], false, false);
 
-	bdaddr_t *ba_addrs = NULL;
-	size_t ba_addrs_count = 0;
-	bool ba_addr_any = false;
-
 	int status = EXIT_SUCCESS;
 	int ba_fd = -1;
+	int ba_event_fd = -1;
 	size_t i;
 
 	ba_addrs_count = argc - optind;
@@ -603,127 +681,76 @@ usage:
 		goto fail;
 	}
 
-	if ((ba_fd = bluealsa_open(ba_interface)) == -1) {
+	if ((ba_fd = bluealsa_open(ba_interface)) == -1 ||
+			(ba_event_fd = bluealsa_open(ba_interface)) == -1) {
 		error("BlueALSA connection failed: %s", strerror(errno));
 		goto fail;
 	}
 
-	if (bluealsa_subscribe(ba_fd, BA_EVENT_TRANSPORT_ADDED | BA_EVENT_TRANSPORT_REMOVED) == -1) {
+	if (bluealsa_event_subscribe(ba_event_fd,
+				BA_EVENT_TRANSPORT_ADDED |
+				BA_EVENT_TRANSPORT_CHANGED |
+				BA_EVENT_TRANSPORT_REMOVED) == -1) {
 		error("BlueALSA subscription failed: %s", strerror(errno));
 		goto fail;
 	}
 
+	if (start_available_transports(ba_fd) == -1) {
+		error("Couldn't start available transports: %s", strerror(errno));
+		goto fail;
+	}
+
 	struct sigaction sigact = { .sa_handler = main_loop_stop };
 	sigaction(SIGTERM, &sigact, NULL);
 	sigaction(SIGINT, &sigact, NULL);
 
 	debug("Starting main loop");
-	goto init;
-
 	while (main_loop_on) {
 
-		struct ba_msg_event event;
-		struct ba_msg_transport *transports;
+		struct ba_msg_event ev;
 		ssize_t ret;
 		size_t i;
 
-		struct pollfd pfds[] = {{ ba_fd, POLLIN, 0 }};
+		struct pollfd pfds[] = {{ ba_event_fd, POLLIN, 0 }};
 		if (poll(pfds, ARRAYSIZE(pfds), -1) == -1 && errno == EINTR)
 			continue;
 
-		while ((ret = recv(ba_fd, &event, sizeof(event), MSG_DONTWAIT)) == -1 && errno == EINTR)
+		while ((ret = recv(ba_event_fd, &ev, sizeof(ev), MSG_DONTWAIT)) == -1 &&
+				errno == EINTR)
 			continue;
-		if (ret != sizeof(event)) {
+		if (ret != sizeof(ev)) {
 			error("Couldn't read event: %s", strerror(ret == -1 ? errno : EBADMSG));
 			goto fail;
 		}
 
-init:
-		debug("Fetching available transports");
-		if ((ret = bluealsa_get_transports(ba_fd, &transports)) == -1) {
-			error("Couldn't get transports: %s", strerror(errno));
-			goto fail;
-		}
-
-		for (i = 0; i < workers_count; i++)
-			workers[i].eviction = true;
-
-		for (i = 0; i < (unsigned)ret; i++) {
-
-			size_t ii;
-
-			/* filter available transports by BT address (this check is omitted if
-			 * any address can be used), transport type and stream direction */
-			if (transports[i].type != ba_type)
-				continue;
-			if (transports[i].stream != BA_PCM_STREAM_CAPTURE && transports[i].stream != BA_PCM_STREAM_DUPLEX)
-				continue;
-			if (!ba_addr_any) {
-				bool matched = false;
-				for (ii = 0; ii < ba_addrs_count; ii++)
-					if (bacmp(&ba_addrs[ii], &transports[i].addr) == 0) {
-						matched = true;
-						break;
-					}
-				if (!matched)
-					continue;
-			}
-
-			bool matched = false;
-			for (ii = 0; ii < workers_count; ii++)
-				if (bacmp(&workers[ii].transport.addr, &transports[i].addr) == 0) {
-					workers[ii].eviction = false;
-					matched = true;
-					break;
-				}
-
-			/* start PCM worker thread */
-			if (!matched) {
-				workers_count++;
-
-				if (workers_size < workers_count) {
-
-					pthread_rwlock_wrlock(&workers_lock);
-
-					workers_size += 4; /* coarse-grained realloc */
-					if ((workers = realloc(workers, sizeof(*workers) * workers_size)) == NULL) {
-						error("Couldn't (re)allocate memory for PCM workers");
-						goto fail;
-					}
-
-					pthread_rwlock_unlock(&workers_lock);
-
-				}
-
-				struct pcm_worker *worker = &workers[workers_count - 1];
-				memcpy(&worker->transport, &transports[i], sizeof(worker->transport));
-				ba2str(&worker->transport.addr, worker->addr);
-				worker->eviction = false;
-				worker->active = false;
-				worker->pcm_fd = -1;
-				worker->ba_fd = -1;
-				worker->pcm = NULL;
-
-				debug("Creating PCM worker %s", worker->addr);
+		if (!validate_transport(&ev.addr, ev.type))
+			continue;
 
-				int ret;
-				if ((ret = pthread_create(&worker->thread, NULL, pcm_worker_routine, worker)) != 0) {
-					warn("Couldn't create PCM worker %s: %s", worker->addr, strerror(ret));
+		/* for simplicity's sake, treat change event as "remove & add" */
+		if (ev.events & BA_EVENT_TRANSPORT_CHANGED)
+			ev.events = BA_EVENT_TRANSPORT_ADDED | BA_EVENT_TRANSPORT_REMOVED;
+
+		if (ev.events & BA_EVENT_TRANSPORT_REMOVED)
+			for (i = 0; i < workers_count; i++) {
+				struct pcm_worker *worker = &workers[i];
+				if (bluealsa_event_match(&worker->transport, &ev) == 0) {
+					pthread_cancel(worker->thread);
+					pthread_join(worker->thread, NULL);
+					memcpy(worker, &workers[workers_count - 1], sizeof(*worker));
 					workers_count--;
+					break;
 				}
-
 			}
 
-		}
-
-		/* stop PCM workers designated for eviction */
-		for (i = workers_count; i > 0; i--) {
-			struct pcm_worker *worker = &workers[i - 1];
-			if (worker->eviction) {
-				pthread_cancel(worker->thread);
-				pthread_join(worker->thread, NULL);
-				memcpy(worker, &workers[workers_count - 1], sizeof(*worker));
-				workers_count--;
+		if (ev.events & BA_EVENT_TRANSPORT_ADDED) {
+			struct ba_msg_transport transport;
+			if (bluealsa_get_transport(ba_fd, &ev.addr, ev.type, &transport) == -1) {
+				error("Couldn't get transport: %s", strerror(errno));
+				goto fail;
+			}
+			if (start_pcm_worker_routine(&transport) == -1) {
+				error("Couldn't start PCM worker: %s", strerror(errno));
+				goto fail;
 			}
 		}
 
@@ -737,5 +764,7 @@ fail:
 success:
 	if (ba_fd != -1)
 		close(ba_fd);
+	if (ba_event_fd != -1)
+		close(ba_event_fd);
 	return status;
 }
diff --git a/utils/hcitop.c b/utils/hcitop.c
index 1c7be1e..37ad538 100644
--- a/utils/hcitop.c
+++ b/utils/hcitop.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - hcitop.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -9,7 +9,7 @@
  */
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <getopt.h>
diff --git a/utils/rfcomm.c b/utils/rfcomm.c
index 6794fc4..029e22e 100644
--- a/utils/rfcomm.c
+++ b/utils/rfcomm.c
@@ -1,6 +1,6 @@
 /*
  * BlueALSA - rfcomm.c
- * Copyright (c) 2016-2018 Arkadiusz Bokowy
+ * Copyright (c) 2016-2019 Arkadiusz Bokowy
  *
  * This file is a part of bluez-alsa.
  *
@@ -9,7 +9,7 @@
  */
 
 #if HAVE_CONFIG_H
-# include "config.h"
+# include <config.h>
 #endif
 
 #include <ctype.h>
@@ -124,7 +124,7 @@ usage:
 		while ((line = readline(prompt)) != NULL) {
 			char *tmp = strtrim(line);
 			if (strlen(tmp) > 0) {
-				if (bluealsa_send_rfcomm_command(ba_fd, ba_addr, build_rfcomm_command(tmp)) == -1)
+				if (bluealsa_send_rfcomm_command(ba_fd, &ba_addr, build_rfcomm_command(tmp)) == -1)
 					warn("Couldn't send RFCOMM command: %s", strerror(errno));
 				add_history(tmp);
 			}
@@ -146,7 +146,7 @@ usage:
 					sleep(duration);
 					continue;
 				}
-				if (bluealsa_send_rfcomm_command(ba_fd, ba_addr, build_rfcomm_command(tmp)) == -1)
+				if (bluealsa_send_rfcomm_command(ba_fd, &ba_addr, build_rfcomm_command(tmp)) == -1)
 					warn("Couldn't send RFCOMM command: %s", strerror(errno));
 			}
 		}
